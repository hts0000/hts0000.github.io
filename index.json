[{"categories":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 数位统计DP 数位DP强调分情况讨论 ","date":"2022-11-14","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/:0:0","tags":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"title":"基础算法整理(十二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/"},{"categories":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"content":"计数问题 package main import ( \"bufio\" \"fmt\" \"os\" ) var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) ) func power10(x int) int { ans := 1 for x \u003e 0 { ans *= 10 x-- } return ans } // 返回 1~n 中 x 出现次数 func count(n, x int) int { ans := 0 cnt := 0 // 统计 n 有多少位 for m := n; m \u003e 0; m /= 10 { cnt++ } // 从右往左枚举每一位上的 x 总数 for i := 1; i \u003c= cnt; i++ { // 我们计算第四位上 x 出现的次数 // 假设 n = abcdefg，i = 4 指向 d 这一位 // 情况1：高三位为 000~abc-1 // d 右边可以取到 000~999 共 power10(i - 1) 个数 r := power10(i - 1) // d 左边可以取到 000 ~abc-1 共 abc 种情况 l := n / (r * 10) // abc = n / power10(i) = n / (r * 10) // 当 x == 0 时，则为 001~abc-1 种情况 if x \u003e 0 { ans += l * r } else { ans += (l - 1) * r } // n / r = abcd, abcd % 10 = d d := (n / r) % 10 // 高三位等于 abc 的情况，只需要考虑 d \u003e= x，因为 d \u003c x 就不符合条件 // 前四位 abcd 均相同，后三位可取 0~efg 共 efg + 1 种情况 if d == x { ans += n % r + 1 // 此时后三位可取 000~999 共 power10(i - 1) 种情况 } else if d \u003e x { ans += r } } return ans } func main() { defer out.Flush() for { var a, b int fmt.Fscan(in, \u0026a, \u0026b) if a == 0 \u0026\u0026 b == 0 { break } if a \u003e b { a, b = b, a } for i := 0; i \u003c 10; i++ { fmt.Fprintf(out, \"%d \", count(b, i) - count(a - 1, i)) } fmt.Fprintln(out) } } ","date":"2022-11-14","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/:1:0","tags":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"title":"基础算法整理(十二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/"},{"categories":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"content":"经典模板题 338. 计数问题 233. 数字 1 的个数 状态压缩DP 状态压缩就是把一个集合的状态，压缩成一个数，用这个数的二进制表示集合的每一种情况。再使用位运算、逻辑运算等操作方便的计算状态。 ","date":"2022-11-14","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/:1:1","tags":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"title":"基础算法整理(十二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/"},{"categories":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"content":"蒙德里安的梦想 package main import ( \"bufio\" \"fmt\" \"os\" ) const ( N = 12 // 以便计算最后一列 d[m][0] M = 1\u003c\u003cN ) var reader = bufio.NewReader(os.Stdin) var writer = bufio.NewWriter(os.Stdout) var st [M]bool // 字典表，存储所有位置的合法情况 func initStatus(n int){ for i:=0;i\u003c1\u003c\u003cn;i++{ cnt:=0 st[i] = true for j:=0;j\u003cn;j++{ // 遇到1，被占， 且统计的空格数为奇数，无法填充竖着的长方形 if i\u003e\u003ej \u0026 1 \u003e 0 { if cnt\u00261\u003e0{ st[i] = false break } cnt=0 continue } cnt++ } // 判断剩下的统计数是否奇数 if st[i] \u0026\u0026 cnt\u00261\u003e0{ st[i] = false } } } // - **数位统计DP**: 所谓的状态压缩DP，就是用二进制数保存状态。为什么不直接用数组记录呢？因为用一个二进制数记录方便作位运算。前面做过的八皇后，八数码，也用到了状态压缩 // - 计数问题: 蒙德里安的梦想, 求把N*M的棋盘分割成若干个1*2的的长方形，有多少种方案。 // - 核心: 找到所有横放 1 X 2 小方格的方案数，因为所有横放确定了，那么竖放方案是唯一的。 // - 状态定义: // - 集合: 用`f[i][j]` 记录第i列第j个状态的所有合法方案。j二进制中1表示对应行的上一列有横放格子并捅出到本列中。 // - 属性: 方案数 // - 状态计算: `f[i][j] += f[i - 1][k]` // - i 列和 i - 1 列同一行不同时捅出来 ； 本列捅出来的状态j和上列捅出来的状态k求或，得到上列是否存在连续奇数空行状态，奇数空行不转移。 // - `f[m][0]` 表示没有m列没有涌出。 var f [N][M]int func solution(n,m int) int{ initStatus(n) f[0][0] = 1 for i:=1;i\u003c=m;i++{ for j:=0;j\u003c1\u003c\u003cn;j++{ f[i][j] = 0 // 重置统计 for k:=0;k\u003c1\u003c\u003cn;k++{ if j\u0026k==0 \u0026\u0026 st[j|k] { f[i][j] +=f[i-1][k] } } } } return f[m][0] // 最后一列 } func main() { var n,m int for { fmt.Fscan(reader, \u0026n, \u0026m) if n | m == 0 { break } fmt.Fprintln(writer, solution(n,m)) } writer.Flush() } ","date":"2022-11-14","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/:2:0","tags":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"title":"基础算法整理(十二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/"},{"categories":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"content":"91. 最短Hamilton路径 package main import \"fmt\" /* 举例说明：如果是4个点 0-\u003e1-\u003e2-\u003e3 0-\u003e2-\u003e1-\u003e3 ...总方案是3！，剩下的4种方法略... 假设第一种走法的方案，距离是10，第二种走法是20， 则第二种走法后面的点再怎么走的方案也就不被采纳，并且后面点的方法是可以直接套在第一种方案后的。 所以我们就可以只关注两点： 1、那些点是走过的 2、现在走在了哪个点上 状态表示： f[status][j] 第一维表示走过的所有点，第二维度表示现在落在哪个点上 状态转移： f[status][j]=f[status_k-j][k]+weight[k][j] k表示当前走到的j点的前一步k点，并且k点的所有状态集合status_k中不包含j点 status的状态使用二进制状态压缩，1，0分别表示走过和没走过 */ const ( N = 20 M = 1 \u003c\u003c 20 ) var ( n int f [M][N]int weight [N][N]int ) func main() { fmt.Scan(\u0026n) // 输入 for i := 0; i \u003c n; i++ { for j := 0; j \u003c n; j++ { fmt.Scan(\u0026weight[i][j]) } } // 初始化f数组 for i := 0; i \u003c M; i++ { for j := 0; j \u003c N; j++ { f[i][j] = 0x3f3f3f3f } } f[1][0] = 0 // 在起点的状态，还没走，所以距离是0 for i := 0; i \u003c 1\u003c\u003cn; i++ { for j := 0; j \u003c n; j++ { if i\u003e\u003ej\u00261 \u003e 0 { // 查看集合i中的j点有没有走过，只有走过的点的集合才是可以状态转移的合法状态 for k := 0; k \u003c n; k++ { //枚举所有的整数 if i-(1\u003c\u003cj)\u003e\u003ek\u00261 \u003e 0 { //当前状态i集合还不包括j点，所以集合中要减去，减去后的集合也得满足合法的状态转移条件 // 所以k点是已经走过的，二进制1表示。 f[i][j] = min(f[i][j], f[i-(1\u003c\u003cj)][k]+weight[k][j]) } } } } } fmt.Println(f[(1\u003c\u003cn)-1][n-1]) } func min(a, b int) int { if a \u003c b { return a } return b } ","date":"2022-11-14","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/:3:0","tags":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"title":"基础算法整理(十二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/"},{"categories":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"content":"经典模板题 291. 蒙德里安的梦想 最短Hamilton路径 树形DP ","date":"2022-11-14","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/:3:1","tags":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"title":"基础算法整理(十二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/"},{"categories":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"content":"没有上司的舞会 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 6010 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) h, e, ne [N]int idx int happy [N]int f [N][2]int hasFather [N]bool n int ) func add(a, b int) { e[idx] = b ne[idx] = h[a] h[a] = idx idx++ } func dfs(u int) { f[u][1] = happy[u] for i := h[u]; i != -1; i = ne[i] { j := e[i] dfs(j) f[u][1] += f[j][0] f[u][0] += max(f[j][0], f[j][1]) } } func main() { defer out.Flush() fmt.Fscan(in, \u0026n) for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026happy[i]) } for i := 0; i \u003c N; i++ { h[i] = -1 } for i := 0; i \u003c n - 1; i++ { var a, b int fmt.Fscan(in, \u0026a, \u0026b) add(b, a) hasFather[a] = true } root := 1 for hasFather[root] { root++ } dfs(root) fmt.Fprintln(out, max(f[root][0], f[root][1])) } func max(a, b int) int { if a \u003e b { return a } return b } 记忆化搜索 ","date":"2022-11-14","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/:4:0","tags":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"title":"基础算法整理(十二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/"},{"categories":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"content":"滑雪问题 ","date":"2022-11-14","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/:5:0","tags":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"title":"基础算法整理(十二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/"},{"categories":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"content":"滑雪 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 310 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) g [N][N]int f [N][N]int dx = [4]int{-1, 0, 1, 0} dy = [4]int{0, 1, 0, -1} n, m int ) func dp(x, y int) int { if f[x][y] != -1 { return f[x][y] } f[x][y] = 1 for i := 0; i \u003c 4; i++ { a := x + dx[i] b := y + dy[i] if a \u003e= 1 \u0026\u0026 a \u003c= n \u0026\u0026 b \u003e= 1 \u0026\u0026 b \u003c= m \u0026\u0026 g[x][y] \u003e g[a][b] { f[x][y] = max(f[x][y], dp(a, b) + 1) } } return f[x][y] } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { fmt.Fscan(in, \u0026g[i][j]) } } for i := 0; i \u003c N; i++ { for j := 0; j \u003c N; j++ { f[i][j] = -1 } } ans := 0 for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { ans = max(ans, dp(i, j)) } } fmt.Fprintln(out, ans) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-14","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/:5:1","tags":["算法","算法整理","动态规划","数位DP","状态压缩DP","树形DP","记忆化搜索"],"title":"基础算法整理(十二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%BA%8C/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 线性DP 递推方程有明显的线性关系 ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:0:0","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"数字三角形 ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:1:0","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"从上到下 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 510 const INF int = 1e9 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 存放数字三角形 nums [N][N]int // dp 数组 // f[i][j] 表示从起点走到 [i,j] 点的最大路径和 f [N][N]int // n 行的数字三角形 n int ) func main() { defer out.Flush() fmt.Fscan(in, \u0026n) for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= i; j++ { fmt.Fscan(in, \u0026nums[i][j]) } } // 初始化为 -INF // 因为是从上往下遍历，会用到 [i-1][j] // 因此每一行需要多初始化一列，给下一行的使用 for i := 0; i \u003c= n; i++ { for j := 0; j \u003c= i + 1; j++ { f[i][j] = -INF } } // 初始化起点，表示从起点走到起点的最大路径和 f[1][1] = nums[1][1] for i := 2; i \u003c= n; i++ { for j := 1; j \u003c= i; j++ { f[i][j] = max(f[i-1][j-1], f[i-1][j]) + nums[i][j] } } ans := -INF // 遍历最后一行，获取最大路径和 for i := 1; i \u003c= n; i++ { ans = max(ans, f[n][i]) } fmt.Fprintln(out, ans) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:1:1","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"从下往上 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 510 const INF int = 1e9 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 存放数字三角形 nums [N][N]int // dp 数组 // f[1][1] 表示从最下面一层走到起点的最大路径和 f [N][N]int // n 行的数字三角形 n int ) func main() { defer out.Flush() fmt.Fscan(in, \u0026n) for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= i; j++ { fmt.Fscan(in, \u0026nums[i][j]) } } // 从下往上遍历，只会用到三角形内的值，因此不用初始化 for i := n; i \u003e= 1; i-- { for j := i; j \u003e= 1; j-- { f[i][j] = max(f[i+1][j], f[i+1][j+1]) + nums[i][j] } } fmt.Fprintln(out, f[1][1]) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:1:2","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"经典模板题 898. 数字三角形 剑指 Offer II 100. 三角形中最小路径之和 ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:1:3","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"最长上升子序列 ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:2:0","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"最长上升子序列朴素 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 1010 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 存储输入 a [N]int // dp 数组，f[i] 表示以 i 结尾的最长子序列长度 f [N]int n int ) func main() { defer out.Flush() // 处理输入 fmt.Fscan(in, \u0026n) for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026a[i]) } // 初始化，每个以 i 结尾的子序列长度至少为1 for i := 1; i \u003c= n; i++ { f[i] = 1 } // 枚举每个数字结尾 for i := 1; i \u003c= n; i++ { // 遍历 i 前面所有数字 for j := 1; j \u003c= i; j++ { // 题目要求严格小于 if a[j] \u003c a[i] { // f[j] 表示以 j 结尾的最长子序列长度，加1表示加上 i 的长度 f[i] = max(f[i], f[j] + 1) } } } // 遍历一遍 dp 数组获取最大值 ans := 0 for i := 1; i \u003c= n; i++ { ans = max(ans, f[i]) } fmt.Fprintln(out, ans) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:2:1","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"最长上升子序列优化 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 100010 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) a [N]int f [N]int n int ) func main() { defer out.Flush() fmt.Fscan(in, \u0026n) for i := 0; i \u003c n; i++ { fmt.Fscan(in, \u0026a[i]) } length := 0 for i := 0; i \u003c n; i++ { l, r := 0, length for l \u003c r { mid := (l + r + 1) \u003e\u003e 1 if f[mid] \u003c a[i] { l = mid } else { r = mid - 1 } } length = max(length, r + 1) f[r + 1] = a[i] } fmt.Fprintln(out, length) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:2:2","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"经典模板题 895. 最长上升子序列 896. 最长上升子序列 II ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:2:3","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"最长公共子序列 ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:3:0","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"最长公共子序列 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 1010 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) a, b string // f[i][j] 表示在 a 字符串前 i 个字符中出现，且在 b 字符串前 j 个字符中出现的最长公共子序列长度 f [N][N]int n, m int ) func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) fmt.Fscan(in, \u0026a, \u0026b) // 让字符串从下标1开始 a = \" \" + a b = \" \" + b for i := 1; i \u003c= n; i ++ { for j := 1; j \u003c= m; j ++ { f[i][j] = max(f[i-1][j], f[i][j-1]) if a[i] == b[j] { f[i][j] = max(f[i][j], f[i-1][j-1] + 1) } } } fmt.Fprintln(out, f[n][m]) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:3:1","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"经典模板题 897. 最长公共子序列 剑指 Offer II 095. 最长公共子序列 ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:3:2","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"编辑距离 ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:4:0","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"最短编辑距离 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 1010 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) a, b string // f[i][j] 表示将 a 的前 i 个字符变成 b 的前 j 个字符最少需要多少步 f [N][N]int // 字符串长度 n, m int ) func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026a) fmt.Fscan(in, \u0026m, \u0026b) a = \" \" + a b = \" \" + b // 表示将 a 的前0个字符变成 b 的前 i 个字符最少需要多少步 for i := 1; i \u003c= m; i++ { f[0][i] = i } // 表示将 a 的前 i 个字符变成 b 的前 0 个字符最少需要多少步 for i := 1; i \u003c= n; i++ { f[i][0] = i } for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { // f[i][j-1]+1 表示 a 的前 i 个字符与 b 的前 j-1 个字符相同需要的最小步骤， // +1 表示为 a 字符串增加一个字符，步骤数 +1 // f[i-1][j]+1 表示 a 的前 i-1 个字符与 b 的前 j 个字符相同需要的最小步骤， // +1 表示为 a 字符串删除一个字符，步骤数 +1 f[i][j] = min(f[i][j-1]+1, f[i-1][j]+1) // 当前字符不相同，需要修改当前字符 if a[i] != b[j] { // f[i-1][j-1] 表示 a 的前 i-1 个字符与 b 的前 j-1 个字符相同需要的最小步骤， // +1 表示将 a 的 i 字符修改为 b 的 j 字符，步骤数 +1 f[i][j] = min(f[i][j], f[i-1][j-1]+1) // 如果当前字符相同，那么当前步骤数就是使得 a 的前 i-1 个字符与 b 的前 j-1 个字符相同需要的最小步骤 } else { f[i][j] = min(f[i][j], f[i-1][j-1]) } } } fmt.Fprintln(out, f[n][m]) } func min(a, b int) int { if a \u003c b { return a } return b } ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:4:1","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"经典模板题 902. 最短编辑距离 72. 编辑距离 899. 编辑距离 区间DP ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:4:2","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"石子合并 ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:5:0","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"石子合并 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 310 const INF int = 1e9 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 存储输入和前缀和 s [N]int // f[i][j] 表示合并 [i~j] 堆石子所需最小代价 f [N][N]int n int ) func main() { defer out.Flush() fmt.Fscan(in, \u0026n) // 读取输入 for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026s[i]) } // 处理前缀和 for i := 1; i \u003c= n; i++ { s[i] += s[i-1] } // f[i][i] 单独一堆的石子，合并单独一堆石子代价为0 for i := 1; i \u003c= n; i++ { f[i][i] = 0 } // length 枚举区间范围，从 2 开始是因为上面已经初始化了区间范围为 1 的情况 for length := 2; length \u003c= n; length++ { // 枚举区间左端点 for i := 1; i + length - 1 \u003c= n; i++ { // l, r 表示每一个 [l,r] 小区间，最终枚举 [1,n] 整个区间 // [1,2], [2,3], [3,4], ... // [1,3], [2,4], ... // [1,4], ... l, r := i, i + length - 1 // 表示合并 [l,r] 这个区间代价一开始为无穷 f[l][r] = INF // 以 k 为中点，划分为左右两块区间， // f[i][j] 的值就为合并左区间的最小代价 f[l][k] + 合并右区间的最小代价 f[k+1][r] + 合并左右区间的代价 s[r] - s[l-1] // s[r] - s[l-1] 用前缀和快速求 [l,r] 这段区间的值 // 为什么要加上 [l,r] 这段区间的值？因为最后还需要合并左右两堆石子 for k := l; k \u003c r; k++ { f[l][r] = min(f[l][r], f[l][k] + f[k+1][r] + s[r] - s[l-1]) } } } fmt.Fprintln(out, f[1][n]) } func min(a, b int) int { if a \u003c b { return a } return b } 计数类DP ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:5:1","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"整数划分 ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:6:0","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"content":"整数划分 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 1010 const MOD int= 1e9 + 7 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) f [N]int n int ) func main() { defer out.Flush() fmt.Fscan(in, \u0026n) f[0] = 1 // 将整数划分看成是完全背包问题 // f[j] 表示 1~n 当中选，体积恰好是 j 的方案数 for i := 1; i \u003c= n; i++ { for j := i; j \u003c= n; j++ { f[j] = (f[j] + f[j-i]) % MOD } } fmt.Fprintln(out, f[n]) } ","date":"2022-11-13","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/:6:1","tags":["算法","算法整理","动态规划","线性DP","区间DP","计数DP"],"title":"基础算法整理(十一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81%E4%B8%80/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 背包问题 有 N 件物品和一个容量为 V 的背包。物品可能多有个属性——费用Ci、价值Wi、数量Si。求解将哪些物品装入背包可使价值总和最大。 01背包：每个物品只有一个 完全背包：每个物品有无限个 多重背包：每个物品有给定数量 分组背包：有N组物品，每组物品中只能选一个物品 ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:0:0","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"01背包 ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:1:0","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"01背包朴素 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 1010 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 存储第 i 件物品的体积和价值 v, w [N]int // dp 数组，第一维表示物品，第二维表示容量 // f[i][j] 表示把物品 i 放进容量为 j 的背包的最大价值 f [N][N]int // n 是物品的个数，m 是背包容量 n, m int ) func main() { defer out.Flush() // 处理输入 fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026v[i], \u0026w[i]) } // 初始化，表示0件物品放进容量为 i 的背包里的最大价值为0 for i := 0; i \u003c= m; i++ { f[0][i] = 0 } // i 枚举物品 for i := 1; i \u003c= n; i++ { // j 枚举容量 for j := 1; j \u003c= m; j++ { // 如果背包容量放不下物品 i 了，最大价值等于不放物品 i 的最大价值 if j \u003c v[i] { f[i][j] = f[i-1][j] // 能放下物品 i，则比较放与不放哪种价值大 // f[i-1][j] 表示不放物品 i 的最大价值 // f[i-1][j-v[i]] + w[i] 表示放物品 i 的最大价值 } else { f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i]) } } } fmt.Fprintln(out, f[n][m]) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:1:1","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"01背包优化 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 1010 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 存储第 i 件物品的体积和价值 v, w [N]int // dp 数组 f [N]int // n 是物品的个数，m 是背包容量 n, m int ) func main() { defer out.Flush() // 处理输入 fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026v[i], \u0026w[i]) } // 初始化，表示0件物品放进容量为 i 的背包里的最大价值为0 for i := 0; i \u003c= m; i++ { f[i] = 0 } // i 枚举物品 for i := 1; i \u003c= n; i++ { // j 枚举容量 for j := m; j \u003e= v[i]; j-- { // f[j] 表示不选第 i 件物品的最大价值，f[j-v[i]] + w[i] 表示选择第 i 件物品的最大价值 f[j] = max(f[j], f[j-v[i]] + w[i]) } } fmt.Fprintln(out, f[m]) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:1:2","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"经典模板题 2. 01背包问题 ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:1:3","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"完全背包 ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:2:0","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"完全背包朴素 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 1010 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 存储第 i 件物品的体积和价值 v, w [N]int // dp 数组，第一维表示物品，第二维表示容量 f [N][N]int // n 是物品的数量，m 是背包容量 n, m int ) func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026v[i], \u0026w[i]) } // 枚举物品 for i := 1; i \u003c= n; i++ { // 枚举容量 for j := 1; j \u003c= m; j++ { // 枚举物品个数 for k := 0; k * v[i] \u003c= j; k++ { // f[i][j] 表示第 i 个物品取 k 个放进容量为 j 的背包中的最大价值 f[i][j] = max(f[i][j], f[i-1][j-v[i]*k] + w[i]*k) } } } fmt.Fprintln(out, f[n][m]) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:2:1","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"完全背包优化 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 1010 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 存储第 i 件物品的体积和价值 v, w [N]int // dp 数组 f [N]int // n 是物品的数量，m 是背包容量 n, m int ) func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026v[i], \u0026w[i]) } for i := 1; i \u003c= n; i++ { for j := v[i]; j \u003c= m; j++ { f[j] = max(f[j], f[j-v[i]] + w[i]) } } fmt.Fprintln(out, f[m]) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:2:2","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"经典模板题 3. 完全背包问题 ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:2:3","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"多重背包 ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:3:0","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"多重背包朴素 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 110 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 存储第 i 件物品的体积、价值和数量 v, w, s [N]int // dp 数组， // f[i][j] 表示数量 s[i] 的物品 i，存入容量为 j 的背包中的最大价值 f [N][N]int // n 是物品的数量，m 是背包容量 n, m int ) func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026v[i], \u0026w[i], \u0026s[i]) } // 枚举物品 for i := 1; i \u003c= n; i++ { // 枚举容量 for j := 1; j \u003c= m; j++ { // 枚举物品数量从 0 ~ s[i]，且总体积不超过 j for k := 0; k \u003c= s[i] \u0026\u0026 k * v[i] \u003c= j; k++ { // f[i][j] 表示第 i 个物品取 k 个放进容量为 j 的背包中的最大价值，0 \u003c= k \u003c= s[i] f[i][j] = max(f[i][j], f[i-1][j-v[i]*k] + w[i]*k) } } } fmt.Fprintln(out, f[n][m]) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:3:1","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"多重背包优化 多重背包二进制优化 把物品 i 的数量 s[i]，按照二进制分成若干个，$2^0 + 2^1 + … + 2^{k} + s[i] - 2^{k} = s[i]$，将拆分的每一个数看成一个单独的物品。把所有 s[i] 拆分之后，对所有拆分的物品求一次01背包问题。 package main import ( \"bufio\" \"fmt\" \"os\" ) // 物品个数 N \u003c= 1000 // 物品数量 S \u003c= 2000 // 每个物品都按照二进制拆分成了 logS 个 // 所以总的物品个数是 N * logS 上取整 const N int = 25010 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 存储第 i 件物品的体积、价值和数量 v, w [N]int // dp 数组， // f[i][j] 表示数量 s[i] 的物品 i，存入容量为 j 的背包中的最大价值 f [N]int // n 是物品的数量，m 是背包容量 n, m int ) func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) // 将物品 i 的数量按照二进制拆成若干个 cnt := 0 for i := 0; i \u003c n; i++ { var a, b, s int fmt.Fscan(in, \u0026a, \u0026b, \u0026s) k := 1 // 二进制拆分 for k \u003c= s { cnt++ v[cnt] = a * k w[cnt] = b * k s -= k k *= 2 } // 2^k 次方是小于 s[i] 的最大二进制数，剩下的数为 s[i] - 2^k if s \u003e 0 { cnt++ v[cnt] = a * s w[cnt] = b * s } } // 物品个数为拆分了多少个 n = cnt // 对所有拆分的物品做01背包 for i := 1; i \u003c= n; i++ { for j := m; j \u003e= v[i]; j-- { f[j] = max(f[j], f[j-v[i]] + w[i]) } } fmt.Fprintln(out, f[m]) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:3:2","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"经典模板题 4. 多重背包问题 I 5. 多重背包问题 II ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:3:3","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"分组背包 ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:4:0","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"分组背包朴素 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 110 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // v[i][j] 表示第 i 组里的物品 j 的体积是多少 v, w [N][N]int // s[i] 表示第 i 组里有多少种物品 s [N]int // f[i][j] 表示把每 i 组物品选一个，放进容量为 j 的背包中的最大价值 f [N][N]int // 物品组数和背包容量 n, m int ) func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) // 读取输入 for i := 1; i \u003c= n; i++ { // 第 i 组有多少种物品 fmt.Fscan(in, \u0026s[i]) // 第 i 组中每个物品的体积和价值 for j := 1; j \u003c= s[i]; j++ { fmt.Fscan(in, \u0026v[i][j], \u0026w[i][j]) } } // 枚举物品组 for i := 1; i \u003c= n; i++ { // 枚举容量 for j := 0; j \u003c= m; j++ { // 不选第 i 组的最大价值 f[i][j] = f[i-1][j] // 枚举物品组中每一个物品 for k := 1; k \u003c= s[i] ; k++ { // 容量能够放下第 i 组的物品 k if v[i][k] \u003c= j { // 第 i 组选择物品 k 放入容量为 j 的背包中的最大价值 f[i][j] = max(f[i][j], f[i-1][j-v[i][k]] + w[i][k]) } } } } fmt.Fprintln(out, f[n][m]) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:4:1","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"分组背包优化 只优化了空间 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 110 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // v[i][j] 表示第 i 组里的物品 j 的体积是多少 v, w [N][N]int // s[i] 表示第 i 组里有多少种物品 s [N]int // f[j] 表示把每一组物品各选一个，放进容量为 j 的背包中的最大价值 f [N]int // 物品组数和背包容量 n, m int ) func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) // 读取输入 for i := 1; i \u003c= n; i++ { // 第 i 组有多少种物品 fmt.Fscan(in, \u0026s[i]) // 第 i 组中每个物品的体积和价值 for j := 1; j \u003c= s[i]; j++ { fmt.Fscan(in, \u0026v[i][j], \u0026w[i][j]) } } // 枚举物品组 for i := 1; i \u003c= n; i++ { // 枚举容量 for j := m; j \u003e= 0; j-- { // 枚举物品组中每一个物品 for k := 1; k \u003c= s[i] ; k++ { // 容量能够放下第 i 组的物品 k if v[i][k] \u003c= j { // 第 i 组选择物品 k 放入容量为 j 的背包中的最大价值 f[j] = max(f[j], f[j-v[i][k]] + w[i][k]) } } } } fmt.Fprintln(out, f[m]) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:4:2","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","动态规划","背包问题"],"content":"经典模板题 9. 分组背包问题 ","date":"2022-11-01","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/:4:3","tags":["算法","算法整理","动态规划","背包问题"],"title":"基础算法整理(十)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%8D%81/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 最小生成树 最小生成树问题，对应的图都是无向图。 最小生成树问题允许有负边 不能有环 ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:0:0","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"Prim算法(普里姆算法) Prim算法和Dijkstra算法很相似 ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:1:0","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"朴素版Prim算法 稠密图用朴素版Prim算法，时间复杂度O(n^2) 算法步骤： 将所有点初始化为正无穷 迭代n次 每次找到不在集合当中的，距离集合最小的点t。集合表示已经加入生成树的点，距离集合最小定义为——点i到集合内任意一点的距离，是所有不在集合中的点中最小的。点i到集合的距离定义为——点i到集合内点的所有边中的最小值 用t更新其他点到集合的距离 把t加入集合 ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:1:1","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"朴素版Prim算法代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 510 const INF int = 0x3f3f3f3f var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 邻接矩阵存储图 g [N][N]int // 点i到集合的距离 dist [N]int // 点i是否在集合中 st [N]bool n, m int ) func prim() int { // 初始化距离 for i := 1; i \u003c= n; i++ { dist[i] = INF } // res表示最小生成树各边权值和 res := 0 // 遍历n次 for i := 0; i \u003c n; i++ { t := -1 // 找到不在集合当中的，距离集合最近的点t for j := 1; j \u003c= n; j++ { // j不在集合中 if ! st[j] \u0026\u0026 (t == -1 || dist[t] \u003e dist[j]) { t = j } } // 把t点加入集合 st[t] = true // 如果不是第一次找，而且不在集合中的点到集合最小距离是INF了，那么该图不是连通图 if i != 0 \u0026\u0026 dist[t] == INF { return INF } // 累加权值和 if i != 0 { res += dist[t] } // 用t更新其他点到集合的距离 for j := 1; j \u003c= n; j++ { dist[j] = min(dist[j], g[t][j]) } } return res } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= n; j++ { if i == j { g[i][j] = 0 } else { g[i][j] = 0x3f3f3f3f } } } for ; m \u003e 0; m-- { var a, b, c int fmt.Fscan(in, \u0026a, \u0026b, \u0026c) // 无向图，建边的时候两个方向都建一次 g[a][b] = min(g[a][b], c) g[b][a] = min(g[b][a], c) } // 如果不存在最小生成树，返回INF // 存在则返回最小生成树各边的权值和 t := prim() if t == INF { fmt.Fprintln(out, \"impossible\") } else { fmt.Fprintln(out, t) } } func min(a, b int) int { if a \u003c b { return a } return b } ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:1:2","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"经典模板题 858. Prim算法求最小生成树 ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:1:3","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"堆优化版Prim算法 稀疏图用堆优化版Prim算法，时间复杂度O(mlogn)，堆优化版Prim算法不如Kruskal算法简单好写，因此稀疏图一般使用Kruskal算法实现。 ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:1:4","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"Kruskal(克鲁斯卡尔算法) 时间复杂度O(mlogm) Kruskal算法是排序+并查集的应用，算法性能瓶颈主要在排序部分。 算法步骤： 对所有边排序O(mlogm) 枚举每条边a-\u003eb，权重c 如果a-\u003eb不连通，把这条边加入集合中，这一步用并查集来做O(m) ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:2:0","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"Kruskal算法代码模板 package main import ( \"fmt\" \"bufio\" \"os\" \"sort\" ) const N int = 100010 const M int = 200010 // Kruskal算法只要能遍历到所有边即可 type Edge struct { a, b, w int } var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 并查集中的p数组，存储所有点 // 用于快速判断两个点是否在同一集合中 p [N]int n, m int ) // 寻找x的父节点，并做状态压缩，并查集的内容 func find(x int) int { if x != p[x] { p[x] = find(p[x]) } return p[x] } // 给定一个所有边的集合，返回是否存在最小生成树及最小生成树对应的权值和 func kruskal(edges []*Edge) (bool, int) { var ( // 记录最小生成树对应的权值和 res int // 记录已经联通的边数 // 连通n个点只需要n-1条边，用cnt来判断是否有最小生成树 cnt int ) // 先对所有边根据边权从小到大排序 sort.Slice(edges, func(i, j int) bool { return edges[i].w \u003c edges[j].w }) // 从小到大遍历所有边，得到的生成树就是最小的 for i := 0; i \u003c m; i++ { a := edges[i].a b := edges[i].b w := edges[i].w // 用并查集判断a、b点是否在同一集合中 // 在同一集合中意味着，a、b点连通了 a, b = find(a), find(b) // 如果a、b不连通 if a != b { // 连通a、b p[b] = a // 累加边权和 res += w // 记录生成树边数 cnt++ } } // 连接n个点，至少需要n-1条边，边数少于n - 1条，则图不存在最小生成树 return cnt \u003c n - 1, res } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { p[i] = i } edges := make([]*Edge, 0, M) for i := 0; i \u003c m; i++ { var a, b, w int fmt.Fscan(in, \u0026a, \u0026b, \u0026w) edges = append(edges, \u0026Edge{a, b, w}) } flag, res := kruskal(edges) if flag { fmt.Fprintln(out, \"impossible\") } else { fmt.Fprintln(out, res) } } ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:2:1","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"经典模板题 859. Kruskal算法求最小生成树 二分图 二分图指的是图中所有点能划分到两个集合中，所有的边都在两个集合之间连接，集合内部没有边。 二分图的题目通常是判断一个图是否是二分图。 一个图是二分图，当且仅当这个图不含有奇数环。反之，一个图不含有奇数环，那么它一定是一个二分图。 环是从一个点出发经过m条边后，能回到自身。奇数环指的是m为奇数。 当一个点i属于集合a时，那么所有与它连接的点j必须属于集合b。 由于图中不含奇数环，所以划分点到不同集合中的步骤一定不会矛盾。 ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:2:2","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"染色法判断图是否为二分图 就是DFS，时间复杂度O(n + m) 染色过程就是把一个点确认颜色，比如白色，然后深度搜索把该点相连的其他点染为黑色。 ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:3:0","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"染色法代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const ( N int = 100010 M int = 200010 ) var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 邻接表存储图 h [N]int e, ne [M]int idx int // 存储改点染的什么颜色，1为白色，2为黑色 color [N]int n, m int ) func add(a, b int) { e[idx] = b ne[idx] = h[a] h[a] = idx idx++ } func dfs(n, c int) bool { // 先把当前点染为颜色c color[n] = c // 遍历该点所有邻边，将其他点染为另一种颜色 for i := h[n]; i != -1; i = ne[i] { j := e[i] if color[j] == 0 { // 3 - c，当前颜色是1，其他点就染为2；当前颜色是2，其他点就染为1； // 递归下去染色，任意一个连通块染色失败，就返回false if ! dfs(j, 3 - c) { return false } // 当前点与它连通的点颜色一样，发生矛盾 } else if color[j] == color[n] { return false } } return true } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { h[i] = -1 } for ; m \u003e 0; m-- { var a, b int fmt.Fscan(in, \u0026a, \u0026b) // 无向图 add(a, b); add(b, a) } flag := true // 图不一定是连通图，所以需要遍历所有点，把每个连通块都尝试染色 // 如果有连通块染色失败，说明该图无法二分，也说明有奇数环 for i := 1; i \u003c= n; i++ { if color[i] == 0 { if ! dfs(i, 1) { flag = false break } } } if flag { fmt.Fprintln(out, \"Yes\") } else { fmt.Fprintln(out, \"No\") } } ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:3:1","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"经典模板题 860. 染色法判定二分图 ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:3:2","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"匈牙利算法——二分图最大匹配问题 求二分图的最大匹配，时间复杂度最坏情况O(mn)，实际运行情况远小于这个时间复杂度，效果很好。 二分图最大匹配问题指的是，二分图中的集合a和集合b中的点，一一匹配的最大可能。 如图两个集合Boys和Girls，为每个男生匹配一个女生，最多能匹配多少个。 算法运行步骤： 遍历集合Boys 遍历Boys[i]的所有可匹配女生，任选一个匹配(如果是有权图，那么选权值最大的，就成为二分图的最优匹配) 如果Boys[i]的所有可匹配女生都已经分配了 那么尝试让这些已匹配的人去匹配其他人，空出位置 图中B2只能匹配G2，但是G2已经被分配给B1了，那么尝试让B1匹配其他人，以增加匹配数。 算法运行完之后的情侣数量就是最大匹配数。 ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:4:0","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const ( N int = 510 M int = 100010; ) var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 邻接表存储 h [N]int e, ne [M]int idx int // 集合b的点匹配集合a的哪个点 match [N]int // 集合a每个点遍历的时候，标记集合b那些点被访问了，避免递归时发生重复选择同一目标 // 递归子树去重 st [N]bool // n1表示a集合有多少点，n2表示b集合有多少点，m表示边的数量 n1, n2, m int ) func add(a, b int) { e[idx] = b ne[idx] = h[a] h[a] = idx idx++ } // 寻找x能否匹配到一个集合b中的点 func find(x int) bool { // 遍历集合a中点x能匹配的所有集合b中的点 for i := h[x]; i != -1; i = ne[i] { // j是集合b中的点 j := e[i] // 同一颗递归树中，j必须没被用过才能选 if ! st[j] { // 这里把j标记为true，在下一层递归时，点j对应的点就不能再次匹配点j了，避免死循环 // 在同一颗递归树里面，点x不能再次匹配点j，必须找别的点，如果找不到，那么下面的判断就失败，不会赋值 // 回溯算法中的子树去重 st[j] = true // j点没有匹配集合a中的点 // 或者点j对应的点，能匹配其他点 if match[j] == 0 || find(match[j]) { // 实际记录时，记录的是集合b中哪个点与集合a中的点匹配 match[j] = x return true } } } return false } func main() { defer out.Flush() fmt.Fscan(in, \u0026n1, \u0026n2, \u0026m) for i := 1; i \u003c= n1; i++ { h[i] = -1 } for ; m \u003e 0; m-- { var a, b int fmt.Fscan(in, \u0026a, \u0026b) // 虽然是无向图，但是算法遍历过程中只会从集合a找向集合b // 所以b-\u003ea的边用不到 add(a, b) } // 匹配数量 res := 0 for i := 1; i \u003c= n1; i++ { // 每个点匹配开始都要把st清空，st只负责子树去重 // 是否匹配成功还要看match for i := 1; i \u003c N; i++ { st[i] = false } // i能否匹配到一个点 if find(i) { res++ } } fmt.Fprintln(out, res) } ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:4:1","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"content":"经典模板题 861. 二分图的最大匹配 ","date":"2022-10-31","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/:4:2","tags":["算法","算法整理","最小生成树","Prim","Kruskal","二分图","二分图最大匹配","染色法","匈牙利算法"],"title":"基础算法整理(九)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B9%9D/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 最短路 最短路问题分为两类： 单源最短路：求一个点到其他所有点的最短距离 多源汇最短路：源点就是起点，汇点就是终点，可能有多个询问，每次询问一个点到另一个点的最短距离 单源最短路根据边权值的正负，可以使用不同的算法： n为图的点的数量，m为图的边的数量 边权值为正 朴素版Dijkstra算法，时间复杂度O(n^2)，与边数量没有关系，比较适合稠密图 堆优化版Dijkstra算法，时间复杂度O(mlogn)，如果是稀疏图，或n数量比较大，应该使用堆优化版 边权值存在负数 Bellman-Ford算法，时间复杂度O(nm)，求经过不超过k条边的最短路，只能用Bellman-Ford算法来做 SPFA算法，时间复杂度一般情况下为O(m)，最坏情况为O(nm)，是对Bellman-Ford算法的优化，SPFA算法一般情况下优于Bellman-Ford算法，但是有的情况只能用Bellman-Ford算法来做 多源汇最短路只有一种算法：Floyd算法，时间复杂度为O(n^3) ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:0:0","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"单源最短路 ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:0","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"朴素Dijkstra算法代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 510 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 用邻接矩阵存储稠密图 g [N][N]int // 存储起点到各个点的最短距离 d [N]int // 存储是否已经确定1-\u003ei的最短路 st [N]bool n, m int ) func dijkstra() int { // 初始化d为正无穷，表示所有点都不可达 for i := 1; i \u003c= n; i++ { d[i] = 0x3f3f3f3f } // 1号点为起点，初始化起点到起点距离为0 d[1] = 0 for i := 0; i \u003c n; i++ { t := -1 // 寻找还未更新距离的节点中的最小距离的节点 for j := 1; j \u003c= n; j++ { if !st[j] \u0026\u0026 (t == -1 || d[t] \u003e d[j]) { t = j } } // 标记已寻到1-\u003et的最短路 st[t] = true // 从t点出发更新其余点的最短路 for j := 1; j \u003c= n; j++ { d[j] = min(d[j], d[t] + g[t][j]) } } // n点不可达 if d[n] == 0x3f3f3f3f { return -1 } return d[n] } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) // 初始化g为正无穷，表示一开始所有边都没建立连接 for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= n; j++ { g[i][j] = 0x3f3f3f3f } } for ; m \u003e 0; m-- { var x, y, z int fmt.Fscan(in, \u0026x, \u0026y, \u0026z) // 为x-\u003ey点建立连接，权重为z // 因为存在重边，所有需要存储最小值 // 不用处理自环，因为求1-\u003en的最短路自环没有影响 g[x][y] = min(g[x][y], z) } // 返回1-\u003en的最短距离 fmt.Fprintln(out, dijkstra()) } func min (a, b int) int { if a \u003c b { return a } return b } ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:1","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"经典模板题 849. Dijkstra求最短路 I ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:2","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"用堆来优化朴素版Dijkstra算法 朴素版的Dijkstra算法中，寻找没确认最短路的点中的距离最小的点这一步，时间复杂度是O(n^2)的。 for i := 0; i \u003c n; i++ { t := -1 // 寻找还未更新距离的节点中的最小距离的节点 // 这一步总共执行n * n次 for j := 1; j \u003c= n; j++ { if !st[j] \u0026\u0026 (t == -1 || d[t] \u003e d[j]) { t = j } } ... } 寻找一个集合中的最小值，我们可以用堆来优化。因此我们可以用堆来存储所有点到起点的最短距离d，这样每次寻找最小值只需要O(1)的时间复杂度，需要寻找n次，因此这一步的时间复杂度降到了O(n)。 // d是一个小根堆，或叫优先队列 // 寻找最小距离点操作改为 t := heap.Pop(d) 除此之外，我们还需要用最小距离节点——t更新到其他点的距离。朴素算法中，这一步时间复杂度是O(m)的。因为我们每次只会更新节点t能到达的节点，访问内存操作最多只有m次。 for i := 0; i \u003c n; i++ { ... // 从t点出发更新其余点的最短路 // 每次循环，只有t能到达的点有可能被更新 // n次循环加起来，有效操作次数\u003c=m次 for j := 1; j \u003c= n; j++ { d[j] = min(d[j], d[t] + g[t][j]) } } 堆优化后，因为需要更新堆元素，需要调整堆，因此这一步时间复杂度为O(mlogn)。 for i := 0; i \u003c n; i++ { ... // 从t点出发更新其余点的最短路 // 每次循环，只有t能到达的点有可能被更新 // n次循环加起来，有效操作次数\u003c=m次 for j := 1; j \u003c= n; j++ { d[j] = min(d[j], d[t] + g[t][j]) // 这里调整堆是O(logn)的 heap.Push(d, j) } } 最后，朴素算法就被优化成了O(mlogn) ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:3","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"堆优化版Dijkstra算法代码模板 package main import ( \"fmt\" \"bufio\" \"os\" \"container/heap\" ) const N int = 1000010 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 邻接表存储图 h, e, ne [N]int idx int // 存储起点到i点的最短距离 d [N]int // 存储i-\u003ej的边权 w [N]int // 记录点i是否已经寻到最短路 st [N]bool n, m int ) // 存储no节点到起点的距离 type Pair struct { dis, no int } type PriorityQueue []*Pair func (pq PriorityQueue) Len() int { return len(pq) } func (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] } func (pq PriorityQueue) Less(i, j int) bool { return pq[i].dis \u003c pq[j].dis } func (pq *PriorityQueue) Push(x interface{}) { *pq = append(*pq, x.(*Pair)) } func (pq *PriorityQueue) Pop() interface{} { old := *pq n := len(old) x := old[n-1] old[n-1] = nil // avoid memory leak *pq = old[0:n-1] return x } func add(a, b, c int) { e[idx] = b w[idx] = c ne[idx] = h[a] h[a] = idx idx++ } func dijkstra() int { // 初始化小根堆，并存入起点到起点的最短路 pq := \u0026PriorityQueue{ { 0, 1 } } d[1] = 0 for pq.Len() \u003e 0 { t := heap.Pop(pq).(*Pair) // t.no是目前最短距离节点编号，t.dis是最短距离节点到起点的距离 // 因为存在重边，再遇到相同节点，就跳过 if st[t.no] { continue } st[t.no] = true // 更新最短距离节点能到达的所有节点 for i := h[t.no]; i != -1; i = ne[i] { j := e[i] if d[j] \u003e d[t.no] + w[i] { d[j] = d[t.no] + w[i] heap.Push(pq, \u0026Pair{ d[j], j }) } } } if d[n] == 0x3f3f3f3f { return -1 } return d[n] } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 0; i \u003c N; i++ { h[i] = -1 d[i] = 0x3f3f3f3f } for ; m \u003e 0; m-- { var a, b, c int fmt.Fscan(in, \u0026a, \u0026b, \u0026c) add(a, b, c) } fmt.Fprintln(out, dijkstra()) } ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:4","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"经典模板题 850. Dijkstra求最短路 II ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:5","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"Bellman-Ford算法 两重循环，第一重循环节点次数n，第二重循环所有边a-\u003eb及权重w，并更新dist[b] = min(dist[b], dist[a] + w)。这个更新的过程叫做松弛操作。 Bellman-Ford算法证明了，所有循环结束之后，所有的边都满足dist[b] \u003c= dist[a] + w，这个等式也叫作三角不等式 负权回路是回路的权值加起来小于0 如果存在负权回路，那么Bellman-Ford求出的最短路不一定存在(最短路为负无穷时不存在) Bellman-Ford算法可以求出是否存在负权回路 ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:6","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"Bellman-Ford算法代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const ( N int = 510 M int = 10010 ) // 存储所有边，a -\u003e b 权值为 w 的边 type Edge struct { a, b, w int } var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // Bellman-Ford算法只要能遍历到所有边就可以求最短路 edges [M]Edge // dist 存储 起点 到 点i 的最短距离 dist [N]int // backup 存储上一次 dist 的值，避免本次更新时用到被覆盖的值 // 跟 背包问题 中从后往前遍历，避免使用被覆盖值一个道理 backup [N]int // 标识是否找到最短路 flag bool = true; n, m, k int ) func bellmanFord() int { // 初始化 dist 所有点到起点距离为无穷 for i := 1; i \u003c= n; i++ { dist[i] = 0x3f3f3f3f } // 起点到起点距离为0 dist[1] = 0 for i := 0; i \u003c k; i++ { // 保存 dist 状态 copy(backup[:], dist[:]) for j := 0; j \u003c m; j++ { a := edges[j].a b := edges[j].b w := edges[j].w // 使用 backup 的状态，而不是 dist dist[b] = min(dist[b], backup[a] + w) } } // 因为存在负权，距离可能被更新为0x3f3f3f3f - 某个负权w，所以不能简单判断 dist[n] == 0x3f3f3f3f // 但是负权最多为 10000，k为500，最多为0x3f3f3f3f - 500 * 10000 if dist[n] \u003e 0x3f3f3f3f / 2 { flag = false; return -1 } return dist[n] } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m, \u0026k) for i := 0; i \u003c m; i++ { var a, b, w int fmt.Fscan(in, \u0026a, \u0026b, \u0026w) edges[i] = Edge{a, b, w} } t := bellmanFord() if ! flag \u0026\u0026 t == -1 { fmt.Fprintln(out, \"impossible\") } else { fmt.Fprintln(out, t) } } func min(a, b int) int { if a \u003c b { return a } return b } ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:7","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"经典模板题 853. 有边数限制的最短路 ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:8","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"SPFA算法 SPFA算法求最短路问题的限制最少，只要图中没有负环的存在，就可以用SPFA算法来求解最短路问题，而99%的最短路问题，都没有负环。 SPFA算法是对Bellman-Ford算法的优化。 SPFA算法的第一重循环是所有被更新过距离的点，用一个队列来存放。一开始队列中只有起点，用起点更新起点的所有邻边，能更新的点加入队列中，用这些变小了的点去更新其他点，才有会使其他点的距离缩小，才有意义。 ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:9","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"SPFA算法代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 100010 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 稀疏图，用邻接表来存 h, e, ne, w [N]int idx int // 数组模拟队列，或者直接用slice也行 que [N]int qh, qt int = 0, -1 // 存储 点1 到 点i 的最短距离 dist [N]int // 标识 点i 是否在队列中，在队列中的点是距离缩小了的点， // 用这些点去更新其他点才有意义 st [N]bool flag bool = true n, m int ) // 邻接表建图 func add(a, b, c int) { e[idx] = b ne[idx] = h[a] w[idx] = c h[a] = idx idx++ } func spfa() int { // 初始化所有点为无穷 for i := 1; i \u003c= n; i++ { dist[i] = 0x3f3f3f3f } // 起点 到 起点 的距离为0 dist[1] = 0 qt++ que[qt] = 1; st[1] = true for qh \u003c= qt { t := que[qh] qh++ // 改点出队，标记为不在队列中 st[t] = false // 遍历t的所有边 for i := h[t]; i != -1; i = ne[i] { j := e[i] // 用t更新它的所有邻边，如果能缩小距离，将点j也加入队列 if dist[j] \u003e dist[t] + w[i] { dist[j] = dist[t] + w[i] // 只有不在队列中的点才加入队列 if ! st[j] { qt++ que[qt] = j st[j] = true } } } } if dist[n] == 0x3f3f3f3f { flag = false return -1 } return dist[n] } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { h[i] = -1 } for ; m \u003e 0; m-- { var a, b, c int fmt.Fscan(in, \u0026a, \u0026b, \u0026c) add(a, b, c) } t := spfa() if ! flag \u0026\u0026 t == - 1 { fmt.Fprintln(out, \"impossible\") } else { fmt.Fprintln(out, t) } } ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:10","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"经典模板题 851. spfa求最短路 ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:11","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"SPFA算法判断是否存在负环 dist[i]的含义是起点到i点的最短路距离，我们新加一个cnt[i]，表示**起点到i点最短路经过的边数**。 dist[i]更新的条件是，与i连接的其他点j，起点-\u003ej的距离+j-\u003ei的距离，小于当前i记录的最短路距离。也就是当前i的状态能被它连接的其他点更新(DP思想)。dist[i] = min(dist[i], dist[j] + w)。 cnt[i]跟着dist[i]一起更新，更新为起点-\u003ej的边数 + 1，因为起点-\u003ej-\u003ei是新的最短路，所以当前i点最短路的边数为，能更新i点最短路的点j所经过的边数加1，可以理解为DP中当前状态由上一个状态推导出来。 判断是否存在负环的条件是，cnt[i] \u003e= n，其中n为图中点的个数。如果最短路径等于n，意味这经过了n+1个点，但图中只有n个点，根据抽屉原理，则图中某一个点被经过了两次，则图中有环。因为SPFA是最短路算法，因此正环实际上不会循环(走正环一定没有不走正环短)，只有负环会一直更新(走负环会一直得到更小的值，产生负无穷)。所以当cnt[i] \u003e= n时，就可以停止循环，返回找到负环了，如果没有负环，就是正常的找最短路的过程。 抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。这一现象就是我们所说的“抽屉原理”。抽屉原理的一般含义为：“如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。” 抽屉原理有时也被称为鸽巢原理。它是组合数学中一个重要的原理。 ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:12","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"SPFA算法判断是否存在环代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const ( N int = 2010 M int = 10010 ) var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 邻接表存储图 h [N]int e, ne, w [M]int idx int // 存储起点到点i的最短距离 dist [N]int // 存储起点到点i最短路经过的边数 cnt [N]int // 记录点i是否在队列中 st [N]bool n, m int ) // 邻接表建图 func add(a, b, c int) { e[idx] = b ne[idx] = h[a] w[idx] = c h[a] = idx idx++ } // SPFA算法判断是否存在负环 func spfa() bool { que := make([]int, 0, n) for i := 1; i \u003c= n; i++ { // 初始化所有距离为正无穷 dist[i] = 0x3f3f3f3f // 这里与spfa求最短路不一样，要把所有点入队 // 因为负环可能从起点到不了 que = append(que, i) st[i] = true } // 起点到起点的距离为0 dist[1] = 0 for len(que) \u003e 0 { t := que[0] que = que[1:] st[t] = false for i := h[t]; i != -1; i = ne[i] { j := e[i] // 点j可以被点t更新距离 if dist[j] \u003e dist[t] + w[i] { // 更新dist[j]的同时更新cnt[j] dist[j] = dist[t] + w[i] cnt[j] = cnt[t] + 1 // 如果经过了n条边，意味这经过了n+1个点，存在环 // 最短路中正环不会循环，只有负环会循环，因此可以判断存在负环 if cnt[j] \u003e= n { return true } // j不在队列中才加入队列 if ! st[j] { que = append(que, j) st[j] = true } } } } return false } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { h[i] = -1 } for ; m \u003e 0; m-- { var a, b, c int fmt.Fscan(in, \u0026a, \u0026b, \u0026c) add(a, b, c) } if spfa() { fmt.Fprintln(out, \"Yes\") } else { fmt.Fprintln(out, \"No\") } } ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:13","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"经典模板题 852. spfa判断负环 ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:14","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"Floyd算法求最短路 Floyd算法是基于DP的，时间复杂度O(n^3)。用邻接矩阵来存储图——d[i][j]表示从i点到j点的最短路是多少。 ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:15","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"Floyd算法求最短路代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const ( N int = 210 INF int = 1e9 ) var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 用邻接矩阵存储图 d [N][N]int // n个点，m条边，q个询问 n, m, q int ) func floyd() { for k := 1; k \u003c= n; k++ { for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= n; j++ { // DP思想 d[i][j] = min(d[i][j], d[i][k] + d[k][j]) } } } } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m, \u0026q) // 初始化邻接矩阵，图存在重边和自环 // floyd要求图中没有负环，自环自己到自己初始化为0 for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= n; j++ { if i == j { d[i][j] = 0 } else { d[i][j] = INF } } } // 读入m条边 for ; m \u003e 0; m-- { var a, b, w int fmt.Fscan(in, \u0026a, \u0026b, \u0026w) // 重边用取min的方式解决 d[a][b] = min(d[a][b], w) } // Floyd算法会将d[N][N]变成存储点i到点j的最短路距离 floyd() // q个询问 for ; q \u003e 0; q-- { var a, b int fmt.Fscan(in, \u0026a, \u0026b) // 因为存在负权值，最大值可能会被更新 if d[a][b] \u003e INF / 2 { fmt.Fprintln(out, \"impossible\") } else { fmt.Fprintln(out, d[a][b]) } } } func min(a, b int) int { if a \u003c b { return a } return b } ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:16","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"content":"经典模板题 854. Floyd求最短路 ","date":"2022-10-26","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/:1:17","tags":["算法","算法整理","最短路","Dijkstra","Bellman-Ford","SPFA","Floyd"],"title":"基础算法整理(八)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AB/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 搜索 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:0:0","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"BFS 使用数据结构：queue。 使用空间：因要存储每一层所有节点，因此使用的空间是O(2^h)指数级，h是树的高度。 BFS搜索具有最短路的性质。BFS搜索两个点的距离，一定是最短的。 BFS是树中的层序遍历。 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:1:0","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"代码模板 走迷宫问题 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 110 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 存储迷宫 maze [N][N]int // 存储距离 dist [N][N]int n, m int ) type pair struct { first int second int } func bfs(start pair) int { queue := make([]pair, 1) queue[0] = start dist[0][0] = 0 // 上右下左 四个方向 var dx = [4]int{-1, 0, 1, 0} var dy = [4]int{0, 1, 0, -1} for len(queue) \u003e 0 { t := queue[0] queue = queue[1:] // 枚举四个方向 for j := 0; j \u003c 4; j++ { x := t.first + dx[j] y := t.second + dy[j] // 将合法的位置加入队列中 if x \u003e= 0 \u0026\u0026 x \u003c n \u0026\u0026 y \u003e= 0 \u0026\u0026 y \u003c m \u0026\u0026 maze[x][y] == 0 \u0026\u0026 dist[x][y] == -1 { queue = append(queue, pair{x, y}) dist[x][y] = dist[t.first][t.second] + 1 } } } return dist[n-1][m-1] } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 0; i \u003c n; i++ { for j := 0; j \u003c m; j++ { fmt.Fscan(in, \u0026maze[i][j]) // 没走过的点初始化为-1 dist[i][j] = -1 } } fmt.Fprintln(out, bfs(pair{0, 0})) } ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:1:1","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"经典模板题 844. 走迷宫 845. 八数码 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:1:2","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"DFS 使用数据结构：stack。 使用空间：只需要存储当前路径上的所有节点，因此使用的空间是O(h)，h是树的高度。 DFS的一些概念： DFS搜索不具有最短路性质。 DFS是树的中序遍历(左中右)。 DFS最重要的是画出递归树。 DFS两个重要概念——回溯和剪枝。 回溯的难点在于递归过程中的去重问题。常见去重有： 同层去重 子树去重 路径去重 深度优先搜索可以求出某个节点为根的子树上节点的数量。 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:2:0","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"代码模板 N皇后问题 package main import ( \"fmt\" \"bufio\" \"os\" ) var in = bufio.NewReader(os.Stdin) var out = bufio.NewWriter(os.Stdout) const N int = 10 // 棋盘 var chessbord [N][N]byte var ( // 记录列是否有皇后 col [N]bool // 记录45度对角是否有皇后，有n行n列，因此需要开2*N的空间 udg [2*N]bool // 记录135度对角是否有皇后，有n行n列，因此需要开2*N的空间 dg [2*N]bool ) var n int func dfs(row int) { // 找到了一种解决方案，输出棋盘 if row == n { for i := 0; i \u003c n; i++ { for j := 0; j \u003c n; j++ { fmt.Fprintf(out, \"%c\", chessbord[i][j]) } fmt.Fprintln(out) } fmt.Fprintln(out) return } // 枚举每一列，能放下皇后的进入下一行 for c := 0; c \u003c n; c++ { // 如果这一列、135度对角和45度对角上都没有皇后，就在c列放下皇后，并进入下一行 // row - c + n 和 row + c 如何理解？每条对角线可以看成是一个 y = x + b 或 y = -x + b 的函数 // 唯一的 x和y 可以确认唯一的 b，我们可以用这个 b 来代表y行x列的对角线 // 135度对角线y = x + b，45度对角线y = -x + b // 变形后135度对角线 b = y - x，45度对角线b = y + x // 因为 y - x 可能为负，我们可以加上一个n，将整体结果映射到0~n这个区间 if !col[c] \u0026\u0026 !udg[row - c + n] \u0026\u0026 !dg[row + c] { // 放下皇后 chessbord[row][c] = 'Q' // 标记 c 列有皇后；标记 row 行 -c 列有皇后；标记 row 行 c 列有皇后 col[c] = true; udg[row - c + n] = true; dg[row + c] = true // 进入下一行 dfs(row + 1) // 回溯状态，为下一列枚举提供可能 chessbord[row][c] = '.' col[c] = false; udg[row - c + n] = false; dg[row + c] = false } } } func main() { defer out.Flush() fmt.Fscan(in, \u0026n) // 初始化棋盘 for i := 0; i \u003c n; i++ { for j := 0; j \u003c n; j++ { chessbord[i][j] = '.' } } dfs(0) } ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:2:1","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"经典模板题 842. 排列数字 843. n-皇后问题 51. N 皇后 图论 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:2:2","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"树与图的存储 树是一种特殊的图，因此我们只讨论图即可。 图的形式 图分为有向图和无向图，无向图是一种特殊的有向图，其两个顶点有两条相互连接的边，因此在讨论图的遍历时，只讨论有向图即可。 图的存储形式 图的存储形式有： 邻接矩阵 邻接表 邻接矩阵是一个N*N的二维数组。x行y列存储值为1，表示x顶点与y顶点有一条边。邻接矩阵使用比较少，因为他需要O(n^2)的存储空间，比较适合存储稠密图。 邻接表是一个元素是链表的数组，下标x存储的是一条链表，链表所有节点是x顶点能到达的所有其他顶点。 重边：指的是点i到点j之间存在不止一条边 自环：指的是点i有一条边指向自己 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:3:0","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"图的遍历 深度有限搜索可以方便的获取子树的节点数量。 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:4:0","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"深度优先搜索遍历代码模板 const N int = 100010 var ( // 邻接表的存储方式 h [N]int e, ne [2*N]int idx int // 记录哪些点被访问过了 st [N]bool ) // 为 a，b 点建立连接 func add(a, b int) { e[idx] = b ne[idx] = h[a] h[a] = idx idx++ } // 深度有限搜索遍历图 func dfs(u int) { st[u] = true for i := h[u]; i != -1; i = ne[i] { j := e[i] if !st[j] { dfs(j) } } } ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:4:1","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"经典模板题 846. 树的重心 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:4:2","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"广度优先搜索代码模板 const N int = 100010 var ( // 存储邻接表 h, e, ne [N]int idx int // 存储点是否被访问过 st [N]bool ) func add(a, b int) { e[idx] = b ne[idx] = h[a] h[a] = idx idx++ } func bfs() { queue := make([]int, 1, N) queue[0] = 1 st[1] = true for len(queue) \u003e 0 { t := queue[0] queue = queue[1:] // 当前点的邻接表 for i := h[t]; i != -1; i = ne[i] { j := e[i] if !st[j] { st[j] = true queue = append(queue, j) } } } } ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:4:3","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"经典模板题 847. 图中点的层次 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:4:4","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"拓扑排序 拓扑排序是指，将有向图中的所有顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素。 拓扑排序是针对有向图而言，无向图没有拓扑序列。 拓扑排序的一个典型应用是——有前导课程的课程表，所有后面的课程指向前面的先导课程。 一个有环图不存在拓扑排序，因为必定有一个前面的节点指向后面的节点。反之，一个有向无环图必定存在拓扑排序，因此有向无环图又称为拓扑图。 图的入度与出度： 入度：有多少条边指向该节点 出度：该节点有多少条边出去 求拓扑排序的步骤 寻找入度为0的点入队，入度为0意味着没有其他节点指向它。 取出队头元素，将队头元素所有的出边删掉 将出边指向节点中，入度为0的点入队 拓扑图必定存在一个入度为0的点。如果存在环，那么将不会有元素入队，循环结束。 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:5:0","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 1e5 + 10 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) h, e, ne [N]int idx int // d 存储所有节点的入度 queue, d [N]int hh, tt int = 0, -1 n, m int ) func add(a, b int) { e[idx] = b ne[idx] = h[a] h[a] = idx idx++ } func topsort() bool { // 先将所有入度为0的点入队 for i := 1; i \u003c= n; i++ { if d[i] == 0 { tt++ queue[tt] = i } } // 取出队头元素，将其所有出边删除 for hh \u003c= tt { t := queue[hh] hh++ for i := h[t]; i != -1; i = ne[i] { j := e[i] // 将入度为0的点入队 d[j]-- if d[j] == 0 { tt++ queue[tt] = j } } } // 如果是拓扑图，那么所有点都会入队 return tt == n - 1 } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { h[i] = -1 } var a, b int for i := 1; i \u003c= m; i++ { fmt.Fscan(in, \u0026a, \u0026b) add(a, b) d[b]++ } if topsort() { for i := 0; i \u003c hh; i++ { fmt.Fprintf(out, \"%d \", queue[i]) fmt.Fprintln(out) } } else { fmt.Fprintln(out, \"-1\") } } ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:5:1","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"经典模板题 848. 有向图的拓扑序列 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:5:2","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com Hash表/哈希表 Hash表通过Hash函数映射的方式，将一个稀疏的集合存储到一个紧凑的集合中。比如一个集合的数据范围是1~10^9次方，但里面的数只有10^5个，我们就可以通过一个Hash函数(通常是取模)的方式将集合中的数映射到一个10^5的集合中，减少存储空间的浪费。 但是将一个大集合映射到小集合，必然造成信息的损失，表现到Hash表中就是Hash冲突。通过Hash后，大集合中的某些数必定被映射到了同一个点上。因此我们无法确认该点是否存在某些值，因为有多个值同时被映射过来了。 解决Hash冲突的经典解决方式(都需要额外判断)： 拉链法 开放寻址法 拉链法 每一个点存储的是一个链式结构，冲突时将新值链接到前面或后面。确认是否存在该值时，可以依次判断链上的每一个节点。 开放寻址法 如果该点存在冲突，则往下或往上寻找空的位置，将新值写入。确认是否存在该值时，先找到映射的位置，然后向上或向下依次判断每一个值。 ","date":"2022-10-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/:0:0","tags":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"title":"基础算法整理(六)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/"},{"categories":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"content":"代码模板 拉链法 package main import ( \"fmt\" \"bufio\" \"os\" ) // 拉链法 const N int = 100003 var h, e, ne [N]int var idx int func insert(x int) { // x 为负数时 % N 结果为负数，加上 N 变为正数，再 % N k := (x % N + N) % N e[idx] = x ne[idx] = h[k] h[k] = idx idx++ } func query(x int) bool { k := (x % N + N) % N for i := h[k]; i != -1; i = ne[i] { if e[i] == x { return true } } return false } func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() // 将h所有槽位初始化为-1，表示空节点 for i := 0; i \u003c N; i++ { h[i] = -1 } var n int fmt.Fscan(in, \u0026n) for ; n \u003e 0; n-- { var op string var x int fmt.Fscan(in, \u0026op, \u0026x) if op == \"I\" { insert(x) } else { if query(x) { fmt.Fprintln(out, \"Yes\") } else { fmt.Fprintln(out, \"No\") } } } } 开放寻址法 package main import ( \"fmt\" \"bufio\" \"os\" ) // 开放寻址法通常开数据范围2~3倍的空间 const N int = 200003 // 用一个不存在于数据范围内的数来表示该点没有值 const null int = 0x3f3f3f3f var h [N]int // 在 h 中寻找 x 应该插入的位置 func find(x int) int { k := (x % N + N) % N // 在h中找一个x能插入的位置，如果x已经插入过了，返回插入的位置 for h[k] != null \u0026\u0026 h[k] != x { k++ // 如果到最后了，尝试从头开始查找插入的问题 if k == N { k = 0 } } return k } func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() // 初始化将所有点标记为空 for i := 0; i \u003c N; i++ { h[i] = null } var n int fmt.Fscan(in, \u0026n) for ; n \u003e 0; n-- { var op string var x int fmt.Fscan(in, \u0026op, \u0026x) k := find(x) if op == \"I\" { h[k] = x } else { if h[k] != null { fmt.Fprintln(out, \"Yes\") } else { fmt.Fprintln(out, \"No\") } } } } ","date":"2022-10-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/:0:1","tags":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"title":"基础算法整理(六)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/"},{"categories":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"content":"经典模板题 840. 模拟散列表 字符串Hash 字符串hash是一种快速判断字符串是否相等的方法。Golang中strings.Index等库均用到了字符串Hash——RK算法。详细可以看Golang中的字符串匹配——RK算法。 ","date":"2022-10-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/:0:2","tags":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"title":"基础算法整理(六)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/"},{"categories":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 100010 // P表示P进制，题目提到字符串中只包含大小写英文字母和数字，因此128可以完全存下 // ASCII码总共128，131是大于128的最小素数，用素数是因为可以有效的降低冲突的概率 // 这里还有个细节是用到了uint64 // 当字符串足够长时，产生的hash值可能会非常大，int可能会存不下，但是uint64也不一定存的下 // 经验告诉我们，当P取131或13331时，hash值mod一个2^64，在99.99%的情况下不会发生冲突 // 因此用uint64还有个好处，当uint64发生溢出时，就相当于mod了2^64，可以减少许多次计算 // 因此这个字符串hash方法，是假定不会发生冲突的 const P uint64 = 131 // h存储的是s所有前缀的hash值，预处理好之后，求某一段的hash就只需要O(1)的时间 // p存储的是P^i次方数，方便O(1)时间计算hash var h, p [N]uint64 func get(l, r int) uint64 { return h[r] - h[l-1] * p[r-l+1] } func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n, m int fmt.Fscan(in, \u0026n, \u0026m) var s string fmt.Fscan(in, \u0026s) s = \" \" + s // 预处理前缀hash和P进制每一位数 p[0] = 1 for i := 1; i \u003c= n; i++ { p[i] = p[i-1] * P h[i] = h[i-1] * P + uint64(s[i]) } for ; m \u003e 0; m-- { var l1, r1, l2, r2 int fmt.Fscan(in, \u0026l1, \u0026r1, \u0026l2, \u0026r2) // 因为hash冲突极大概率不存在，因此判断hash值相同就认为字符串相同 if get(l1, r1) == get(l2, r2) { fmt.Fprintln(out, \"Yes\") } else { fmt.Fprintln(out, \"No\") } } } ","date":"2022-10-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/:0:3","tags":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"title":"基础算法整理(六)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/"},{"categories":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"content":"经典模板题 841. 字符串哈希 求大于x的最小素数 ","date":"2022-10-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/:0:4","tags":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"title":"基础算法整理(六)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/"},{"categories":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"content":"代码模板 // 快速求比128数大的最小素数 for i := 128; ; i++ { flag := true for j := 2; j * j \u003c= i; j++ { if i % j == 0 { flag = false break } } if flag { fmt.Fprintln(out, i) break } } ","date":"2022-10-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/:0:5","tags":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"title":"基础算法整理(六)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com Trie树/字典树 Trie是一种高效存储和查找字符串集合的数据结构。其存储形式如下图所示： 红色星号标记了存在以该词结尾的单词。 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:0:0","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"代码模板 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 1e5 + 10 var ( // 指示son存储到哪了 idx int // 第一个维度表示 节点i // 第二个维度表示 节点i的子节点的下标 // 比如先存储了一个 只有a字母 长度为20的字符串，那么idx值为20 // 表示已经使用了20个节点 // 再存储新的字符串，将会从idx开始 // son[0][26]表示头结点的子节点 son [N][26]int // 以某个节点结尾的单词数量 cnt [N]int ) func insert(s string) { p := 0 for i := 0; i \u003c len(s); i++ { u := s[i] - 'a' if son[p][u] == 0 { // 如果没有存储过该字符，则新开一个节点存储，idx+1的含义 son[p][u] = idx + 1 idx++ } p = son[p][u] } cnt[p]++ // 以节点p结尾的单词数量 } func query(s string) int { p := 0 for i := 0; i \u003c len(s); i++ { u := s[i] - 'a' if son[p][u] == 0 { return 0 } p = son[p][u] } return cnt[p] } func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n int fmt.Scan(\u0026n) for ; n \u003e 0; n-- { var op, s string fmt.Fscan(in, \u0026op, \u0026s) if op == \"I\" { insert(s) } else { fmt.Fprintln(out, query(s)) } } } ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:0:1","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"经典模板题 835. Trie字符串统计 208. 实现 Trie (前缀树) 143. 最大异或对 421. 数组中两个数的最大异或值 并查集 并查集通常用来： 将两个集合合并 询问两个元素是否在一个集合当中 并查集能在近乎O(1)的时间内完成这两个操作。 并查集是树形的数据结构，用数根来表示这个集合的编号，其余每个节点存储它的父节点是谁 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:0:2","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"朴素并查集 问题1：如何判断树根？ 集合中只有树根的父节点等于自身，因此判断是否与父节点相同即可：if x == p[x] 问题2：如何求一个元素属于那个集合？ 从num不断地向上走，一直走到树根：for x := x; x != p[x]; x = p[x] {} 问题3：如何合并两个集合？ 假设有两个集合分别用编号x和y表示，则将集合x合并到y的操作为，将x的根节点指向y：p[x] = y 可以发现，并查集的时间复杂度集中在问题2上。并查集的路径压缩降低了这个时间复杂度。 有了路径压缩后，并查集查询两个元素是否在同一个集合中的时间复杂度，可以近乎看成O(1)。 在一次求元素属于那个集合的操作中，将查找路径上的所有节点直接指向根节点，本质上是降低了树的高度。 在代码实现时，一般会直接带上路径压缩。 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:1:0","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"代码模板 var p [N]int func init() { // 一开始每个元素都是一个单独的集合，自己就是自己的祖先节点 for i := 1; i \u003c= n; i++ { p[i] = i } } // 核心实现，寻找 x 的祖先节点，并且加上路径压缩 func find(x int) int { // 如果x的根节点不是，则递归寻找根节点， // 并将这条路径上的节点的父节点都赋值为根节点 if p[x] != x { p[x] = find(p[x]) } return p[x] } ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:1:1","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"经典模板题 836. 合并集合 剑指 Offer II 118. 多余的边 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:1:2","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"维护每个集合数量 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:2:0","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"代码模板 // 额外使用一个cnt，来维护这个集合的数量 var p, cnt [N]int func init() { // 一开始每个元素都是一个单独的集合，自己就是自己的祖先节点 for i := 1; i \u003c= n; i++ { p[i] = i // 初始化每个集合数量为1 cnt[i] = 1 } } // 核心实现，寻找 x 的祖先节点，并且加上路径压缩 func find(x int) int { // 如果x的根节点不是，则递归寻找根节点， // 并将这条路径上的节点的父节点都赋值为根节点 if p[x] != x { p[x] = find(p[x]) } return p[x] } // 将b加入a集合，并且更新a集合数量 func merge(a, b int) { a, b = find(a), find(b) if a != b { p[b] = a cnt[a] += cnt[b] } } ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:2:1","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"经典模板题 837. 连通块中点的数量 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:2:2","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"记录偏移量 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:3:0","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"代码模板 const N int = 50010 var p, d [N]int func find(x int) int { if x != p[x] { t := find(p[x]) d[x] += d[p[x]] p[x] = t } return p[x] } ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:3:1","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"经典模板题 240. 食物链 堆 堆是一颗完全二叉树，根据节点与其左右节点的性质，可以分为大根堆和小根堆。对于每一个节点，都小于其左右节点的堆称为小根堆，对于每一个节点，都大于其左右节点的堆称为大根堆。 堆通常需要支持如下操作： 插入一个数 求集合当中的最值 删除最值 删除任意一个元素(不常用) 修改任意一个元素(不常用) 要求执行完这些操作之后，集合仍然是一个堆。 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:3:2","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"实现细节 我们使用一维数组来存储集合，将下标为1的位置定义为根节点，那么每个节点i与其左右节点的关系为：$左节点 = 2i，右节点 = 2i+1$。 我们定义两种操作：down(u int)和up(u int)，分别从u向下调整堆，和从u向上调整堆。 down会判断u是否小于其左右节点(对于小根堆而言)，如果不是，则交换u与最小者，再递归调整最小者。 up会判断u是否小于其父节点(对于小根堆而言)，如果不是，则交换u与其父节点，再循环调整其父节点。 我们可以组合down和up操作，来实现上述需要支持的5个操作。 堆的初始化，我们可以不断的将数插到最后，然后向上调整堆，这样的时间复杂度是O(nlogn)的。有另一种方法是O(n)的。 对于一个数组，我们从n/2 ~ 1执行down操作，$n/2$其实就是倒数第二层，这一层的节点数量为$n/4$，只需要往下down一次，因此时间复杂度是$(n/4)*1$。往上每一层的节点数量为$n/8$，需要往下down两次，时间复杂度是$(n/8)*2$，以此类推，那么总的时间复杂度就是他们的总和： $$sum((n/4)*1, (n/8)*2, (n/16)*3, …) = n$$ go语言中heap.Init函数也是采用这个实现。 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:3:3","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"代码模板 // 堆 var h [N]int // 堆存储长度 var size int // 堆初始化 O(n) func initHeap() { for i := n / 2; i \u003e 0; i-- { down(i) } } // 从u开始向上调整堆 O(logn) func up(u int) { for u / 2 \u003e 0 \u0026\u0026 h[u] \u003c h[u / 2] { h[u], h[u / 2] = h[u / 2], h[u] u /= 2 } } // 从u开始向下调整堆 O(logn) func down(u int) { t := u // 拿到 u 及左右儿子中的最小值 if u * 2 \u003c= size \u0026\u0026 h[u * 2] \u003c h[t] { t = u * 2 } if u * 2 + 1 \u003c= size \u0026\u0026 h[u * 2 + 1] \u003c h[t] { t = u * 2 + 1 } // 如果 u 已经是 三者中最小，则不需要调整堆 // 否则交换 u 与最小者，递归调整堆 if u != t { h[u], h[t] = h[t], h[u] down(t) } } ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:3:4","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"经典模板题 838. 堆排序 839. 模拟堆 912. 排序数组 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:3:5","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 链表与邻接表 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:0:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"单链表 链表通常使用结构体加指针的方式来构建： type Node struct { Val int Next *Node } 但是这种方式创建链表很慢，笔试算法中链表长度可能达到10^5甚至10^6级别，只是初始化链表就超时了。所以笔试算法通常使用数组来模拟链表，用数组模拟链表也被称为静态链表。 用数组模拟链表： // 存储节点i的值 var e = [N]int{0, 1, 2, 3, 4, 5} // 存储节点i的next，这里存储的实际是数组下标，-1表示nil var ne = [N]int{3, 1, 2, 5, 4, -1} // [0]-\u003e[3]-\u003e[1]-\u003e[2]-\u003e[5]-\u003e[4]-\u003enil 单链表最大的用途是用来写邻接表，存储树和图。 双链表通常用于优化某些问题。 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:1:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N = 100010 // 指向头节点，指示链表长度 var head, length int var e, ne [N]int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var m int fmt.Fscan(in, \u0026m) initLinkList() for ; m \u003e 0; m-- { var op string var k, x int fmt.Fscan(in, \u0026op) if op == \"H\" { fmt.Fscan(in, \u0026x) addToHead(x) } else if op == \"D\"{ fmt.Fscan(in, \u0026k) // 如果删除的节点是头结点，直接将head指向下一位 if k == 0 { head = ne[head] } else { remove(k - 1) } } else { fmt.Fscan(in, \u0026k, \u0026x) add(k - 1, x) } } for i := head; i != -1; i = ne[i] { fmt.Fprintf(out, \"%d \", e[i]) } } // 初始化链表 func initLinkList() { head = -1 length = 0 } // 将x插到头结点 func addToHead(x int) { e[length] = x ne[length] = head head = length length++ } // 将x插到下标是k的后面 func add(k, x int) { e[length] = x ne[length] = ne[k] ne[k] = length length++ } // 删除下标k后面的一个节点 func remove(k int) { ne[k] = ne[ne[k]] } ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:1:1","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"经典模板题 826. 单链表 707. 设计链表 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:1:2","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"双链表 双链表比单链表多存储了一个前节点指针，能够在O(1)时间找到上一个节点。 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:2:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N = 100010 // l存放i节点的左节点；r存放i节点的右节点 var e, l, r [N]int var length int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() initDuLinkNode() var m int fmt.Fscan(in, \u0026m) for ; m \u003e 0; m-- { var op string fmt.Fscan(in, \u0026op) var k, x int if op == \"R\" { fmt.Fscan(in, \u0026x) // 1表示最右端点 // l[1]表示最右端点的左侧 add(l[1], x) } else if op == \"L\" { fmt.Fscan(in, \u0026x) // 0表示最左端点 add(0, x) } else if op == \"D\" { fmt.Fscan(in, \u0026k) // 删除第k个插入的数 // 因为预先插入了两个左右端点，所以需+2 // 又因为下标从0开始，插入数从1开始，所以-1 remove(k + 1) } else if op == \"IR\" { fmt.Fscan(in, \u0026k, \u0026x) // 在第k个插入数的右侧插入x add(k + 1, x) } else if op == \"IL\" { fmt.Fscan(in, \u0026k, \u0026x) // 在第k个插入数的左侧插入x // 等价于在 第k个插入数的左节点的右侧 插入x add(l[k + 1], x) } } for i := r[0]; i != 1; i = r[i] { fmt.Fprintf(out, \"%d \", e[i]) } } func initDuLinkNode() { // 定义第一个和第二个节点为左右端点 r[0] = 1 l[1] = 0 length = 2 } // 在下标k的右边插入x func add(k, x int) { e[length] = x r[length] = r[k] l[length] = k l[r[k]] = length r[k] = length length++ } // 删除下标是k的点 func remove(k int) { r[l[k]] = r[k] l[r[k]] = l[k] } ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:2:1","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"经典模板题 827. 双链表 707. 设计链表 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:2:2","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"邻接表 邻接表存储的是一个节点和它的边。存储形式为一个矩阵，每个元素代表一个节点及它的所有边。 邻接表多用于存储树和图。 栈与队列 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:3:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"栈 一种先进后出的数据结构。 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:4:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 100010 var st [N]int var tt int = -1 func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var m int fmt.Fscan(in, \u0026m) for ; m \u003e 0; m-- { var op string fmt.Fscan(in, \u0026op) if op == \"push\" { var x int fmt.Fscan(in, \u0026x) push(x) } else if op == \"pop\" { _ = pop() } else if op == \"empty\" { fmt.Fprintln(out, empty()) } else { fmt.Fprintln(out, query()) } } } func push(x int) { tt++ st[tt] = x } func pop() int { x := st[tt] tt-- return x } func empty() string { if tt == -1 { return \"YES\" } return \"NO\" } func query() int { return st[tt] } ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:4:1","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"经典模板题 828. 模拟栈 3302. 表达式求值 剑指 Offer II 036. 后缀表达式 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:4:2","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"单调栈 通常用于解决，寻找每一个数左边离它最近的比它小的数，或寻找每一个数左边离它最近的比它大的数，或右边最近比它小小，诸如此类的问题。 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:5:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 100010 var st [N]int var tt int = -1 func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var m int fmt.Fscan(in, \u0026m) for i := 0; i \u003c m; i++ { var x int fmt.Fscan(in, \u0026x) for tt \u003e -1 \u0026\u0026 st[tt] \u003e= x { tt-- } if tt \u003e - 1 { fmt.Fprintf(out, \"%d \", st[tt]) } else { fmt.Fprint(out, \"-1 \") } tt++ st[tt] = x } } ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:5:1","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"经典模板题 830. 单调栈 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:5:2","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"队列 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:6:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"代码模板 package main import \"fmt\" const N int = 100010 var que [N]int var qh, qt int = 0, -1 func main() { var m int fmt.Scan(\u0026m) for ; m \u003e 0; m-- { var op string fmt.Scan(\u0026op) if op == \"push\" { var x int fmt.Scan(\u0026x) push(x) } else if op == \"pop\" { _ = pop() } else if op == \"empty\" { fmt.Println(empty()) } else { fmt.Println(query()) } } } func push(x int) { qt++ que[qt] = x } func pop() int { x := que[qh] qh++ return x } func empty() string { if qh \u003e qt { return \"YES\" } return \"NO\" } func query() int { return que[qh] } ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:6:1","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"经典模板题 829. 模拟队列 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:6:2","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"单调队列 经典应用是求滑动窗口中的最值。 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:7:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 1000010 var a [N]int var deque [N]int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n, k int fmt.Fscan(in, \u0026n, \u0026k) for i := 0; i \u003c n; i++ { fmt.Fscan(in, \u0026a[i]) } // 求窗口中的最小值 hh, tt int := 0, -1 for i := 0; i \u003c n; i++ { // 队头元素已经超出窗口范围，将队头元素弹出 if hh \u003c= tt \u0026\u0026 i - k + 1 \u003e deque[hh] { hh++ } // 重新维护单调队列，从队尾弹出比当前元素大的元素 for hh \u003c= tt \u0026\u0026 a[deque[tt]] \u003e= a[i] { tt-- } tt++; deque[tt] = i // 队列存储的是下标 if i \u003e= k - 1 { fmt.Fprintf(out, \"%d \", a[deque[hh]]) } } fmt.Fprintln(out) // 求窗口中的最大值 hh, tt = 0, -1 for i := 0; i \u003c n; i++ { // 队头元素已经超出窗口范围 if hh \u003c= tt \u0026\u0026 i - k + 1 \u003e deque[hh] { hh++ } // 重新维护单调队列，从队尾弹出比当前元素小的元素 for hh \u003c= tt \u0026\u0026 a[deque[tt]] \u003c= a[i] { tt-- } tt++; deque[tt] = i if i \u003e= k - 1 { fmt.Fprintf(out, \"%d \", a[deque[hh]]) } } } ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:7:1","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"经典模板题 154. 滑动窗口 239. 滑动窗口最大值 kmp算法 kmp算法 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:7:2","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 双指针 双指针算法一般有两种场景： 两个指针分别指向两个不同的集合 两个指针指向同一个集合，本质是维护该集合上的一段区间 双指针一般用于将暴力穷举O(n^2)的算法，优化到O(n)。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:0:0","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 package main import ( \"fmt\" ) func main() { var n int fmt.Scan(\u0026n) nums := make([]int, n) for i := 0; i \u003c n; i++ { fmt.Scan(\u0026nums[i]) } m := make([]int, 1e5 + 10) ans := 0 for i, j := 0, 0; i \u003c n; i++ { m[nums[i]]++ for m[nums[i]] \u003e 1 { m[nums[j]]-- j++ } ans = max(ans, i - j + 1) } fmt.Print(ans) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:0:1","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"经典模板题 799. 最长连续不重复子序列 800. 数组元素的目标和 3. 无重复字符的最长子串 2816. 判断子序列 位运算 常用的位运算操作： 取出n的二进制表示下第k位是多少——(n\u003e\u003ek)\u00261 返回n的二进制表示下最后一位1，也叫lowbit操作——n\u0026-n ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:0:2","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"取出第k位 用0表示第一位。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:1:0","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 package main import \"fmt\" func main() { n := 10 for k := 3; k \u003e= 0; k-- { fmt.Print(n\u003e\u003ek\u00261) } } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:1:1","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"lowbit 公式为：x \u0026 -x。 原理为： 负数在计算机中使用补码的方式表示，因此-x = ^x + 1，当x取反之后，x的最后的1会变成0，而最后的1后面的0会变成1，再加上1的话，会进位一直到最后的1处。因此-x的二进制表达形——最后一个1前与x全部取反，最后一个1及后面全部一致，然后x \u0026 -x就会得到最后一个1及后面的0组成的二进制数。 一般形式： x = 0b(10101010000) ^x = 0b(01010101111) ^x + 1 = 0b(01010110000) 计算过程： x \u0026 -x = 0b(10101010000) \u0026 \\ 0b(01010110000) = 0b(00000010000) lowbit的用处有很多，常见的有：快速计算一个数有多少个位为1。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:0","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 package main import \"fmt\" // 计算二进制表示中1的个数 func main() { var n int fmt.Scan(\u0026n) for i := 0; i \u003c n; i++ { var num, res int fmt.Scan(\u0026num) for num \u003e 0 { num -= lowbit(num) res++ } fmt.Printf(\"%d \", res) } } func lowbit(x int) int { return x \u0026 -x } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:1","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"经典模板题 801. 二进制中1的个数 191. 位1的个数 离散化 这里单独指整数离散化。离散化是指将一个稀疏的区间离散到一个紧凑的区间中。比如有一个区间范围为[-10^9 ~ 10^9]，但是里面只有的数只有10^5范围，那么显然这个区间是稀疏的，有很多重复或空的值。离散化就是把这个稀疏空间映射到紧凑空间上，降低操作的时空间复杂度。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:2","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 func main() { // 存储所有需要操作的下标 alls := make([]int, 0, N) // 对所有需要操作的下标排序去重 quickSort(\u0026alls, 0, len(alls) - 1) alls = unique(alls) // 二分求出离散化后的值 find(alls, x) } func unique(a []int) []int { j := 0 for i := 0; i \u003c len(a); i++ { if i == 0 || a[i] != a[i - 1] { a[j] = a[i] j++ } } // 不应该直接返回a的切片，这样会导致底层大数组的引用没有消失，gc就无法回收 // return a[:j] // 返回一个新开辟的切片，底层数组不同，gc可以将a回收掉 temp := make([]int, j) copy(temp, a[:j]) return temp } func find(a []int, x int) int { l, r := 0, len(a) - 1 for l \u003c r { mid := (l + r) \u003e\u003e 1 if a[mid] \u003e= x { r = mid } else { l = mid + 1 } } return r + 1 } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:3","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"经典模板题 802. 区间和 区间合并 合并满足某种条件的区间，本质是贪心算法。 经典例题是合并有交集的区间，排序后判断左右端点重合则重新维护最小和最大端点。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:4","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 func merge(segs []pair) []pair { // 首先从小到大排序区间 sort.Slice(segs, func(i, j int) bool { return segs[i].first \u003c segs[j].first }) temp := make([]pair, 0) // 赋予开始和结束端点最小值，避免重复 var st, ed int = math.MinInt64, math.MinInt64 // 遍历所有区间 for _, seg := range segs { // 当有区间与开始和结束端点重叠时，更新最大结束端点 if seg.first \u003c= ed { ed = max(ed, seg.second) // 如果没有重叠，说明是一个新区间，更新开始和结束端点 } else { // 避免重复 if st != math.MinInt64 { temp = append(temp, pair{st, ed}) } st = seg.first ed = seg.second } } // 避免重复，再加入最后一个区间 if st != math.MinInt64 { temp = append(temp, pair{st, ed}) } return temp } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:5","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"经典模板题 803. 区间合并 56. 合并区间 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:6","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 高精度 高精度是指，不能直接用一个变量来存储的数据，这种数据有几千位甚至几万位。存储这种数据必须使用数组。高精度运算就是为这种数据做算术运算。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:0:0","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"1.1 大整数相加 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:1:0","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"代码模板 package main import \"fmt\" func main() { a, b := \"\", \"\" fmt.Scanf(\"%s\", \u0026a) fmt.Scanf(\"%s\", \u0026b) A := make([]int, 0, len(a)) B := make([]int, 0, len(b)) for i := len(a) - 1; i \u003e= 0; i-- { A = append(A, int(a[i] - '0')) } for i := len(b) - 1; i \u003e= 0; i-- { B = append(B, int(b[i] - '0')) } C := add(A, B) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } } // C = A + B func add(A, B []int) (C []int) { t := 0 for i := 0; i \u003c len(A) || i \u003c len(B); i++ { if i \u003c len(A) { t += A[i] } if i \u003c len(B) { t += B[i] } C = append(C, t % 10) t /= 10 } if t == 1 { C = append(C, 1) } return C } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:1:1","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"经典模板题 791. 高精度加法 剑指 Offer II 025. 链表中的两数相加 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:1:2","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"1.2 大整数相减 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:2:0","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"代码模板 package main import \"fmt\" func main() { var a, b string fmt.Scanf(\"%s\", \u0026a) fmt.Scanf(\"%s\", \u0026b) A := make([]int, 0, len(a)) B := make([]int, 0, len(b)) for i := len(a) - 1; i \u003e= 0; i-- { A = append(A, int(a[i] - '0')) } for i := len(b) - 1; i \u003e= 0; i-- { B = append(B, int(b[i] - '0')) } if cmp(A, B) { C := sub(A, B) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } } else { // A \u003c B 的情况，要加上负号 fmt.Print(\"-\") C := sub(B, A) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } } } // 判断是否有 A \u003e= B func cmp(A, B []int) bool { if len(A) != len(B) { return len(A) \u003e len(B) } for i := len(A) - 1; i \u003e= 0; i-- { if A[i] != B[i] { return A[i] \u003e B[i] } } return true } // C = A - B // 应该保证 A \u003e= B func sub(A, B []int) (C []int) { t := 0 for i := 0; i \u003c len(A); i++ { t = A[i] - t if i \u003c len(B) { t -= B[i] } // 考虑了需要进位和不需要进位的情况 C = append(C, (t + 10) % 10) if t \u003c 0 { t = 1 } else { t = 0 } } // 去除前导零 for len(C) \u003e 1 \u0026\u0026 C[len(C) - 1] == 0 { C = C[:len(C) - 1] } return C } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:2:1","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"经典模板题 792. 高精度减法 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:2:2","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"1.3 大整数乘法 一个高精度的正整数A，乘上一个低精度的正整数b。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:3:0","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"代码模板 package main import \"fmt\" func main() { var a string var b int fmt.Scanf(\"%s\", \u0026a) fmt.Scanf(\"%d\", \u0026b) if b == 0 { fmt.Print(0) } else { A := make([]int, 0, len(a)) for i := len(a) - 1; i \u003e= 0; i-- { A = append(A, int(a[i] - '0')) } C := mul(A, b) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } } } // C = A * b // 0 \u003c= b \u003c= 10000 func mul(A []int, b int) (C []int) { for i, t := 0, 0; i \u003c len(A) || t \u003e 0; i++ { if i \u003c len(A) { t += A[i] * b } C = append(C, t % 10) t /= 10 } return C } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:3:1","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"经典模板题 793. 高精度乘法 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:3:2","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"1.4 大整数除法 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:4:0","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"代码模板 package main import \"fmt\" func main() { var a string var b int fmt.Scanf(\"%s\", \u0026a) fmt.Scanf(\"%d\", \u0026b) A := make([]int, 0, len(a)) for i := len(a) - 1; i \u003e= 0; i-- { A = append(A, int(a[i] - '0')) } C, r := div(A, b) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } fmt.Printf(\"\\n%d\", r) } // C = A / b, r = A % b // 1 \u003c= b \u003c= 10000 func div(A []int, b int) (C []int, r int) { // 高精度除法需要从最高位开始处理， // 与其他算术运算不同 for i := len(A) - 1; i \u003e= 0 ; i-- { r = r * 10 + A[i] C = append(C, r / b) r %= b } // 反转C，与其他算术运算输出逻辑保持一致 reverse(C, 0, len(C) - 1) // 去除前导零 for len(C) \u003e 1 \u0026\u0026 C[len(C) - 1] == 0 { C = C[:len(C) - 1] } return C, r } func reverse(a []int, l, r int) { for l \u003c r { a[l], a[r] = a[r], a[l] l++; r-- } } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:4:1","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"经典模板题 794. 高精度除法 前缀和与差分 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:4:2","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"一维前缀和 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:0","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"什么是前缀和？ 设有长度为n的原数组a，则其前缀和si为原数组前i项的和——si=a1+a2+...+ai，当i=0时，s0=0。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:1","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"如何求前缀和数组？ 从前往后遍历原数组，s[i]=s[i-1]+a[i]。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:2","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"前缀和的作用 前缀和一般用来在O(1)时间复杂度内求解区间和。比如求解原数组a[3]~a[10]的区间和，用前缀和求解为s[10]-s[2]。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:3","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 100010 var a[N]int var b[N]int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n, m int fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026a[i]) } for i := 1; i \u003c= n; i++ { b[i] = b[i - 1] + a[i] } for ; m \u003e 0; m-- { var l, r int fmt.Fscan(in, \u0026l, \u0026r) fmt.Fprintln(out, b[r] - b[l-1]) } } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:4","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"经典模板题 795. 前缀和 303. 区域和检索 - 数组不可变 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:5","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"二维前缀和 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:6:0","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() const N int = 1010 var a, s [N][N]int var n, m, q int fmt.Fscan(in, \u0026n, \u0026m, \u0026q) for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { fmt.Fscan(in, \u0026a[i][j]) } } for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { // 求前缀和 s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j] } } for ; q \u003e 0; q-- { var x1, y1, x2, y2 int fmt.Fscan(in, \u0026x1, \u0026y1, \u0026x2, \u0026y2) // 求子矩阵的和 fmt.Fprintln(out, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]) } } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:6:1","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"经典模板题 796. 子矩阵的和 304. 二维区域和检索 - 矩阵不可变 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:6:2","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"一维差分 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:0","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"什么是差分？ 差分是前缀和的逆运算，对一个差分数组求前缀和，得到原数组。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:1","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"如何求差分数组？ 构造这样一个数据，对于原数组a而言，差分数组b中每一个元素，都等于b[i] = a[i] - a[i-1]，其中b[1] = a[1]。 这样构造完之后，我们对其求前缀和可以发现，得到的答案就是原数组。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:2","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"差分的作用 差分数组用于解决区间加值的问题。比如给区间[l:r]中每一个数都加上C，利用差分数组可以在O(1)时间复杂度完成。 实现过程为，在差分数组b[l]处加上C，在b[r+1]处减去C，这样在还原为原数组时，区间[l:r]就施加上C的影响，在[r+1:n]减去C的影响。 公式为：b[l] += C; b[r+1] -= C。 图例——为[4:7]这个区间加上3。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:3","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N = 100010 var a [N]int var b [N]int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n, m int fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026a[i]) insert(i, i, a[i]) } for ; m \u003e 0; m-- { var l, r, c int fmt.Fscan(in, \u0026l, \u0026r, \u0026c) insert(l, r, c) } for i := 1; i \u003c= n; i++ { b[i] += b[i-1] fmt.Fprintf(out, \"%d \", b[i]) } } func insert(l, r, c int) { b[l] += c b[r+1] -= c } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:4","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"经典模板题 797. 差分 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:5","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"二维差分 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:8:0","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 1010 var a [N][N]int var b [N][N]int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n, m, q int fmt.Fscan(in, \u0026n, \u0026m, \u0026q) // 读取原数组数据，并构建差分数组 for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { fmt.Fscan(in, \u0026a[i][j]) insert(i, j, i, j, a[i][j]) } } // q次矩阵增加c值操作 for ; q \u003e 0; q-- { var x1, y1, x2, y2, c int fmt.Fscan(in, \u0026x1, \u0026y1, \u0026x2, \u0026y2, \u0026c) insert(x1, y1, x2, y2, c) } // 构建二维前缀和数组 for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1] } } // q次矩阵增加c之后的答案输出 for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { fmt.Fprintf(out, \"%d \", b[i][j]) } fmt.Fprintln(out) } } func insert(x1, y1, x2, y2, c int) { b[x1][y1] += c b[x2+1][y1] -= c b[x1][y2+1] -= c b[x2+1][y2+1] += c } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:8:1","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","前缀和","差分"],"content":"经典模板题 798. 差分矩阵 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:8:2","tags":["算法","算法整理","高精度","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","排序","二分"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 1. 排序 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:0:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"1.1 快速排序 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:1:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"代码模板 func sortArray(nums []int) []int { qucikSort(nums, 0, len(nums) - 1) return nums } func qucikSort(nums []int, l, r int) { if l \u003e= r { return } pivot := nums[(l + r) / 2] i, j := l - 1, r + 1 for i \u003c j { for i++; nums[i] \u003c pivot; i++ {} for j--; nums[j] \u003e pivot; j-- {} if i \u003c j { nums[i], nums[j] = nums[j], nums[i] } } qucikSort(nums, l, j) qucikSort(nums, j + 1, r) } ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:1:1","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"经典模板题 912. 排序数组 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:1:2","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"1.2 归并排序 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:2:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"代码模板 递归版 func sortArray(nums []int) []int { mergeSort(nums, 0, len(nums) - 1) return nums } func mergeSort(nums []int, left, right int) { if left \u003e= right { return } mid := (left + right) \u003e\u003e 1 mergeSort(nums, left, mid) mergeSort(nums, mid + 1, right) temp := merge(nums[left:mid+1], nums[mid+1:right+1]) copy(nums[left:], temp) } func merge(left, right []int) []int { temp := make([]int, len(left) + len(right)) i, j, k := 0, 0, 0 for i \u003c len(left) || j \u003c len(right) { if i \u003e= len(left) { copy(temp[k:], right[j:]) return temp } if j \u003e= len(right) { copy(temp[k:], left[i:]) return temp } if left[i] \u003c= right[j] { temp[k] = left[i] k++; i++ } else { temp[k] = right[j] k++; j++ } } return temp } 迭代版 func sortArray(nums []int) []int { mergeSort(nums) return nums } func mergeSort(nums []int) { for step := 1; step \u003c len(nums); step += step { for i := 0; i + step \u003c len(nums); i += 2 * step { temp := merge(nums[i:i+step], nums[i+step:min(i+2*step, len(nums))]) copy(nums[i:], temp) } } } func merge(left, right []int) []int { temp := make([]int, len(left) + len(right)) i, j, k := 0, 0, 0 for i \u003c len(left) || j \u003c len(right) { if i \u003e= len(left) { copy(temp[k:], right[j:]) break } if j \u003e= len(right) { copy(temp[k:], left[i:]) break } if left[i] \u003c= right[j] { temp[k] = left[i] k++; i++ } else { temp[k] = right[j] k++; j++ } } return temp } func min(a, b int) int { if a \u003c b { return a } return b } ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:2:1","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"经典模板题 912. 排序数组 剑指 Offer 51. 数组中的逆序对 2. 二分 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:2:2","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"2.1 整数二分 二分的本质是将一个区间分为两块，一块满足要求，另一块不满足要求，然后就可以寻找这两块区间的边界。 每次缩小的时候，都要确保剩余区间内有答案。 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:3:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"代码模板 // 左闭右开区间 // lowerBound 返回最小的满足 nums[i] \u003e= target 的 i // 如果数组为空，或者所有数都 \u003c target，则返回 nums.length // 要求 nums 是非递减的，即 nums[i] \u003c= nums[i + 1] func lowerBound(a []int, x int) int { // [l : r) // 循环不变量： // a[l - 1] \u003c x // a[r] \u003e= x l, r := 0, len(a) for l \u003c r { m := (l + r) \u003e\u003e 1 if a[m] \u003c x { l = m + 1 // 范围缩小到 [m + 1 : r) } else { r = m // 范围缩小到 [l : m) } } return l // 或者返回 r } golang的标准库中内置了二分查找的API——sort.SearchInts()，其实现代码跟模板代码类似，也是lower_bound的写法，但是进行了抽象。 把if a[m] \u003c x这一句代码进行了抽象，改为传入一个闭包函数，当条件不满足时，缩小左区间，否则缩小右区间。 // src/sort/search.go;l=124 func SearchInts(a []int, x int) int { // 闭包函数把 x 包进去了 return Search(len(a), func(i int) bool { return a[i] \u003e= x }) } func Search(n int, f func(int) bool) int { // 定义循环不变量 // Define f(-1) == false and f(n) == true. // Invariant: f(i-1) == false, f(j) == true. i, j := 0, n for i \u003c j { h := int(uint(i+j) \u003e\u003e 1) // avoid overflow when computing h // i ≤ h \u003c j if !f(h) { i = h + 1 // preserves f(i-1) == false } else { j = h // preserves f(j) == true } } // i == j, f(i-1) == false, and f(j) (= f(i)) == true =\u003e answer is i. return i } 一些常用的使用方法 寻找x的左边界: l := sort.SearchInts(nums, x)，如果不存在x，则l = len(nums) 寻找x的右边界: r := sort.SearchInts(nums, x + 1) - 1，如果不存在x，则r = len(nums) 寻找第一个\u003ex的: sort.SearchInts(nums, x + 1) 寻找第一个\u003cx的: sort.SearchInts(nums, x) - 1 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:3:1","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"关于 lower_bound 和 upper_bound lower_bound是寻找第一个\u003e=x的下标 upper_bound是寻找第一个\u003ex的下标 golang实现lower_bound和upper_bound // 如果不存在 x，返回的下标是 0 func lowerBound(a []int, x int) int { return sort.Search(len(a), func(i int) bool { return a[i] \u003e= x }) } func upperBound(a []int, x int) int { return sort.Search(len(a), func(i int) bool { return a[i] \u003e x }) } lower_bound() - 1是\u003cx的最大下标，-1表示不存在 upper_bound() - 1是\u003c=x的最大值下标，-1表示不存在 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:3:2","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"关于循环不变量 循环不变量指的是在循环中，性质不变的量。 比如我们定义L的左侧是\u003cx的，R的右侧是\u003e=x的，保证这两个变量的性质，在循环时和循环后不改变，这就叫循环不变量。 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:3:3","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"模板实践 34. 在排序数组中查找元素的第一个和最后一个位置 func searchRange(nums []int, target int) []int { // 寻找左边界 l := lowerBound(nums, target) if l == len(nums) || nums[l] != target { return []int{-1, -1} } // 左边界存在，右边界肯定存在 // 寻找右边界，第一个 \u003e=target+1 的下标，这个下标-1 就是 target 的右边界 r := lowerBound(nums, target + 1) - 1 return []int{l, r} } func lowerBound(a []int, x int) int { l, r := 0, len(a) for l \u003c r { m := (l + r) \u003e\u003e 1 if a[m] \u003c x { l = m + 1 } else { r = m } } return l } 用标准库函数 func searchRange(nums []int, target int) []int { l := sort.SearchInts(nums, target) if l == len(nums) || nums[l] != target { return []int{-1, -1} } r := sort.SearchInts(nums, target + 1) - 1 return []int{l, r} } ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:3:4","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"经典模板题 704. 二分查找 34. 在排序数组中查找元素的第一个和最后一个位置 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:3:5","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"2.2 浮点数二分 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:4:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"代码模板 func mySqrt() { var x float64 fmt.Scanf(\"%f\", \u0026x) var l, r float64 = 0, x for r - l \u003e 1e-8 { mid := (l + r) / 2 if mid * mid \u003e= x { r = mid } else { l = mid } } fmt.Printf(\"%f\", l) } ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:4:1","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"经典模板题 69. x 的平方根 790. 数的三次方根 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:4:2","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","树状数组"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 参考 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:0:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"树状数组是什么？ 树状数组，或称Binary Indexed Tree, Fenwick Tree，是一种用于高效处理对一个存储数字的列表进行更新及求前缀和的数据结构。 树状数组所能解决的典型问题就是存在一个长度为n的数组，我们如何高效进行如下操作： update(idx, delta)：将num加到位置idx的数字上。 prefixSum(idx)：求从数组第一个位置到第idx（含idx）个位置所有数字的和。 rangeSum(from_idx, to_idx)：求从数组第from_idx个位置到第to_idx个位置的所有数字的和 如果用暴力求解数组区间和，时间复杂度为O(n)，更新数组值为O(1)。 // [left,right] func rangeSum(left, right int) int { // 时间复杂度O(n)，与for left\u003c= right 没有数量级上的差距 return sum(right) - sum(left - 1) } // [0,index] func sum(index int) int { if index \u003c 0 || index \u003e= len(nums) { return 0 } sum := 0 for i := index; i \u003e= 0; i-- { sum += nums[i] } return sum } // O(1) func update(index, delta int) { nums[index] += delta } 用前缀和求解区间和的时间复杂度为O(1)，更新数组值为O(n) type Presum struct { nums []int } func NewPreSum(nums []int) Presum { pre := make([]int, len(nums)) pre[0] = nums[0] for i := 1; i \u003c len(nums); i++ { pre[i] = pre[i-1] + nums[i] } return Presum{ nums: pre, } } func (p *Presum) Update(index, val int) { // O(n) for i := index; i \u003c len(p.nums); i++ { p.nums[i] += val } } func (p *Presum) SumRange(left, right int) int { // O(1) return p.nums[right] - p.nums[left-1] } 树状数组求解区间和的时间复杂度为O(logn)，更新数组值为O(logn)。因为修改值之后需要重新维护树状数组。 type BinaryIndTree struct { Nums []int Tree []int } func NewBinaryIndTree(nums []int) BinaryIndTree { // 用前缀和快速构造树状数组 length := len(nums) tree := make([]int, length+1) preSum := make([]int, length+1) for i := 1; i \u003c= length; i++ { preSum[i] = preSum[i-1] + nums[i-1] tree[i] = preSum[i] - preSum[i-lowbit(i)] } return BinaryIndTree{ Nums: nums, Tree: tree, } } func lowbit(i int) int { return i \u0026 (-i) } func (b *BinaryIndTree) Add(index, delta int) { // O(logn) for i := index; i \u003c len(b.Tree); i += lowbit(i) { b.Tree[i] += delta } } func (b *BinaryIndTree) Update(index, val int) { b.Add(index+1, val-b.Nums[index]) b.Nums[index] = val } func (b *BinaryIndTree) Sum(index int) int { sum := 0 // O(logn) for i := index; i \u003e 0; i -= lowbit(i) { sum += b.Tree[i] } return sum } func (b *BinaryIndTree) SumRange(left, right int) int { return b.Sum(right+1) - b.Sum(left) } 树状数组适用于对数组查询和修改都有性能要求的场景。 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:1:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"树状数组如何高效？ 看上面这张图，可以把树状数组想象成一棵树。所有奇数下标的都是独立子节点。子节点通过i+lowbit(i)来找到其父节点，父节点存储的就是它和它所有子节点的和。通过这样一棵树，我们可以用O(logn)的时间复杂度来获得一个区间的和。 为了方便表示，tree被画成了不连续的样子，实际上tree在内存中仍是连续的数组。 下面这样图可以比较容易理解树状数组在更新节点值时，如何知道那些节点值是应该更新的。 比如我们要对下标i的值进行更新，除了对i本身，还有其上面覆盖了i(或者说管辖i)的所有节点进行更新。比如i=1，则需要更新的节点为1、2、4、8 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:2:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"lowbit原理 lowbit(i)用一句话来解释就是——截断i在二进制表示中最低位1前面的数。 比如：i=6=b(110)，截断最低位1前面的数得到b(10)=2 lowbit实现很简单 func lowbit(i int) int { // return i \u0026 ((~i)+1) 两者等价 return i \u0026 (-i) } 为什么\u0026上自己的负数可以截断最低位1前面的数呢？因为负数在计算机中是用补码来表示的，所以我们需要对补码、原码有一些了解。 原码：用最高位表示符号位，如int8(-8) = 原(10001000) 补码：对原码除符号位之外的所有位取反并加1，如int8(-8) = 补(11111000) 反码：对原码除符号位之外的所有位取反，如int8(-8) = 反(11110111) 这里我们以6和-6为例，假设他们都是有符号的8位数。 可以发现一个数的正数与负数，它们除了最低位的1及后面的数之外，每一位的数都不相同，因此它们相\u0026可以得到我们想要的结果——截断i在二进制表示中最低位1前面的数。 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:2:1","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"树状数组功能一览 根据节点维护的数据含义不同，树状数组可以提供不同的功能来满足各种区间场景。 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"1. 单点增减+区间求和 LeetCode-307. 区域和检索 - 数组可修改 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:1","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"2. 区间增减+单点查询 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:2","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"3. 区间增减+区间求和 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:3","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"4. 单点增减+区间最值 HDU-1754 I Hate It ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:4","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"5. 区间叠加+单点最值 LeetCode-218. 天际线问题 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:5","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"树状数组常见应用 求逆序对 求区间逆序对 求树上逆序对 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:4:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"二维树状数组 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:5:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"完整代码 type BinaryIndTree struct { Nums []int Tree []int } func NewBinaryIndTree(nums []int) BinaryIndTree { // 用前缀和快速构造树状数组 length := len(nums) tree := make([]int, length+1) preSum := make([]int, length+1) for i := 1; i \u003c= length; i++ { preSum[i] = preSum[i-1] + nums[i-1] tree[i] = preSum[i] - preSum[i-lowbit(i)] } return BinaryIndTree{ Nums: nums, Tree: tree, } } func (b *BinaryIndTree) update(index, delta int) { for i := index; i \u003c len(b.Tree); i += lowbit(i) { b.Tree[i] += delta } } func (b *BinaryIndTree) Update(index, val int) { b.update(index+1, val-b.Nums[index]) b.Nums[index] = val } func (b *BinaryIndTree) Sum(index int) int { sum := 0 for i := index; i \u003e 0; i -= lowbit(i) { sum += b.Tree[i] } return sum } func (b *BinaryIndTree) SumRange(left, right int) int { return b.Sum(right+1) - b.Sum(left) } func lowbit(i int) int { return i \u0026 (-i) } ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:6:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","查找算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:0","tags":["算法","查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法","查找算法"],"content":"二分查找 对于任何有序集合，我们可以使用二分查找的方式来快速定位到想要的元素。 二分查找的时间复杂度为O(logn) 二分查找的实现难点在于边界条件的判断，要注意集合的闭合区间。实现时闭合区间分为两种：[left,right]和[left,right)，两种不同的闭合区间的代码实现也不同。 ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:0","tags":["算法","查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法","查找算法"],"content":"二分查找的边界条件 [left,right] // BinarySearch 查找nums中是否存在target，并返回其下标，如果不存在返回-1 func BinarySearch(nums []int, target int) int { length := len(nums) left, right := 0, length - 1 for left \u003c= right { mid := left + (right - left) / 2 if nums[mid] \u003c target { left = mid + 1 } else if nums[mid] \u003e target { right = mid - 1 } else { return mid } } return -1 } [left,right) // BinarySearch 查找nums中是否存在target，并返回其下标，如果不存在返回-1 func BinarySearch(nums []int, target int) int { length := len(nums) left, right := 0, length for left \u003c right { mid := left + (right - left) / 2 if nums[mid] \u003c target { left = mid + 1 } else if nums[mid] \u003e target { right = mid } else { return mid } } return -1 } ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:1","tags":["算法","查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法","查找算法"],"content":"二分查找其他应用 二分查找不仅可以用于有序序列，还可以用于部分有序序列，比如leetcode 153.寻找旋转排序数组中的最小值也可以使用二分法。 由此我们可知，二分查找只是一种查找的思想。对于查找一个值，我们要首先想到如何能跳过一些无意义的比较，收缩左右边界，以达到加快搜索的过程。 ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:2","tags":["算法","查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法","回溯"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:0","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","回溯"],"content":"回溯 回溯就是暴力穷举，对于一些组合、切割、求子集、n皇后等问题，只能使用暴力穷举的方式遍历所有可能性求解。 回溯用于解决n层for循环的问题 对于一个长度为n的序列，要求出它所有的子集，需要写出n层for循环。因为序列长度n未知，所以连用for暴力穷举的代码都写不出来。 这是就要用到回溯，通过递归的方式，不断深入，开启n层for循环。 n层递归的循环，就像是一颗树，循环的次数是树的宽度，递归的次数是树的深度 ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:1","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","回溯"],"content":"回溯模板 func demo() { // 存放结果 res := make([]int, 0) // 存放临时结果 path := make([]int, 0) // 回溯函数的参数很难提前确定 // 一般在写具体实现是根据需要补上 var backTracking func(所需参数) backTracking = func(所需参数) { if 满足要求 { // 新申请内存空间，避免底层数组一致 res = append(res, append([]int{}, path...)...) return } for 遍历序列 { path = append(添加临时结果) backTracking(所需参数) path = path[:len(path)-1] } } } ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:2","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","回溯"],"content":"回溯的去重 去重首先需要序列有序，然后在for循环内部判断当前元素与前一元素是否相同，如果相同就continue ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:3","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","回溯"],"content":"标识当前元素已被使用 used := make([]bool, length) backTracking = func() { for i := 0; i \u003c len(nums); i++ { if used[i] { continue } used[i] = true ... backTracking() used[i] = false ... } } ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:4","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["MySQL","SQL"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:0:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"检索 # 查找并去重，如果有多列，则要一整行完全一样才会去重 SELECT DISTINCT prod_name FROM prod_table; # limit限制输出的行数，第一个参数指示从第几行开始(从0开始算)，后面参数指示输出几行 SELECT prod_name FROM prod_table LIMIT 5, 3; SELECT prod_name FROM prod_table LIMIT 3 OFFSET 5; # 一样的意思 # 根据当前列进行排序 SELECT prod_name FROM prod_table ORDER BY prod_name; # 根据其他列排序当前列 SELECT prod_name FROM prod_table ORDER BY id; # 根据多列进行排序，先根据prod_name列排序，再根据id列排序（只有prod_name列的值重复时，才会使用id列排序） SELECT prod_name FROM prod_table ORDER BY prod_name, id; # 倒序排序，想根据多个列进行降序排序，必须在每个列后面都跟上DESC SELECT prod_name FROM prod_table ORDER BY prod_name DESC, id DESC; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:1:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"过滤数据 # 过滤price=2.2的列，支持的操作符有：=, !=, \u003c, \u003e, \u003c=, \u003e=, BETWEEN SELECT price FROM prices WHERE price=2.2; # BETWEEN过滤，范围[2.2 ~ 3.2] SELECT price FROM prices WHERE price BETWEEN 2.2 AND 3.2; # 过滤非空值 SELECT prod_name FROM prod_table WHERE prod_name IS NOT NULL; # 多过滤条件组合，OR, AND, NOT, IN，符号优先级AND \u003e OR，可以加上括号()来明确优先级 SELECT prod_name FROM prod_table WHERE (prod_name = \"apple\" OR prod_name = \"mongo\") AND prod_price \u003e 2.2 AND prod_price \u003c 4.4; # IN操作符，过滤条件是否在集合中 SELECT prod_name FROM prod_table WHERE prod_name IN (\"apple\", \"mongo\"); # 模糊匹配，%匹配多个任意字符，_匹配任意单个字符 # 模糊匹配性能很差 SELECT prod_name FROM prod_table WHERE prod_name LIKE \"%apple%\"; SELECT prod_name FROM prod_table WHERE prod_name LIKE \"_ppl_\"; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:2:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"正则匹配REGEXP SELECT prod_id, prod_name FROM products WHERE prod_id REGEXP '' 一些特殊字符：-,|,[], ^的双重用途 当在集合中[^]，表示否定集合的条件 当在集合外^[]，表示以该集合条件开头 MYSQL中快速测试正则表达式是否可以正确工作：SELECT 'hts_0000@sina.com' REGEXP '^[:alnum:]{4,15}@[sina|qq|163]\\\\.[com|cn]$', ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:3:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"拼接字段 # 把输出内容格式化，有点像printf SELECT Concat(prod_name, \"(\", prod_price, \")\") FROM prod_table; # 去除字段左右多余空格，RTrim去除右边空格，LTrim去除左边空格，Trim去除左右空格 SELECT Concat(RTrim(prod_name), \"|\", LTrim(prod_name), \"|\", Trim(prod_name)) FROM prod_table; # 计算price*num的值，并将计算结果展示为expanded_price列 SELECT price, num, price*num AS expanded_price FROM prices; MYSQL中快速测试函数调用和计算表达式的值：SELECT 2*3;或SELECT Trim(' hello world '); ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:4:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"函数 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:5:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"文本处理函数 RTrim, LTrim, Trim # Upper, Lower SELECT price_name, Upper(price_name) as upper_price_name, Lower(price_name) as lower_price_name FROM prices; # Length, Locate, Soundex, SubString ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:5:1","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"时间函数 MYSQL中存储时间的数据类型为datatime，其会将时间存储为YYYY-MM-DD HH:mm::ss，因此下面的时间匹配是不可靠的，因为它只匹配了日期，而没有时间。可靠的做法是，用Date()函数，提取order_date这一列数组中的日期部分，再做匹配 # 不可靠的做法 SELECT cust_id, order_num FROM orders WHERE order_date = '2020-01-01'; # 可靠的做法 SELECT cust_id, order_num FROM orders WHERE Date(order_date) = '2020-01-01'; # 匹配2005年9月的所有数据 SELECT cust_id, order_num FROM orders WHERE Year(order_date) = 2005 AND Month(order_date) = 9; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:5:2","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"数值处理函数 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:5:3","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"聚合函数 汇总数据，而不是检索出来。常用的汇总有： 汇总行数 行数据组之和 列数据之和、最大值、最小值、平均值等 # AVG, COUNT, MAX, MIN, SUM SELECT MAX(price), MIN(price), SUM(price), COUNT(price), AVG(price) FROM prices; MAX()一般用来找出数值或时间类型的最大值，但它也能用来找文本类型的最大值。MIN()它也能用来找文本类型的最小值 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:5:4","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"系统函数 返回系统信息，如登录用户信息、系统版本等 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:5:5","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"聚合数据 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:6:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"分组数据 分组允许把数据分为多个逻辑组，以便对每个组做聚合计算。 # 根据vend_id创建分组，再对每一组做聚合计算(这里的聚合是COUNT(*)) SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:7:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"GROUP BY 创建分组 # 根据id把ids表排序分组，COUNT(*)是对每个分组的数据进行统计 SELECT id, count(*) AS num_id FROM ids GROUP BY id; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:7:1","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"HAVING 过滤分组 HAVING功能跟WHERE类似，HAVING仅仅是因为分组查询出来的数据WHERE不能用过滤分组，仅此而已。HAVING基本上能代替WHERE所有功能。 注意，用HAVING过滤的时候，不能写别名，必须用前面聚合的表达式。如下面的例子就必须用COUNT(*)，而不能用num_id # 分组的过滤不能使用WHERE，必须使用HAVING SELECT id, COUNT(*) AS num_id FROM ids GROUP BY id HAVING COUNT(*) \u003e 2; # HAVING和WHERE合用的例子 # 返回有2个物品价格\u003e=10的供应商id SELECT vend_id, COUNT(*) AS num_id FROM products WHERE prod_price \u003e= 10 GROUP BY vend_id HAVING COUNT(*) \u003e= 2; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:7:2","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"子查询 就是嵌套查询 # 先查询购买了TNT2的所有订单号，再根据订单号过滤出客户id SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = \"TNT2\"); # 为计算列使用子查询，将customers.cust_id列与子查询中的orders.cust_id列一一比较，n*m的嵌套比较关系 SELECT cust_id, cust_name, cust_state, (SELECT count(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS orders FROM customers ORDER BY cust_name; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:8:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"联结表 JOIN 联结表时，实际上就是把第一个表中的每一行与第二个表的每一行配对。相当于做了一个笛卡尔积。 内联结——基于两个表之间的相等测试。 # 将vendors表和products表联结起来，配对vendors和products表的每一行数据，当id对应时，就输出供应商名称，产品名称和产品价格，通过这种方法可以找到产品对应的供应商。 # 这种方法需要表与表之间有关系，主键和外键 SELECT vend_name, prod_name, prod_price FROM vendors, products WHERE vendors.vend_id = products.vend_id; # 内联结写法 SELECT vend_name, prod_name, prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id ORDER BY vend_name, prod_name; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:9:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"高级联结 表可以声明别名，用AS关键字。表的别名能有效缩短SQL语句。 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:10:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"自联结 表a联结表a，自己联结自己。使用场景是，我想要在当前表中找到生产了’DTNTR’这个产品ID的供应商生产的所有产品。 自联结需要用到表别名 SELECT p1.prod_id, p1.prod_name FROM products AS p1, products AS p2 WHERE p1.vend_id = p2.vend_id AND p2.prod_id = 'DTNTR'; 自然联结 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:10:1","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"外部联结 内联结 只列出ON匹配的行 左联结 选择LEFT OUTER JOIN子句左边的所有行去匹配右边的所有行，如果右边有不匹配的行，就是NULL，ON后面的条件不匹配也会列出来 右联结 选择RIGHT OUTER JOIN子句右边的所有行去匹配左边的所有行，如果左边有不匹配的行，就是NULL，ON后面的条件不匹配也会列出来 左右联结可以互换使用，只需要调整WHERE或FROM子句中表的顺序。 # 检索所有客户及他们的订单，包括没有订单的客户，如果用内联结，就无法检索出没有订单的客户了 SELECT c.cust_id, o.order_num FROM customers AS c LEFT OUTER JOIN orders AS o ON c.cust_id = o.cust_id; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:10:2","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"使用带聚集函数的联结 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:10:3","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"组合查询 用UNION操作将多条SELECT语句组合成一个结果集。 UNION操作与多个WHERE条件查询结果完成的工作一样。但是执行性能不一样，需要试试才知道哪个性能好。 UNION并上的SELECT必须有相同的列，列的顺序可以不同。 UNION会自动去重，与WHERE结果一样。如果不想去重，用UNION ALL，UNION ALL与WHERE就不一样了，它能做到WHERE做不到的事。 # 查找产品价格小于等于5的产品，并上vend_id为1001或1002的 SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price \u003c= 5 UNION SELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001, 1002); # 与上面等价的WHERE SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price \u003c= 5 OR vend_id IN (1001, 1002); ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:11:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"全文本搜索 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:12:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"插入 # 依赖表定义定义的次寻，每个值必须与表中列的定义对应上，如果定义允许为空，才能使用NULL # 主键都是填NULL，让MYSQL自动生成 INSERT INTO Customers VALUES(NULL, 'PeP E. La', '100'); # 也可以指定列名，这样的好处是，表结构发生变化该SQL也能工作，因为它不强依赖列的次寻 # 不必总是填上所有列，没有指定的列，会被填上NULL INSERT INTO Customers(cust_name, cust_contace, cust_email) VALUES('PeP E. La', NULL, 'pepela@gla.com'); # 插入多行 INSERT INTO Customers( cust_name, cust_contace, cust_email) VALUES( 'PeP E. La', NULL, 'pepela@gla.com' ), ( 'PeP E. La', NULL, 'pepela@gla.com' ); ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:13:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"更新 UPDATE customers SET cust_email = 'test@google.com' WHERE cust_id = 10005; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:14:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"删除 DELETE FROM customers WHERE cust_id = 10005; TRUNCATE TABLE; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:15:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"创建表 CREATE TABLE `test` ( `cust_id` int(11) NOT NULL AUTO_INCREMENT, `cust_name` char(50) NOT NULL, `cust_address` char(50) DEFAULT NULL, `cust_city` char(50) DEFAULT NULL, `cust_state` char(5) DEFAULT NULL, `cust_zip` char(10) DEFAULT NULL, `cust_country` char(50) DEFAULT NULL, `cust_contact` char(50) DEFAULT NULL, `cust_email` char(255) DEFAULT NULL, PRIMARY KEY (`cust_id`) ) ENGINE=InnoDB AUTO_INCREMENT=10006 DEFAULT CHARSET=utf8mb4; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:16:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"更新表 更新表的定义 # 增加列 ALTER TABLE Customers ADD describes CHAR(50); # 删除列 ALTER TABLE Customers DROP COLUMN describes; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:17:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"删除表 DROP TABLE customers; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:18:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"重命名表 RENAME TABLE old_table TO new_table; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:19:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"视图 视图是虚拟的表，虚拟表不包含数据，它包含的是一个SQL查询。 为什么要使用视图： 重用SQL语句 简化SQL操作 使用表的组成部分，而不是整个表 保护数据，可以只给到用户视图，而不是整个表 视图创建后，可以像使用表一样使用它，包括SELECT、过滤、排序、JOIN其他表或视图，甚至添加和更新数据。 视图仅仅是用来查看存储在别处的数据的一种设施，视图本身不包含数据，因此它返回的数据是从其他表中检索出来的。 视图最重要的功能就是，将一些常用的、重复的基础查询虚拟成一张表，我们可以在建视图的时候就格式化好里面的数据，使其更有用，减少重复劳动。 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:20:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"使用视图 # 创建视图 CREATE VIEW productcustomers AS SELECT cust_name, cust_contact, prod_id FROM customers, orders, orderitems WHERE customers.cust_id = orders.cust_id AND orderitems.order_num = orders.order_num; # 查看创建视图的语句 SHOW CREATE VIEW viewname; # 删除视图 DELETE VIEW viewname; # 用视图重新格式化检索出来的数据 CREATE VIEW vendorlocation AS SELECT Concat(RTrim(vend_name), ' (', RTrim(vend_country), ')') AS vend_title FROM vendors ORDER BY vend_name; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:20:1","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"存储过程 存储过程简单来说是一条或多条SQL语句的集合，可将其视为批处理文件，但不仅限于批处理。本质就是一个函数。 存储过程简单、安全并且性能高。 存储过程创建之后，会一直存在，直至被显式删除。 存储过程不易于版本管理和调试，阿里开发规范中不建议使用存储过程。 但是存储过程可以封装数据处理、提高性能、减少数据传输带宽，具体使用要视情况而定。 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:21:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"执行/调用存储过程 # 调用productpricing这个存储过程，@pricelow表示用pricelow这个变量来存储结果，MySQL中的变量必须以@开头 CALL productpricing(@pricelow, @pricehight, @priceaverage); # 如果是要传入变量给存储过程 CALL productpricing(1000, @pricelow, @pricehight, @priceaverage); ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:21:1","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"创建存储过程 在MySQL命令行中创建存储过程，需要把语句分隔符;改掉，不然会报语法错误。在其他数据库工具中应该不需要这样改。 一般来说，存储过程不显示结果，而是把结果返回给你指定的变量。 # 修改分隔符为// DELIMITER // # 创建一个名为productpricing的无参数存储过程 CREATE PROCEDURE productpricing() BEGIN SELECT Avg(prod_price) AS priceaverage FROM products; END// # 有返回参数的存储过程 # BEGIN上面的这一块是定义入参和出参的地方 # BEGIN和END中间这一段是具体逻辑 CREATE PROCEDURE productpricing( OUT pl DECIMAL(8, 2), # 返回pl给调用者 OUT ph DECIMAL(8, 2), OUT pa DECIMAL(8, 2) ) BEGIN SELECT Min(prod_price) INTO pl # 表示将结果传递给pl变量 FROM products; SELECT Max(prod_price) INTO ph FROM products; SELECT Avg(prod_price) INTO pa FROM products; END// # 调用上面的存储过程 CALL productpricing(@pl, @ph, @pa)// # 使用上面的存储过程，不会产生输出，而是会返回pl、ph、pa变量，访问变量来获取结果 SELECT @pl as pricelow// SELECT @pl as pricelow, @ph as pricehight, @pa as priceaverage// # 定义一个具有入参的存储过程 CREATE PROCEDURE ordertotal( IN onumber INT, # 接受一个INT型的参数 OUT ototal DECIMAL(8, 2) ) BEGIN SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num = onumber # 在这里用上了onumber INTO ototal; END// # 调用上面的存储过程 CALL ordertotal(20005, @total)// # 修改分隔符为; DELIMITER ; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:21:2","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"删除存储过程 DROP PROCEDUER IF EXISTS productpricing; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:21:3","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"更高级更复杂的存储过程 下面这个存储过程功能为，给出是否需要加税taxable，计算给定客户编号onumber的价格总计ototal。 -- 这些都是注释 -- Name: ordertotal -- Parameters: onumber = order number -- taxable = 0 if not taxable, 1 if taxable -- ototal = order total variable CREATE PROCEDURE ordertotal( IN onumber INT, IN taxable BOOLEAN, # 传入的是一个布尔值 OUT ototal DECIMAL(8, 2) ) COMMENT '订单收益总计，是否附加税' # 这条也是注释，用SHOW PROCEDURE STATUS可以看到 BEGIN -- Declare variable for total DECLARE total DECIMAL(8, 2); # 这里定义的就是局部变量 -- Declare tax percentage DECIMAL taxrate INT DEFAULT 6; # 定义税率 -- Get the order total SELECT Sum(item_price*quantity) FROM orderitems WHERE ordr_num = onumber INTO total; -- Is this taxable? IF taxable THE # 传入的布尔值为真，就加上税率 -- Yes, so add taxrate to the total SELECT total+(total/100*taxrate) INTO total; END IF; -- And finally, save to out variable SELECT total INTO ototal; # 将最终计算结果传出去 END; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:21:4","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"游标 从一组结果中获取数据的指针，可以任取结果集中前几行后几行和某几行，像一个迭代器。 MySQL中的游标只能在存储过程或函数中使用。 游标只能定义在存储过程和函数中，定义好之后还要显式的打开和关闭它，以启用和释放游标占用的资源。 CREATE PROCEDURE processorders() BEGIN -- Declare local variables DECLARE o INT; -- Declare the cursor -- 从SELECT查询出来的一组数据集中定义一个游标 DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; -- Declare continue handler -- 当出现02000错误时，done被设置为1 -- 02000错误会发生在REPEAT无法提供更多循环时 DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1; -- Open the cursor -- 显式的打开游标 OPEN ordernumbers; -- Get order number -- 从游标中获取一个数据 FETCH ordernumers INTO o; -- Loop through all rows REPEAT -- Get order number FETCH ordernumers INTO o; -- End of loop -- 当没有更多数据可迭代了，会发生02000错误，done被置为1 -- UNTIL 意思为直到 done 为真了，才停止 UNTIL done END REPEAT; --Close the cursor -- 显式的关闭游标 CLOSE ordernumbers; END// ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:22:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"触发器 在DELTE、UPDATE、INSERT操作执行之后触发一系列操作。 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:23:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"事务 MySQL常用的引擎中有InnoDB引擎是支持事务的，MyISAM则不支持。 事务，用来保证一批SQL操作的原子性，要么全部成功，要么全部失败。 如果事务中某条SQL语句执行出错了，那么整个事务会被自动回滚。 当事务中执行了ROLLBACK或COMMIT，事务会自动关闭。 MySQL命令行中，所有操作都是默认自动提交的，执行的DELETE、INSERT等操作，本来应该是需要显式的COMMIT才会修改，但是因为设置了默认提交，所以会立即生效，如果想改变默认提交行为，可以使用下面的命令。 # 默认不提交 SET autocommit=0; # 默认提交 SET autocommit=1; 事务处理的术语： 事务(transaction) 指一批SQL语句 回退(rollback) 回退事务，撤销未commit前的所有事务操作，回退不能回退CREATE和DROP操作 提交(commit) 将事务执行结果写入数据库表 保留点(savepoint) 设置一个储存点，回退到这个储存点，而不是整个事务 # 开始事务 START TRANSACTION SELECT * FROM orders; DELETE FROM orders; # 删除orders表中的所有行 SELECT * FROM orders; # 回退这个事务，其实就是回退了所有改变数据的操作，上面只有DELETE，回退SELECT是没有意义的 # 执行完整ROLLBACK之后事务就隐形关闭了 ROLLBACK; # 需要重新开启事务 START TRANSACTION SELECT * FROM orders; DELETE FROM orders; # 设置一个保留点，可以ROLLBACK到这个位置，上面的操作不会被回滚 SAVEPOINT delete1; ROLLBACK TO delete1; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:24:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"字符集管理 两个概念，字符集(CHARACTER)和其对应的校对(COLLATION)。 字符集负责字符串的编码规则，常见的有 utf8 和 utf8mb4。 utf8 和 utf8mb4 的区别： utf8是变长字节编码，会用1~4字节去编码，MySQL中最多使用3字节，因此无法支持emoji表情等需要4字节才能表示的字符 utf8mb4是固定长度的编码，统一使用4字节，完全涵盖世上所有字符 校对是对应的字符集的排序字符集。字符串除了存储还需要排序和比较，校对就是干这件事的。 校对字符集也有两类常见的，utf8mb4_general_ci 和 utf8mb4_unicode_ci。 utf8mb4_general_ci 和 utf8mb4_unicode_ci 的区别： utf8mb4_general_ci没有实现基于标准Unicode编码的排序，对于一些特殊的字符和emoji排序的结果可能不是期望值 utf8mb4_unicode_ci实现了基于标准Unicode编码的排序，能够精确的排序所有字符，但是相对更加耗时 MySQL8.0中默认字符集是utf8mb4，默认校对集是utf8mb4_0900_ai_ci。 在8.0之前，应该选择utf8mb4和utf8mb4_unicode_ci或者是utf8_unicode_520_ci如果有的话。 # 查看所有字符集及其默认校对 SHOW CHARACTER SET; # 查看所有可用校对 SHOW COLLATION; # 查看创建数据库或表时使用的字符集和校对 SHOW VARIABLES LIKE 'character%'; SHOW VARIABLES LIKE 'collation%'; # MySQL允许对数据库、表和每一列单独设置 # 单独设置数据库 CREATE DATABASE test DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; CREATE TABLE test_table( id INT, name VARCHAR(20), email VARCHAR(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci # 单独设置列 ) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; # 单独设置表 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:25:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"安全管理 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:26:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"用户管理 MySQL用户账户信息存储在mysql.user表中。 有三种方法可以创建用户： CREATE语句 GRANT语句，MySQL8.0中不在支持 在mysql.user表中INSERT一条记录 CREATE语句创建用户的语义是最清晰的。GRANT语句是用来给用户赋予权限的。直接INSERT则是强烈不建议使用。 # 查看所有用户信息 SELECT * FROM mysql.user; # 创建一个用户，基于给定的密码 CREATE USER xiaoming IDENTIFIED BY 'p@$$w0rd'; # 重命名用户，仅支持5.0之后的版本，5.0之前使用UPDATE更新mysql.user表 RENAME USER xiaoming TO xiaoli; # 更改用户的密码，不指定用户名时，更新当前用户的密码 SET PASSWORD FOR xiaoli = Password('n3e p@$$w0rd'); # 删除用户 DROP USER xiaoli; ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:26:1","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"用户权限管理 管理用户权限，使用GRANT语句，GRANT语句要求至少提供如下信息： 要授予的权限 授予访问权限的库或表 要授予权限的用户名 GRANT的反操作的REVOKE，用来撤销权限。 # 新建用户没有访问权限，能登录数据库，但看不到任何数据，也不能操作任何数据 # 查看用户的权限 SHOW GRANTS FOR xiaoli; # 输出结果为 # +------------------------------------+ # | Grants for xiaoli@% | # +------------------------------------+ # | GRANT USAGE ON *.* TO 'xiaoli'@'%' | # +------------------------------------+ # 其中USAGE ON *.* 表示该用户对任何库和表没有任何权限(USAGE表示没有权限) # 'xiaoli'@'%' 表示 xiaoli用户可以从任意一个ip登录上来，'%'匹配任意ip或主机名 # 给xiaoli添加对orders表的查询和插入权限 GRANT SELECT, INSERT ON crashcourse.orders TO xiaoli; # 撤销xiaoli的插入权限 REVOKE INSERT ON crashcourse.orders TO xiaoli; 可以被授予或撤销的权限 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:26:2","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"维护数据库 ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:27:0","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["MySQL","SQL"],"content":"备份数据库 # 现在mysql命令行中执行，保证所有数据都写盘了 FLUSH TABLES; # 再用备份工具备份 mysqldump ","date":"2022-03-01","objectID":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:27:1","tags":["MySQL","SQL"],"title":"MySQL必知必会","uri":"/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["算法","树"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 树的遍历方式分为如下几种： 前序遍历 中序遍历 后序遍历 层序遍历 其中前序遍历可以求出树的深度，而后序遍历可以求出树的高度 树的遍历也可以借用辅助数据结构来完成： 栈 队列 栈适合模拟前中后序遍历，队列适合模拟层序遍历 ","date":"2022-02-21","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/:0:0","tags":["算法","树"],"title":"树的递归遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"categories":["算法","树"],"content":"前序遍历求深度 func maxDepth(root *TreeNode) int { if root == nil { return 0 } leftDepth := maxDepth(root.Left) rightDepth := maxDepth(root.Right) return max(leftDepth, rightDepth) + 1 } ","date":"2022-02-21","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/:0:1","tags":["算法","树"],"title":"树的递归遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"categories":["bit数组","bitmap"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 什么是bit数组？ bit数组通常为一个无符号数的数组，用每一个元素的每一个bit位来存储数据。 var bitSlice []uint64{0, 0, 0} bit数组 当我们存储数据，比如存储2时，对64取商和模为0和2，可知需要将2存储在bitSlice[0]的第2个bit位中，因此我们把bitSlice[0] \u0026 1\u003c\u003c2即可标识2被存储了 把2存储到bitSlice中 对于更大的数字，比如66，对64取商和模为1和2，可知需要将66存储在bitSlice[1]的第2个bit位中，因此我们把bitSlice[1] \u0026 1\u003c\u003c2即可标识66被存储了 把66存储到bitSlice中 bit数组有什么用？ bit数组可以使用很小的存储空间，存储更多的数据。对于uint64而言，如果直接存储，一个数要使用8byte空间，64个数则要64*8byte=512byte，而用bit来存，一个uint64的变量可以存储64个数，空间节省了64倍。 如果我们要对40亿条数据进行排序去重，但机器可用内存只有4G，要怎么做呢？ 我们先来计算一下，4,000,000,000对64取商和模为62,500,000和0，可知数组最大需要62,500,000个元素，而62,500,000 * 8byte = 500,000,000byte ≈ 480M 如果用[]uint32切片直接存储，则需要4,000,000,000 * 4byte = 16,000,000,000byte ≈ 15G 使用bit数组，存储时只会将数所在的bit位 置1，所以只要按顺序取出数据，就是排序去重后的数据。 bit数组应用 bit数组在很多地方都有应用，比如redis中的bitmap就是使用了bit数组的方式实现的。 bit数组实现 package bitmap import ( \"bytes\" \"fmt\" ) // 参考go语言圣经6.5章节 // UINTSIZE 判断当前机器是32位还是64位 // 64位机器^uint(0) = 64位全1，\u003e\u003e 63之后变成只有第一位为1，32 \u003c\u003c 1 = 64 // 32位机器\u003e\u003e 63之后全部位变为0，32 \u003c\u003c 0 = 32 const UINTSIZE = 32 \u003c\u003c (^uint(0) \u003e\u003e 63) // An IntSet is a set of small non-negative integers. // Its zero value represents the empty set. type IntSet struct { words []uint } // Has reports whether the set contains the non-negative value x. func (s *IntSet) Has(x int) bool { word, bit := x/UINTSIZE, uint(x%UINTSIZE) // words长度大于数据所在元素下标，且所在bit位不为0 return word \u003c len(s.words) \u0026\u0026 s.words[word]\u0026(1\u003c\u003cbit) != 0 } // Add adds the non-negative value x to the set. func (s *IntSet) Add(x int) { // 对要存储的数取商和模 word, bit := x/UINTSIZE, uint(x%UINTSIZE) // 如果words数组长度小于商，则扩容至能存下为止 for word \u003e= len(s.words) { s.words = append(s.words, 0) } // 将数存储到指定bit位 s.words[word] |= 1 \u003c\u003c bit } // UnionWith sets s to the union of s and t. // 设置s为s和t的并集 func (s *IntSet) UnionWith(t *IntSet) { for i, tword := range t.words { if i \u003c len(s.words) { // 取并集 // 101 | 010 = 111 s.words[i] |= tword } else { s.words = append(s.words, tword) } } } // IntersectWith sets s to the intersect of s and t // 设置s为s和t的交集 // 元素在s集合t集合均出现 func (s *IntSet) IntersectWith(t *IntSet) { // 如果s比t长，把s截取到t的长度 if len(s.words) \u003e len(t.words) { s.words = s.words[:len(t.words)] } // 如果t比s长，也只会比较s中有的部分 for i, tword := range t.words { if i \u003c len(s.words) { s.words[i] \u0026= tword } } } // DifferenceWith sets s to the difference of s and t // 设置s为s和t的差集 // 元素出现在s集合，未出现在t集合 func (s *IntSet) DifferenceWith(t *IntSet) { for i, tword := range t.words { if i \u003c len(s.words) { // ^: 异或运算，值不同则为1，相同为0 // B A // 100011010 ^ 110101001 = 010110011 // 010110011 \u0026 110101001 = 010100001 // 正好是A中有而B中没有的 s.words[i] \u0026= s.words[i] ^ tword } } } // SymmetricDifference sets s to the symmetric difference of s and t // 设置s为s和t的并查集 // 元素出现在s但没有出现在t，或者出现在t没有出现在s func (s *IntSet) SymmetricDifference(t *IntSet) { for i, tword := range t.words { if i \u003c len(s.words) { s.words[i] ^= tword } else { // 如果s元素个数小于t，则s要把t中多的部分补上 s.words = append(s.words, tword) } } } // String returns the set as a string of the form \"{1 2 3}\". // String方法，fmt.Printf()函数对实现了String方法的类型会直接调用其String()方法进行输出 func (s *IntSet) String() string { var buf bytes.Buffer buf.WriteByte('{') for i, word := range s.words { if word == 0 { continue } // 逐位遍历，如果为1，则将其写入缓冲区 for j := 0; j \u003c UINTSIZE; j++ { if word\u0026(1\u003c\u003cuint(j)) != 0 { if buf.Len() \u003e len(\"{\") { buf.WriteByte(' ') } // UINTSIZE*i+j还原数实际大小 // 比如2存储在[0]的第2个比特位 // UINTSIZE*0+2=2 fmt.Fprintf(\u0026buf, \"%d\", UINTSIZE*i+j) } } } buf.WriteByte('}') return buf.String() } // Len return the number of elements // 返回当前存储了多少个数 func (s *IntSet) Len() int { l := 0 for _, word := range s.words { if word == 0 { continue } for j := 0; j \u003c UINTSIZE; j++ { if word\u0026(1\u003c\u003cuint(j)) != 0 { l++ } } } return l } // Elems returns a slice containing the elements of the set func (s *IntSet) Elems() []int { res := make([]int, s.Len()) k := 0 for i, word := range s.words { if word == 0 { continue } for j := 0; j \u003c UINTSIZE; j++ { if word\u0026(1\u003c\u003cj) != 0 { res[k] = UINTSIZE*i + j k++ } } } return res } // Remove remove x from the set // 删除指定数 func (s *IntSet) Remove(x int","date":"2022-02-15","objectID":"/bit%E6%95%B0%E7%BB%84/:0:0","tags":["bit数组","bitmap"],"title":"Bit数组/bitmap","uri":"/bit%E6%95%B0%E7%BB%84/"},{"categories":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 什么是RK算法？ RK算法是一种字符串匹配算法。核心思想是将字符串映射为其字符集长度的数值(hash值)，将字符串比较变为数值比较，从而可以获得较好的性能。需要注意的是，当hash相同时，字符串任然有小概率不相同，hash不同则不可能相同。 对于文本串s和模式串p，我们计算p的hash值，然后再计算s中长度为len(p)的所有子串的hash值，对比他们是否相同，如果相同还需再比较一次字符串是否相同。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:0:0","tags":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"content":"什么是hash值？ 通过一个hash函数，将输入内容转化为数字，这个数字就是hash值。对于输入的内容相同，hash函数输出的值必须相同且应该尽量唯一。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:1:0","tags":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"content":"如何计算字符串的hash值？ 对于一串数字字符串\"1234\"，我们可以把它看做是10进制数，通过计算:'1'*10^(4-1) + '2'*10^(4-2) + '3'*10^(4-3)+'4'*10^(4-4)将它hash为1234(10^2表示10的2次方,4为字符串长度)。 对于小写字母字符串\"abcd\"，我们可以把它看做是26进制数，通过计算:'a'*26^(4-1) + 'b'*26^(4-2) + 'c'*26^(4-3) + 'd'*26^(4-4)将它hash为19010(‘a’=1,‘b’=2,‘c’=3,’d’=4)。 对于大小写字符混合字符串\"AbCd\"，我们可以把它看做是128进制(ASCII码128个字符)，通过计算:'A'*128^(4-1) + 'b'*128^(4-2) + 'C'*128^(4-3) + 'd'*128^(4-4)，将它们hash为137,929,188(‘A’=65,‘b’=98,‘C’=67,’d’=100)。 通过上述例子可以发现，我们可以把一串字符hash为它们字符集进制的数，那么我们是否可以用Unicode字符集作为进制数？不就可以表示所有字符了？答案是可以的。Unicode字符集所有字符个数为1114112个。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:2:0","tags":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"content":"如何使用hash进行字符串匹配？ 对于文本串s\"12345\"，我们希望知道模式串p\"45\"是否被s包含要如何做？ 以10进制为例。 首先对p进行hash，'4'*10+'5'=45，对s[0:2]进行hash，'1'*10+'2'=12，12不等于45，进行下一轮计算s[1:3]。下一轮计算难道又要'2'*10+'3'=23这样遍历s[1:3]的每一个字符吗？其实不用，我们可以把(12-10)*10+3，这意味着我们总共只需要遍历s串一次，而p串也是一次，这就是rk算法时间复杂度O(m+n)的原因。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:3:0","tags":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"content":"常用的字符串hash函数 BKDRHash ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:4:0","tags":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"content":"如何解决hash值相同但字符串不相同的情况 字符串hash难免出现hash值相同的情况，当相同时我们需要额外遍历一遍以确保相同。 Golang中的RK算法应用 // PrimeRK相当于我们上面提到的进制 const PrimeRK = 16777619 // HashStr returns the hash and the appropriate multiplicative // factor for use in Rabin-Karp algorithm. func HashStr(sep string) (uint32, uint32) { hash := uint32(0) for i := 0; i \u003c len(sep); i++ { // 将模式串hash为PrimeRK进制的数 hash = hash*PrimeRK + uint32(sep[i]) } // var pow, sq uint32 = 1, PrimeRK for i := len(sep); i \u003e 0; i \u003e\u003e= 1 { if i\u00261 != 0 { pow *= sq } sq *= sq } return hash, pow } // IndexRabinKarp uses the Rabin-Karp search algorithm to return the index of the // first occurrence of substr in s, or -1 if not present. func IndexRabinKarp(s, substr string) int { if len(s) \u003c len(substr) { return -1 } // Rabin-Karp search hashss, pow := HashStr(substr) n := len(substr) var h uint32 for i := 0; i \u003c n; i++ { h = h*PrimeRK + uint32(s[i]) } if h == hashss \u0026\u0026 s[:n] == substr { return 0 } for i := n; i \u003c len(s); { h *= PrimeRK h += uint32(s[i]) h -= pow * uint32(s[i-n]) i++ if h == hashss \u0026\u0026 s[i-n:i] == substr { return i - n } } return -1 } 参考：https://www.cnblogs.com/golove/p/3234673.html ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:5:0","tags":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 什么是KMP算法？ kmp算法是一种用于高效匹配字符串子串是否存在的算法，比如想知道文本串s中是否存在模式串p，就可以使用kmp算法。 如何实现KMP算法？ 实现kmp算法分两步 基于模式串初始化next数组 使用next数组加速字符串匹配 ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:0:0","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"什么是next数组？ next数组，又称为prefix数组、前缀表，其作用是记录给定字符串的所有子串中相等的前后缀长度。 ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:1:0","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"什么是前缀后缀？ 对于字符串cbccbcbccc，其前缀为包含首字符不包含尾字母的任意子串，其后缀为包含尾字符不包含首字符的任意子串。 前缀 c cb cbc cbcc ... cbccbcbcc 后缀 c cc ccc bccc ... bccbcbccc 对于字符串cbccbcbccc的每一个子串，我们求出它们的最长相等前后缀长度，其中子串c初始化为0。 最长相等前后缀 ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:1:1","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"next数组具体实现 求next数组的代码如下 func getNext(s string) []int { sLen := len(s) next := make([]int, sLen) next[0] = 0 j := 0 for i := 1; i \u003c sLen; i++ { // j要保证大于0，因为下面有取j-1作为数组下标的操作 for j \u003e 0 \u0026\u0026 s[i] != s[j] { // 回退前一位 j = next[j - 1] } if s[i] == s[j] { j++ } next[i] = j } return next } 求出next数组后，我们就可以利用它加速字符串的匹配。 当遇到不匹配时，就往前找一个最长相等前后缀，并移动模式串指针到他的后面，再尝试匹配 不匹配 匹配 当i==j==5时，文本串s[5] != 模式串p[5]，这时我们在next数组中往前找一位，next数组中记录了p[0:5]这个子串最长相等前后缀长度为2，意味着我们j指针只需要回退到下标为2的位置就可以继续匹配了，跳过了前面相同的部分 kmp具体实现 func kmp(s string, p string) int { m, n := len(s), len(p) next := make([]int, n) // 构建next数组 for i, j := 1, 0; i \u003c n; i++ { for j \u003e 0 \u0026\u0026 p[i] != p[j] { j = next[j-1] } if p[i] == p[j] { j++ } next[i] = j } // 根据next数组加速字符串匹配 for i, j := 0, 0; i \u003c m; i++ { for j \u003e 0 \u0026\u0026 s[i] != p[j] { j = next[j-1] } if s[i] == p[j] { j++ } if j == n { return i - n + 1 } } // 全部匹配失败，返回-1 return -1 } ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:2:0","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["分享"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 1 引言 本文用于记录日常使用hugo的优化建议，阅读时长10分钟。 适用于以下人员： 已经搭建好Hugo博客 希望使用图床功能 希望自己的博客能在百度和谷歌上搜索到 本文将从以下几点进行优化： 使用GitHub作为博文的图床 让百度和谷歌收录站点 2 使用GitHub作为图床储存图片 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:0:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"什么是图床 图床是一个专门存放图片的服务器，使用图床可以让我们的博客直接从网上获取图片，而无需管理本地图片路径，让我们获得更好的博文书写体验。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:1:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"优雅的使用图床 方案为：VsCode+PicGo插件+GitHub。 VsCode用于书写博客文章，PicGo插件用于快速生成网络图片链接，GitHub作为图片服务器存放图片。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"操作步骤如下： ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:1","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"1.安装VsCode 点击VsCode即可前往下载界面。安装十分简单，不再赘述。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:2","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"2.下载PicGo插件 打开VsCode，在左侧的扩展管理中输入PicGo下载插件。 下载PicGo插件 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:3","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"3.创建GitHub图床仓库 创建一个名字为\u003c你github账户名\u003e.github.io的仓库，我这里的是博客使用的仓库，并使用images目录作为图片存放的目录。 创建GitHub图床仓库 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:4","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"4.生成令牌(Token) 接下来需要生成令牌，让PicGo插件能通过令牌免密上传图片到图床目录。 生成令牌 生成令牌 生成令牌 生成令牌 Token生成之后要及时复制，之后就无法复制了。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:5","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"5.配置PicGo插件 打开VsCode上的PicGo插件，点击小齿轮进行配置。 在配置中找到GitHub的相关配置项，从上到下分别配置：图床目录(必须加上/)，github仓库，Token令牌。 配置PicGo插件 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:6","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"6.测试图床 VsCode上的PicGo插件配置好之后，使用Ctrl+Alt+u可以把剪切版中的图片上传到图床中，并且会在当前VsCode打开的文件中生产一个图片的网络链接。同时我们看GitHub上的images目录时，会发现图片被自动上传了。 测试图床 2 在百度和谷歌上添加网站 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:7","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"为什么要添加网站 在百度和谷歌添加博客的网站之后，就可以通过百度和谷歌的搜索引擎找到自己的博客。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:3:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"收录和站点管理 站点收录：让百度或谷歌知道有这个站点的存在，添加之后需要等1~7天（不同搜索引擎不一样）的时间后才能找到自己的博客。 站点管理：向百度或谷歌证明某个站点是属于你的，即你是网站的管理员。可以通过如下方式进行证明： 在网站首页中增加一个校验值标签 在网页目录中增加一个校验页面 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:4:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"添加收录 测试网址是否被收录：site:hts0000.github.io。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:5:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"百度 检查收录 添加之后百度大概需要一星期的时间进行收录。 检查收录 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:5:1","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"谷歌 检查收录 添加之后谷歌大概需要1~2天的时间来收录网站。 检查收录 收录成功后在谷歌中搜索：site:hts0000.github.io，就可以发现我们的网站可以通过浏览器搜索到了。 检查收录 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:5:2","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"站点管理 通过百度账号和谷歌账号，可以绑定网站，通过百度和谷歌的统计功能，可以看到网站的访问次数和访问情况。 让账号和网站绑定，需要向百度和谷歌证明你是网站的管理员，证明的方法有很多种，这次选择校验页面的方式进行验证。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:6:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"百度 首先在账号中添加网站 站点管理 站点管理 把下载好的校验页面放到网页目录下，向百度证明你是网站的管理员。 站点管理 校验成功后可以在站点管理中看到刚刚添加的站点。 站点管理 点击站点可以看到百度为我们统计的站点信息，如点击率搜索量等等。 站点管理 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:6:1","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"谷歌 谷歌的操作与百度类似，也是在网页的目录下添加校验页面，向谷歌证明你是网站的管理员。 站点管理 添加完成之后也可以通过谷歌统计的站点信息查看网站的点击量等等。 站点管理 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:6:2","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 1 引言 本文用于记录基于HUGO搭建个人博客的步骤和注意事项，阅读时长大概30分钟。 适用于以下人员： 想搭建博客 想了解hugo 闲着没事 2 准备阶段 在开始搭建博客前，希望你已经准备好以下工具，以便能快速的跟上本篇文章。 Git Bash Notepad++ VSCode 文章将会从如下三个大步骤进行展开。 基于HUGO的本地博客 定制本地博客 使用GitHub展示博客内容 3 基于HUGO的本地博客 想要在本地搭建一个基于HUGO的博客，大致有如下三步。 安装hugo 获取一个hugo主题 启动hugo 第一步，安装hugo。 前往hugo的github仓库获取对应操作系统的hugo执行程序。 完成之后打开cmd终端，输入hugo version，如能正确显示hugo的版本即为安装成功。 hugo安装成功 安装成功后在cmd终端执行如下命令，在D盘生成hugo博客站点MyBlog。 hugo new site D:\\MyBlog 第二步，获取HUGO主题。 hugo的主题是博客的门面，博客的风格和样式都基于主题。如果有前端编程的能力，也可以自行设计属于自己的主题，或者前往hugo主题商店下载现成的主题。这里以LoveIt 主题为例。 点击Download前往LoveIt的github仓库进行下载。 下载LoveIt主题 下载LoveIt主题 将下载好的压缩包解压到D:\\MyBlog\\themes目录下，并将目录重命名为LoveIt。 将D:\\MyBlog\\themes\\LoveIt\\exampleSite\\zh目录下的所有文件和D:\\MyBlog\\themes\\LoveIt\\exampleSite\\static目录复制到D:\\MyBlog\\目录下。 zh目录：LoveIt主题的中文配置及界面内容 zh\\config.toml：LoveIt主题的集中配置文件 zh\\content目录：LoveIt主题的默认页面内容 static目录：LoveIt主题的图包 使用Notepad++或其他文本编辑工具打开config.toml文件，将 staticDir = [\"../static\", “../../assets/others”] 改成staticDir = [\"/static\", “../assets/others”]。 第三步，启动本地博客。 在cmd终端执行如下命令，启动监听。 hugo server -D --config D:\\MyBlog\\config.toml 在浏览器访问URL:localhost:1313，可以查看本地博客。 下载LoveIt主题 4 定制本地博客 定制一个充满个人元素的博客大概分为如下三步。 个性化的博客标题和个人介绍 个性化的头像和图标 个性化的博客内容 第一步，定制个人的博客标题和介绍。 关于如何修改博客的标题等，D:\\MyBlog\\config.toml文件内作者有非常完善的注释，大家多修改多尝试（先备份），这里不细讲。 第二步，个性化头像和图标。 点击Favicon Generator，打开Select your Favicon image上传一张你喜欢的图片。 Favicon Generator生成图标 上传之后成功之后来到页面最下方点击Generate your Favicons and HTML code，Favicon Generator会自动分辨率生成符合一系列PC和移动终端的图标。 Favicon Generator生成图标 点击Favicon package下载生成好的图标包。 Favicon Generator下载图标 将下载好的图标包解压，把里面的文件全部复制到D:\\MyBlog\\static\\目录下。 如果想要替换主页的头像图标，需要替换D:\\MyBlog\\static\\images\\avatar.png，推荐分辨率为528*560。 最后整体效果如下图所示。 博客展示 第三步，个性化的博客内容。 博客的最终目的是展示内容，hugo能非常方便的根据文章的设定生成标签(tags)和分类(categories)。下面教大家如何设置文章的模板。 设置博客文章的模板 LoveIt主题中作者已经写好了一个文章模板，这里直接套用这个模板进行修改即可。 首先将D:\\MyBlog\\themes\\LoveIt\\archetypesdefault.md文件复制到D:\\MyBlog\\archetypes目录下，使用VsCode等markdown编辑工具打开。 模板文件 生成一篇博客文章 打开cmd终端，执行如下命令，根据文章模板生成第一篇文章。 # 进入D盘 D: # 进入MyBlog目录 cd MyBlog # 生成博客文章，文章会生成在content/posts目录下 hugo new posts/我的第一篇博客.md # 启动hugo，开启监听 hugo server -D --config D:\\MyBlog\\config.toml 再次访问URL:localhost:1313即可看到刚刚添加的文章。 5 用GitHub展示博客文章 让GitHub仓库展示博客页面，大致有如下四步。 创建一个GitHub账号 创建一个同名仓库 hugo build生成页面 推送到GitHub远程仓库 第一步，创建一个GitHub账号。 网上有很多教程，不再赘述。 第二步，创建一个同名仓库 网上也有很多教程，只强调一点，仓库名称为username.github.io。如：你的用户名叫zhangsan000，则你的仓库名必须为zhangsan000.github.io。 GitHub仓库 第三步，hugo生成静态页面。 打开cmd终端，执行如下命令，生成静态页面。 # 进入D盘 D: # 进入MyBlog目录 cd MyBlog # 生成静态页面 hugo hugo生成静态页面之后在MyBlog目录下会生成public目录存放静态页面。 将静态页面推送到GitHub 打开cmd终端，将GitHub仓库clone到本地。 # 查看git是否正常安装，能正常显示git版本即为安装正确 git version D: cd MyBlog/pubilc # 将你的仓库clone下来 git clone repoURL 然后将所有文件移动到clone下来的仓库目录下，再次打开cmd终端，输入如下命令，将静态页面推送到远程仓库。 D: # 进入git本地仓库 cd MyBlog\\public\\\u003c你的仓库目录\u003e # 将所有的文件添加到本地暂存区 git add . # 提交暂存区的内容 git commit -m 'init MyBlog' # 将本地提交推送到远程 git push 在GitHub上查看提交。 GitHub仓库 最后在浏览器上访问URL:\u003c仓库名称\u003e.github.io即可通过网络访问到静态页面。 GitHub仓库 ","date":"2020-02-15","objectID":"/%E5%9F%BA%E4%BA%8Ehugo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["hugo","分享"],"title":"基于Hugo快速搭建个人博客","uri":"/%E5%9F%BA%E4%BA%8Ehugo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"Hts0000的个人博客 主要分享如下内容 Linux运维 网络基础 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About LoveIt","uri":"/about/"}]