[{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 搜索 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:0:0","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"BFS 使用数据结构：queue。 使用空间：因要存储每一层所有节点，因此使用的空间是O(2^h)指数级，h是树的高度。 BFS搜索具有最短路的性质。BFS搜索两个点的距离，一定是最短的。 BFS是树中的层序遍历。 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:1:0","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"代码模板 走迷宫问题 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 110 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) // 存储迷宫 maze [N][N]int // 存储距离 dist [N][N]int n, m int ) type pair struct { first int second int } func bfs(start pair) int { queue := make([]pair, 1) queue[0] = start dist[0][0] = 0 // 上右下左 四个方向 var dx = [4]int{-1, 0, 1, 0} var dy = [4]int{0, 1, 0, -1} for len(queue) \u003e 0 { t := queue[0] queue = queue[1:] // 枚举四个方向 for j := 0; j \u003c 4; j++ { x := t.first + dx[j] y := t.second + dy[j] // 将合法的位置加入队列中 if x \u003e= 0 \u0026\u0026 x \u003c n \u0026\u0026 y \u003e= 0 \u0026\u0026 y \u003c m \u0026\u0026 maze[x][y] == 0 \u0026\u0026 dist[x][y] == -1 { queue = append(queue, pair{x, y}) dist[x][y] = dist[t.first][t.second] + 1 } } } return dist[n-1][m-1] } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 0; i \u003c n; i++ { for j := 0; j \u003c m; j++ { fmt.Fscan(in, \u0026maze[i][j]) // 没走过的点初始化为-1 dist[i][j] = -1 } } fmt.Fprintln(out, bfs(pair{0, 0})) } ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:1:1","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"经典模板题 844. 走迷宫 845. 八数码 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:1:2","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"DFS 使用数据结构：stack。 使用空间：只需要存储当前路径上的所有节点，因此使用的空间是O(h)，h是树的高度。 DFS的一些概念： DFS搜索不具有最短路性质。 DFS是树的中序遍历(左中右)。 DFS最重要的是画出递归树。 DFS两个重要概念——回溯和剪枝。 回溯的难点在于递归过程中的去重问题。常见去重有： 同层去重 子树去重 路径去重 深度优先搜索可以求出某个节点为根的子树上节点的数量。 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:2:0","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"代码模板 N皇后问题 package main import ( \"fmt\" \"bufio\" \"os\" ) var in = bufio.NewReader(os.Stdin) var out = bufio.NewWriter(os.Stdout) const N int = 10 // 棋盘 var chessbord [N][N]byte var ( // 记录列是否有皇后 col [N]bool // 记录45度对角是否有皇后，有n行n列，因此需要开2*N的空间 udg [2*N]bool // 记录135度对角是否有皇后，有n行n列，因此需要开2*N的空间 dg [2*N]bool ) var n int func dfs(row int) { // 找到了一种解决方案，输出棋盘 if row == n { for i := 0; i \u003c n; i++ { for j := 0; j \u003c n; j++ { fmt.Fprintf(out, \"%c\", chessbord[i][j]) } fmt.Fprintln(out) } fmt.Fprintln(out) return } // 枚举每一列，能放下皇后的进入下一行 for c := 0; c \u003c n; c++ { // 如果这一列、135度对角和45度对角上都没有皇后，就在c列放下皇后，并进入下一行 // row - c + n 和 row + c 如何理解？每条对角线可以看成是一个 y = x + b 或 y = -x + b 的函数 // 唯一的 x和y 可以确认唯一的 b，我们可以用这个 b 来代表y行x列的对角线 // 135度对角线y = x + b，45度对角线y = -x + b // 变形后135度对角线 b = y - x，45度对角线b = y + x // 因为 y - x 可能为负，我们可以加上一个n，将整体结果映射到0~n这个区间 if !col[c] \u0026\u0026 !udg[row - c + n] \u0026\u0026 !dg[row + c] { // 放下皇后 chessbord[row][c] = 'Q' // 标记 c 列有皇后；标记 row 行 -c 列有皇后；标记 row 行 c 列有皇后 col[c] = true; udg[row - c + n] = true; dg[row + c] = true // 进入下一行 dfs(row + 1) // 回溯状态，为下一列枚举提供可能 chessbord[row][c] = '.' col[c] = false; udg[row - c + n] = false; dg[row + c] = false } } } func main() { defer out.Flush() fmt.Fscan(in, \u0026n) // 初始化棋盘 for i := 0; i \u003c n; i++ { for j := 0; j \u003c n; j++ { chessbord[i][j] = '.' } } dfs(0) } ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:2:1","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"经典模板题 842. 排列数字 843. n-皇后问题 51. N 皇后 图论 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:2:2","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"树与图的存储 树是一种特殊的图，因此我们只讨论图即可。 图的形式 图分为有向图和无向图，无向图是一种特殊的有向图，其两个顶点有两条相互连接的边，因此在讨论图的遍历时，只讨论有向图即可。 图的存储形式 图的存储形式有： 邻接矩阵 邻接表 邻接矩阵是一个N*N的二维数组。x行y列存储值为1，表示x顶点与y顶点有一条边。邻接矩阵使用比较少，因为他需要O(n^2)的存储空间，比较适合存储稠密图。 邻接表是一个元素是链表的数组，下标x存储的是一条链表，链表所有节点是x顶点能到达的所有其他顶点。 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:3:0","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"图的遍历 深度优先搜索遍历 深度有限搜索可以方便的获取子树的节点数量。 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:4:0","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"代码模板 const N int = 100010 var ( // 邻接表的存储方式 h [N]int e, ne [2*N]int idx int // 记录哪些点被访问过了 st [N]bool ) // 为 a，b 点建立连接 func add(a, b int) { e[idx] = b ne[idx] = h[a] h[a] = idx idx++ } // 深度有限搜索遍历图 func dfs(u int) { st[u] = true for i := h[u]; i != -1; i = ne[i] { j := e[i] if !st[j] { dfs(j) } } } ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:4:1","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"经典模板题 846. 树的重心 广度优先搜索 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:4:2","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"代码模板 const N int = 100010 var ( // 存储邻接表 h, e, ne [N]int idx int // 存储点是否被访问过 st [N]bool ) func add(a, b int) { e[idx] = b ne[idx] = h[a] h[a] = idx idx++ } func bfs() { queue := make([]int, 1, N) queue[0] = 1 st[1] = true for len(queue) \u003e 0 { t := queue[0] queue = queue[1:] // 当前点的邻接表 for i := h[t]; i != -1; i = ne[i] { j := e[i] if !st[j] { st[j] = true queue = append(queue, j) } } } } ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:4:3","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"经典模板题 847. 图中点的层次 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:4:4","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"拓扑排序 拓扑排序是指，将有向图中的所有顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素。 拓扑排序是针对有向图而言，无向图没有拓扑序列。 拓扑排序的一个典型应用是——有前导课程的课程表，所有后面的课程指向前面的先导课程。 一个有环图不存在拓扑排序，因为必定有一个前面的节点指向后面的节点。反之，一个有向无环图必定存在拓扑排序，因此有向无环图又称为拓扑图。 图的入度与出度： 入度：有多少条边指向该节点 出度：该节点有多少条边出去 求拓扑排序的步骤 寻找入度为0的点入队，入度为0意味着没有其他节点指向它。 取出队头元素，将队头元素所有的出边删掉 将出边指向节点中，入度为0的点入队 拓扑图必定存在一个入度为0的点。如果存在环，那么将不会有元素入队，循环结束。 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:5:0","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 1e5 + 10 var ( in = bufio.NewReader(os.Stdin) out = bufio.NewWriter(os.Stdout) h, e, ne [N]int idx int // d 存储所有节点的入度 queue, d [N]int hh, tt int = 0, -1 n, m int ) func add(a, b int) { e[idx] = b ne[idx] = h[a] h[a] = idx idx++ } func topsort() bool { // 先将所有入度为0的点入队 for i := 1; i \u003c= n; i++ { if d[i] == 0 { tt++ queue[tt] = i } } // 取出队头元素，将其所有出边删除 for hh \u003c= tt { t := queue[hh] hh++ for i := h[t]; i != -1; i = ne[i] { j := e[i] // 将入度为0的点入队 d[j]-- if d[j] == 0 { tt++ queue[tt] = j } } } // 如果是拓扑图，那么所有点都会入队 return tt == n - 1 } func main() { defer out.Flush() fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { h[i] = -1 } var a, b int for i := 1; i \u003c= m; i++ { fmt.Fscan(in, \u0026a, \u0026b) add(a, b) d[b]++ } if topsort() { for i := 0; i \u003c hh; i++ { fmt.Fprintf(out, \"%d \", queue[i]) fmt.Fprintln(out) } } else { fmt.Fprintln(out, \"-1\") } } ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:5:1","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"content":"经典模板题 848. 有向图的拓扑序列 ","date":"2022-10-20","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/:5:2","tags":["算法","算法整理","搜索算法","BFS","DFS","广度优先搜索","深度优先搜索","图论","最短路","拓扑排序"],"title":"基础算法整理(七)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%83/"},{"categories":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com Hash表/哈希表 Hash表通过Hash函数映射的方式，将一个稀疏的集合存储到一个紧凑的集合中。比如一个集合的数据范围是1~10^9次方，但里面的数只有10^5个，我们就可以通过一个Hash函数(通常是取模)的方式将集合中的数映射到一个10^5的集合中，减少存储空间的浪费。 但是将一个大集合映射到小集合，必然造成信息的损失，表现到Hash表中就是Hash冲突。通过Hash后，大集合中的某些数必定被映射到了同一个点上。因此我们无法确认该点是否存在某些值，因为有多个值同时被映射过来了。 解决Hash冲突的经典解决方式(都需要额外判断)： 拉链法 开放寻址法 拉链法 每一个点存储的是一个链式结构，冲突时将新值链接到前面或后面。确认是否存在该值时，可以依次判断链上的每一个节点。 开放寻址法 如果该点存在冲突，则往下或往上寻找空的位置，将新值写入。确认是否存在该值时，先找到映射的位置，然后向上或向下依次判断每一个值。 ","date":"2022-10-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/:0:0","tags":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"title":"基础算法整理(六)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/"},{"categories":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"content":"代码模板 拉链法 package main import ( \"fmt\" \"bufio\" \"os\" ) // 拉链法 const N int = 100003 var h, e, ne [N]int var idx int func insert(x int) { // x 为负数时 % N 结果为负数，加上 N 变为正数，再 % N k := (x % N + N) % N e[idx] = x ne[idx] = h[k] h[k] = idx idx++ } func query(x int) bool { k := (x % N + N) % N for i := h[k]; i != -1; i = ne[i] { if e[i] == x { return true } } return false } func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() // 将h所有槽位初始化为-1，表示空节点 for i := 0; i \u003c N; i++ { h[i] = -1 } var n int fmt.Fscan(in, \u0026n) for ; n \u003e 0; n-- { var op string var x int fmt.Fscan(in, \u0026op, \u0026x) if op == \"I\" { insert(x) } else { if query(x) { fmt.Fprintln(out, \"Yes\") } else { fmt.Fprintln(out, \"No\") } } } } 开放寻址法 package main import ( \"fmt\" \"bufio\" \"os\" ) // 开放寻址法通常开数据范围2~3倍的空间 const N int = 200003 // 用一个不存在于数据范围内的数来表示该点没有值 const null int = 0x3f3f3f3f var h [N]int // 在 h 中寻找 x 应该插入的位置 func find(x int) int { k := (x % N + N) % N // 在h中找一个x能插入的位置，如果x已经插入过了，返回插入的位置 for h[k] != null \u0026\u0026 h[k] != x { k++ // 如果到最后了，尝试从头开始查找插入的问题 if k == N { k = 0 } } return k } func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() // 初始化将所有点标记为空 for i := 0; i \u003c N; i++ { h[i] = null } var n int fmt.Fscan(in, \u0026n) for ; n \u003e 0; n-- { var op string var x int fmt.Fscan(in, \u0026op, \u0026x) k := find(x) if op == \"I\" { h[k] = x } else { if h[k] != null { fmt.Fprintln(out, \"Yes\") } else { fmt.Fprintln(out, \"No\") } } } } ","date":"2022-10-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/:0:1","tags":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"title":"基础算法整理(六)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/"},{"categories":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"content":"经典模板题 840. 模拟散列表 字符串Hash 字符串hash是一种快速判断字符串是否相等的方法。Golang中strings.Index等库均用到了字符串Hash——RK算法。详细可以看Golang中的字符串匹配——RK算法。 ","date":"2022-10-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/:0:2","tags":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"title":"基础算法整理(六)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/"},{"categories":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 100010 // P表示P进制，题目提到字符串中只包含大小写英文字母和数字，因此128可以完全存下 // ASCII码总共128，131是大于128的最小素数，用素数是因为可以有效的降低冲突的概率 // 这里还有个细节是用到了uint64 // 当字符串足够长时，产生的hash值可能会非常大，int可能会存不下，但是uint64也不一定存的下 // 经验告诉我们，当P取131或13331时，hash值mod一个2^64，在99.99%的情况下不会发生冲突 // 因此用uint64还有个好处，当uint64发生溢出时，就相当于mod了2^64，可以减少许多次计算 // 因此这个字符串hash方法，是假定不会发生冲突的 const P uint64 = 131 // h存储的是s所有前缀的hash值，预处理好之后，求某一段的hash就只需要O(1)的时间 // p存储的是P^i次方数，方便O(1)时间计算hash var h, p [N]uint64 func get(l, r int) uint64 { return h[r] - h[l-1] * p[r-l+1] } func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n, m int fmt.Fscan(in, \u0026n, \u0026m) var s string fmt.Fscan(in, \u0026s) s = \" \" + s // 预处理前缀hash和P进制每一位数 p[0] = 1 for i := 1; i \u003c= n; i++ { p[i] = p[i-1] * P h[i] = h[i-1] * P + uint64(s[i]) } for ; m \u003e 0; m-- { var l1, r1, l2, r2 int fmt.Fscan(in, \u0026l1, \u0026r1, \u0026l2, \u0026r2) // 因为hash冲突极大概率不存在，因此判断hash值相同就认为字符串相同 if get(l1, r1) == get(l2, r2) { fmt.Fprintln(out, \"Yes\") } else { fmt.Fprintln(out, \"No\") } } } ","date":"2022-10-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/:0:3","tags":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"title":"基础算法整理(六)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/"},{"categories":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"content":"经典模板题 841. 字符串哈希 求大于x的最小素数 ","date":"2022-10-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/:0:4","tags":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"title":"基础算法整理(六)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/"},{"categories":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"content":"代码模板 // 快速求比128数大的最小素数 for i := 128; ; i++ { flag := true for j := 2; j * j \u003c= i; j++ { if i % j == 0 { flag = false break } } if flag { fmt.Fprintln(out, i) break } } ","date":"2022-10-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/:0:5","tags":["算法","算法整理","hash","哈希表","字符串hash","RK算法"],"title":"基础算法整理(六)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%85%AD/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com Trie树/字典树 Trie是一种高效存储和查找字符串集合的数据结构。其存储形式如下图所示： 红色星号标记了存在以该词结尾的单词。 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:0:0","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"代码模板 package main import ( \"bufio\" \"fmt\" \"os\" ) const N int = 1e5 + 10 var ( // 指示son存储到哪了 idx int // 第一个维度表示 节点i // 第二个维度表示 节点i的子节点的下标 // 比如先存储了一个 只有a字母 长度为20的字符串，那么idx值为20 // 表示已经使用了20个节点 // 再存储新的字符串，将会从idx开始 // son[0][26]表示头结点的子节点 son [N][26]int // 以某个节点结尾的单词数量 cnt [N]int ) func insert(s string) { p := 0 for i := 0; i \u003c len(s); i++ { u := s[i] - 'a' if son[p][u] == 0 { // 如果没有存储过该字符，则新开一个节点存储，idx+1的含义 son[p][u] = idx + 1 idx++ } p = son[p][u] } cnt[p]++ // 以节点p结尾的单词数量 } func query(s string) int { p := 0 for i := 0; i \u003c len(s); i++ { u := s[i] - 'a' if son[p][u] == 0 { return 0 } p = son[p][u] } return cnt[p] } func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n int fmt.Scan(\u0026n) for ; n \u003e 0; n-- { var op, s string fmt.Fscan(in, \u0026op, \u0026s) if op == \"I\" { insert(s) } else { fmt.Fprintln(out, query(s)) } } } ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:0:1","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"经典模板题 835. Trie字符串统计 208. 实现 Trie (前缀树) 143. 最大异或对 421. 数组中两个数的最大异或值 并查集 并查集通常用来： 将两个集合合并 询问两个元素是否在一个集合当中 并查集能在近乎O(1)的时间内完成这两个操作。 并查集是树形的数据结构，用数根来表示这个集合的编号，其余每个节点存储它的父节点是谁 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:0:2","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"朴素并查集 问题1：如何判断树根？ 集合中只有树根的父节点等于自身，因此判断是否与父节点相同即可：if x == p[x] 问题2：如何求一个元素属于那个集合？ 从num不断地向上走，一直走到树根：for x := x; x != p[x]; x = p[x] {} 问题3：如何合并两个集合？ 假设有两个集合分别用编号x和y表示，则将集合x合并到y的操作为，将x的根节点指向y：p[x] = y 可以发现，并查集的时间复杂度集中在问题2上。并查集的路径压缩降低了这个时间复杂度。 有了路径压缩后，并查集查询两个元素是否在同一个集合中的时间复杂度，可以近乎看成O(1)。 在一次求元素属于那个集合的操作中，将查找路径上的所有节点直接指向根节点，本质上是降低了树的高度。 在代码实现时，一般会直接带上路径压缩。 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:1:0","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"代码模板 var p [N]int func init() { // 一开始每个元素都是一个单独的集合，自己就是自己的祖先节点 for i := 1; i \u003c= n; i++ { p[i] = i } } // 核心实现，寻找 x 的祖先节点，并且加上路径压缩 func find(x int) int { // 如果x的根节点不是，则递归寻找根节点， // 并将这条路径上的节点的父节点都赋值为根节点 if p[x] != x { p[x] = find(p[x]) } return p[x] } ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:1:1","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"经典模板题 836. 合并集合 剑指 Offer II 118. 多余的边 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:1:2","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"维护每个集合数量 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:2:0","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"代码模板 // 额外使用一个cnt，来维护这个集合的数量 var p, cnt [N]int func init() { // 一开始每个元素都是一个单独的集合，自己就是自己的祖先节点 for i := 1; i \u003c= n; i++ { p[i] = i // 初始化每个集合数量为1 cnt[i] = 1 } } // 核心实现，寻找 x 的祖先节点，并且加上路径压缩 func find(x int) int { // 如果x的根节点不是，则递归寻找根节点， // 并将这条路径上的节点的父节点都赋值为根节点 if p[x] != x { p[x] = find(p[x]) } return p[x] } // 将b加入a集合，并且更新a集合数量 func merge(a, b int) { a, b = find(a), find(b) if a != b { p[b] = a cnt[a] += cnt[b] } } ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:2:1","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"经典模板题 837. 连通块中点的数量 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:2:2","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"记录偏移量 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:3:0","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"代码模板 const N int = 50010 var p, d [N]int func find(x int) int { if x != p[x] { t := find(p[x]) d[x] += d[p[x]] p[x] = t } return p[x] } ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:3:1","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"经典模板题 240. 食物链 堆 堆是一颗完全二叉树，根据节点与其左右节点的性质，可以分为大根堆和小根堆。对于每一个节点，都小于其左右节点的堆称为小根堆，对于每一个节点，都大于其左右节点的堆称为大根堆。 堆通常需要支持如下操作： 插入一个数 求集合当中的最值 删除最值 删除任意一个元素(不常用) 修改任意一个元素(不常用) 要求执行完这些操作之后，集合仍然是一个堆。 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:3:2","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"实现细节 我们使用一维数组来存储集合，将下标为1的位置定义为根节点，那么每个节点i与其左右节点的关系为：$左节点 = 2i，右节点 = 2i+1$。 我们定义两种操作：down(u int)和up(u int)，分别从u向下调整堆，和从u向上调整堆。 down会判断u是否小于其左右节点(对于小根堆而言)，如果不是，则交换u与最小者，再递归调整最小者。 up会判断u是否小于其父节点(对于小根堆而言)，如果不是，则交换u与其父节点，再循环调整其父节点。 我们可以组合down和up操作，来实现上述需要支持的5个操作。 堆的初始化，我们可以不断的将数插到最后，然后向上调整堆，这样的时间复杂度是O(nlogn)的。有另一种方法是O(n)的。 对于一个数组，我们从n/2 ~ 1执行down操作，$n/2$其实就是倒数第二层，这一层的节点数量为$n/4$，只需要往下down一次，因此时间复杂度是$(n/4)*1$。往上每一层的节点数量为$n/8$，需要往下down两次，时间复杂度是$(n/8)*2$，以此类推，那么总的时间复杂度就是他们的总和： $$sum((n/4)*1, (n/8)*2, (n/16)*3, …) = n$$ go语言中heap.Init函数也是采用这个实现。 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:3:3","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"代码模板 // 堆 var h [N]int // 堆存储长度 var size int // 堆初始化 O(n) func initHeap() { for i := n / 2; i \u003e 0; i-- { down(i) } } // 从u开始向上调整堆 O(logn) func up(u int) { for u / 2 \u003e 0 \u0026\u0026 h[u] \u003c h[u / 2] { h[u], h[u / 2] = h[u / 2], h[u] u /= 2 } } // 从u开始向下调整堆 O(logn) func down(u int) { t := u // 拿到 u 及左右儿子中的最小值 if u * 2 \u003c= size \u0026\u0026 h[u * 2] \u003c h[t] { t = u * 2 } if u * 2 + 1 \u003c= size \u0026\u0026 h[u * 2 + 1] \u003c h[t] { t = u * 2 + 1 } // 如果 u 已经是 三者中最小，则不需要调整堆 // 否则交换 u 与最小者，递归调整堆 if u != t { h[u], h[t] = h[t], h[u] down(t) } } ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:3:4","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"content":"经典模板题 838. 堆排序 839. 模拟堆 912. 排序数组 ","date":"2022-10-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/:3:5","tags":["算法","算法整理","Trie","字典树","并查集","heap","堆"],"title":"基础算法整理(五)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%94/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 链表与邻接表 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:0:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"单链表 链表通常使用结构体加指针的方式来构建： type Node struct { Val int Next *Node } 但是这种方式创建链表很慢，笔试算法中链表长度可能达到10^5甚至10^6级别，只是初始化链表就超时了。所以笔试算法通常使用数组来模拟链表，用数组模拟链表也被称为静态链表。 用数组模拟链表： // 存储节点i的值 var e = [N]int{0, 1, 2, 3, 4, 5} // 存储节点i的next，这里存储的实际是数组下标，-1表示nil var ne = [N]int{3, 1, 2, 5, 4, -1} // [0]-\u003e[3]-\u003e[1]-\u003e[2]-\u003e[5]-\u003e[4]-\u003enil 单链表最大的用途是用来写邻接表，存储树和图。 双链表通常用于优化某些问题。 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:1:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N = 100010 // 指向头节点，指示链表长度 var head, length int var e, ne [N]int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var m int fmt.Fscan(in, \u0026m) initLinkList() for ; m \u003e 0; m-- { var op string var k, x int fmt.Fscan(in, \u0026op) if op == \"H\" { fmt.Fscan(in, \u0026x) addToHead(x) } else if op == \"D\"{ fmt.Fscan(in, \u0026k) // 如果删除的节点是头结点，直接将head指向下一位 if k == 0 { head = ne[head] } else { remove(k - 1) } } else { fmt.Fscan(in, \u0026k, \u0026x) add(k - 1, x) } } for i := head; i != -1; i = ne[i] { fmt.Fprintf(out, \"%d \", e[i]) } } // 初始化链表 func initLinkList() { head = -1 length = 0 } // 将x插到头结点 func addToHead(x int) { e[length] = x ne[length] = head head = length length++ } // 将x插到下标是k的后面 func add(k, x int) { e[length] = x ne[length] = ne[k] ne[k] = length length++ } // 删除下标k后面的一个节点 func remove(k int) { ne[k] = ne[ne[k]] } ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:1:1","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"经典模板题 826. 单链表 707. 设计链表 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:1:2","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"双链表 双链表比单链表多存储了一个前节点指针，能够在O(1)时间找到上一个节点。 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:2:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N = 100010 // l存放i节点的左节点；r存放i节点的右节点 var e, l, r [N]int var length int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() initDuLinkNode() var m int fmt.Fscan(in, \u0026m) for ; m \u003e 0; m-- { var op string fmt.Fscan(in, \u0026op) var k, x int if op == \"R\" { fmt.Fscan(in, \u0026x) // 1表示最右端点 // l[1]表示最右端点的左侧 add(l[1], x) } else if op == \"L\" { fmt.Fscan(in, \u0026x) // 0表示最左端点 add(0, x) } else if op == \"D\" { fmt.Fscan(in, \u0026k) // 删除第k个插入的数 // 因为预先插入了两个左右端点，所以需+2 // 又因为下标从0开始，插入数从1开始，所以-1 remove(k + 1) } else if op == \"IR\" { fmt.Fscan(in, \u0026k, \u0026x) // 在第k个插入数的右侧插入x add(k + 1, x) } else if op == \"IL\" { fmt.Fscan(in, \u0026k, \u0026x) // 在第k个插入数的左侧插入x // 等价于在 第k个插入数的左节点的右侧 插入x add(l[k + 1], x) } } for i := r[0]; i != 1; i = r[i] { fmt.Fprintf(out, \"%d \", e[i]) } } func initDuLinkNode() { // 定义第一个和第二个节点为左右端点 r[0] = 1 l[1] = 0 length = 2 } // 在下标k的右边插入x func add(k, x int) { e[length] = x r[length] = r[k] l[length] = k l[r[k]] = length r[k] = length length++ } // 删除下标是k的点 func remove(k int) { r[l[k]] = r[k] l[r[k]] = l[k] } ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:2:1","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"经典模板题 827. 双链表 707. 设计链表 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:2:2","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"邻接表 邻接表存储的是一个节点和它的边。存储形式为一个矩阵，每个元素代表一个节点及它的所有边。 邻接表多用于存储树和图。 栈与队列 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:3:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"栈 一种先进后出的数据结构。 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:4:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 100010 var st [N]int var tt int = -1 func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var m int fmt.Fscan(in, \u0026m) for ; m \u003e 0; m-- { var op string fmt.Fscan(in, \u0026op) if op == \"push\" { var x int fmt.Fscan(in, \u0026x) push(x) } else if op == \"pop\" { _ = pop() } else if op == \"empty\" { fmt.Fprintln(out, empty()) } else { fmt.Fprintln(out, query()) } } } func push(x int) { tt++ st[tt] = x } func pop() int { x := st[tt] tt-- return x } func empty() string { if tt == -1 { return \"YES\" } return \"NO\" } func query() int { return st[tt] } ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:4:1","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"经典模板题 828. 模拟栈 3302. 表达式求值 剑指 Offer II 036. 后缀表达式 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:4:2","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"单调栈 通常用于解决，寻找每一个数左边离它最近的比它小的数，或寻找每一个数左边离它最近的比它大的数，或右边最近比它小小，诸如此类的问题。 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:5:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 100010 var st [N]int var tt int = -1 func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var m int fmt.Fscan(in, \u0026m) for i := 0; i \u003c m; i++ { var x int fmt.Fscan(in, \u0026x) for tt \u003e -1 \u0026\u0026 st[tt] \u003e= x { tt-- } if tt \u003e - 1 { fmt.Fprintf(out, \"%d \", st[tt]) } else { fmt.Fprint(out, \"-1 \") } tt++ st[tt] = x } } ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:5:1","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"经典模板题 830. 单调栈 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:5:2","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"队列 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:6:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"代码模板 package main import \"fmt\" const N int = 100010 var que [N]int var qh, qt int = 0, -1 func main() { var m int fmt.Scan(\u0026m) for ; m \u003e 0; m-- { var op string fmt.Scan(\u0026op) if op == \"push\" { var x int fmt.Scan(\u0026x) push(x) } else if op == \"pop\" { _ = pop() } else if op == \"empty\" { fmt.Println(empty()) } else { fmt.Println(query()) } } } func push(x int) { qt++ que[qt] = x } func pop() int { x := que[qh] qh++ return x } func empty() string { if qh \u003e qt { return \"YES\" } return \"NO\" } func query() int { return que[qh] } ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:6:1","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"经典模板题 829. 模拟队列 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:6:2","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"单调队列 经典应用是求滑动窗口中的最值。 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:7:0","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 1000010 var a [N]int var deque [N]int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n, k int fmt.Fscan(in, \u0026n, \u0026k) for i := 0; i \u003c n; i++ { fmt.Fscan(in, \u0026a[i]) } // 求窗口中的最小值 hh, tt int := 0, -1 for i := 0; i \u003c n; i++ { // 队头元素已经超出窗口范围，将队头元素弹出 if hh \u003c= tt \u0026\u0026 i - k + 1 \u003e deque[hh] { hh++ } // 重新维护单调队列，从队尾弹出比当前元素大的元素 for hh \u003c= tt \u0026\u0026 a[deque[tt]] \u003e= a[i] { tt-- } tt++; deque[tt] = i // 队列存储的是下标 if i \u003e= k - 1 { fmt.Fprintf(out, \"%d \", a[deque[hh]]) } } fmt.Fprintln(out) // 求窗口中的最大值 hh, tt = 0, -1 for i := 0; i \u003c n; i++ { // 队头元素已经超出窗口范围 if hh \u003c= tt \u0026\u0026 i - k + 1 \u003e deque[hh] { hh++ } // 重新维护单调队列，从队尾弹出比当前元素小的元素 for hh \u003c= tt \u0026\u0026 a[deque[tt]] \u003c= a[i] { tt-- } tt++; deque[tt] = i if i \u003e= k - 1 { fmt.Fprintf(out, \"%d \", a[deque[hh]]) } } } ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:7:1","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"content":"经典模板题 154. 滑动窗口 239. 滑动窗口最大值 kmp算法 kmp算法 ","date":"2022-09-22","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/:7:2","tags":["算法","算法整理","链表","栈","队列","单调栈","单调队列","kmp"],"title":"基础算法整理(四)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E5%9B%9B/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 双指针 双指针算法一般有两种场景： 两个指针分别指向两个不同的集合 两个指针指向同一个集合，本质是维护该集合上的一段区间 双指针一般用于将暴力穷举O(n^2)的算法，优化到O(n)。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:0:0","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 package main import ( \"fmt\" ) func main() { var n int fmt.Scan(\u0026n) nums := make([]int, n) for i := 0; i \u003c n; i++ { fmt.Scan(\u0026nums[i]) } m := make([]int, 1e5 + 10) ans := 0 for i, j := 0, 0; i \u003c n; i++ { m[nums[i]]++ for m[nums[i]] \u003e 1 { m[nums[j]]-- j++ } ans = max(ans, i - j + 1) } fmt.Print(ans) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:0:1","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"经典模板题 799. 最长连续不重复子序列 800. 数组元素的目标和 3. 无重复字符的最长子串 2816. 判断子序列 位运算 常用的位运算操作： 取出n的二进制表示下第k位是多少——(n\u003e\u003ek)\u00261 返回n的二进制表示下最后一位1，也叫lowbit操作——n\u0026-n ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:0:2","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"取出第k位 用0表示第一位。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:1:0","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 package main import \"fmt\" func main() { n := 10 for k := 3; k \u003e= 0; k-- { fmt.Print(n\u003e\u003ek\u00261) } } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:1:1","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"lowbit 公式为：x \u0026 -x。 原理为： 负数在计算机中使用补码的方式表示，因此-x = ^x + 1，当x取反之后，x的最后的1会变成0，而最后的1后面的0会变成1，再加上1的话，会进位一直到最后的1处。因此-x的二进制表达形——最后一个1前与x全部取反，最后一个1及后面全部一致，然后x \u0026 -x就会得到最后一个1及后面的0组成的二进制数。 一般形式： x = 0b(10101010000) ^x = 0b(01010101111) ^x + 1 = 0b(01010110000) 计算过程： x \u0026 -x = 0b(10101010000) \u0026 \\ 0b(01010110000) = 0b(00000010000) lowbit的用处有很多，常见的有：快速计算一个数有多少个位为1。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:0","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 package main import \"fmt\" // 计算二进制表示中1的个数 func main() { var n int fmt.Scan(\u0026n) for i := 0; i \u003c n; i++ { var num, res int fmt.Scan(\u0026num) for num \u003e 0 { num -= lowbit(num) res++ } fmt.Printf(\"%d \", res) } } func lowbit(x int) int { return x \u0026 -x } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:1","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"经典模板题 801. 二进制中1的个数 191. 位1的个数 离散化 这里单独指整数离散化。离散化是指将一个稀疏的区间离散到一个紧凑的区间中。比如有一个区间范围为[-10^9 ~ 10^9]，但是里面只有的数只有10^5范围，那么显然这个区间是稀疏的，有很多重复或空的值。离散化就是把这个稀疏空间映射到紧凑空间上，降低操作的时空间复杂度。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:2","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 func main() { // 存储所有需要操作的下标 alls := make([]int, 0, N) // 对所有需要操作的下标排序去重 quickSort(\u0026alls, 0, len(alls) - 1) alls = unique(alls) // 二分求出离散化后的值 find(alls, x) } func unique(a []int) []int { j := 0 for i := 0; i \u003c len(a); i++ { if i == 0 || a[i] != a[i - 1] { a[j] = a[i] j++ } } // 不应该直接返回a的切片，这样会导致底层大数组的引用没有消失，gc就无法回收 // return a[:j] // 返回一个新开辟的切片，底层数组不同，gc可以将a回收掉 temp := make([]int, j) copy(temp, a[:j]) return temp } func find(a []int, x int) int { l, r := 0, len(a) - 1 for l \u003c r { mid := (l + r) \u003e\u003e 1 if a[mid] \u003e= x { r = mid } else { l = mid + 1 } } return r + 1 } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:3","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"经典模板题 802. 区间和 区间合并 合并满足某种条件的区间，本质是贪心算法。 经典例题是合并有交集的区间，排序后判断左右端点重合则重新维护最小和最大端点。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:4","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 func merge(segs []pair) []pair { // 首先从小到大排序区间 sort.Slice(segs, func(i, j int) bool { return segs[i].first \u003c segs[j].first }) temp := make([]pair, 0) // 赋予开始和结束端点最小值，避免重复 var st, ed int = math.MinInt64, math.MinInt64 // 遍历所有区间 for _, seg := range segs { // 当有区间与开始和结束端点重叠时，更新最大结束端点 if seg.first \u003c= ed { ed = max(ed, seg.second) // 如果没有重叠，说明是一个新区间，更新开始和结束端点 } else { // 避免重复 if st != math.MinInt64 { temp = append(temp, pair{st, ed}) } st = seg.first ed = seg.second } } // 避免重复，再加入最后一个区间 if st != math.MinInt64 { temp = append(temp, pair{st, ed}) } return temp } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:5","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"经典模板题 803. 区间合并 56. 合并区间 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:6","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 高精度 高精度是指，不能直接用一个变量来存储的数据，这种数据有几千位甚至几万位。存储这种数据必须使用数组。高精度运算就是为这种数据做算术运算。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:0:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"1.1 大整数相加 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:1:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import \"fmt\" func main() { a, b := \"\", \"\" fmt.Scanf(\"%s\", \u0026a) fmt.Scanf(\"%s\", \u0026b) A := make([]int, 0, len(a)) B := make([]int, 0, len(b)) for i := len(a) - 1; i \u003e= 0; i-- { A = append(A, int(a[i] - '0')) } for i := len(b) - 1; i \u003e= 0; i-- { B = append(B, int(b[i] - '0')) } C := add(A, B) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } } // C = A + B func add(A, B []int) (C []int) { t := 0 for i := 0; i \u003c len(A) || i \u003c len(B); i++ { if i \u003c len(A) { t += A[i] } if i \u003c len(B) { t += B[i] } C = append(C, t % 10) t /= 10 } if t == 1 { C = append(C, 1) } return C } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:1:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 791. 高精度加法 剑指 Offer II 025. 链表中的两数相加 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:1:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"1.2 大整数相减 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:2:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import \"fmt\" func main() { var a, b string fmt.Scanf(\"%s\", \u0026a) fmt.Scanf(\"%s\", \u0026b) A := make([]int, 0, len(a)) B := make([]int, 0, len(b)) for i := len(a) - 1; i \u003e= 0; i-- { A = append(A, int(a[i] - '0')) } for i := len(b) - 1; i \u003e= 0; i-- { B = append(B, int(b[i] - '0')) } if cmp(A, B) { C := sub(A, B) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } } else { // A \u003c B 的情况，要加上负号 fmt.Print(\"-\") C := sub(B, A) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } } } // 判断是否有 A \u003e= B func cmp(A, B []int) bool { if len(A) != len(B) { return len(A) \u003e len(B) } for i := len(A) - 1; i \u003e= 0; i-- { if A[i] != B[i] { return A[i] \u003e B[i] } } return true } // C = A - B // 应该保证 A \u003e= B func sub(A, B []int) (C []int) { t := 0 for i := 0; i \u003c len(A); i++ { t = A[i] - t if i \u003c len(B) { t -= B[i] } // 考虑了需要进位和不需要进位的情况 C = append(C, (t + 10) % 10) if t \u003c 0 { t = 1 } else { t = 0 } } // 去除前导零 for len(C) \u003e 1 \u0026\u0026 C[len(C) - 1] == 0 { C = C[:len(C) - 1] } return C } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:2:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 792. 高精度减法 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:2:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"1.3 大整数乘法 一个高精度的正整数A，乘上一个低精度的正整数b。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:3:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import \"fmt\" func main() { var a string var b int fmt.Scanf(\"%s\", \u0026a) fmt.Scanf(\"%d\", \u0026b) if b == 0 { fmt.Print(0) } else { A := make([]int, 0, len(a)) for i := len(a) - 1; i \u003e= 0; i-- { A = append(A, int(a[i] - '0')) } C := mul(A, b) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } } } // C = A * b // 0 \u003c= b \u003c= 10000 func mul(A []int, b int) (C []int) { for i, t := 0, 0; i \u003c len(A) || t \u003e 0; i++ { if i \u003c len(A) { t += A[i] * b } C = append(C, t % 10) t /= 10 } return C } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:3:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 793. 高精度乘法 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:3:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"1.4 大整数除法 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:4:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import \"fmt\" func main() { var a string var b int fmt.Scanf(\"%s\", \u0026a) fmt.Scanf(\"%d\", \u0026b) A := make([]int, 0, len(a)) for i := len(a) - 1; i \u003e= 0; i-- { A = append(A, int(a[i] - '0')) } C, r := div(A, b) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } fmt.Printf(\"\\n%d\", r) } // C = A / b, r = A % b // 1 \u003c= b \u003c= 10000 func div(A []int, b int) (C []int, r int) { // 高精度除法需要从最高位开始处理， // 与其他算术运算不同 for i := len(A) - 1; i \u003e= 0 ; i-- { r = r * 10 + A[i] C = append(C, r / b) r %= b } // 反转C，与其他算术运算输出逻辑保持一致 reverse(C, 0, len(C) - 1) // 去除前导零 for len(C) \u003e 1 \u0026\u0026 C[len(C) - 1] == 0 { C = C[:len(C) - 1] } return C, r } func reverse(a []int, l, r int) { for l \u003c r { a[l], a[r] = a[r], a[l] l++; r-- } } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:4:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 794. 高精度除法 前缀和与差分 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:4:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"一维前缀和 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"什么是前缀和？ 设有长度为n的原数组a，则其前缀和si为原数组前i项的和——si=a1+a2+...+ai，当i=0时，s0=0。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"如何求前缀和数组？ 从前往后遍历原数组，s[i]=s[i-1]+a[i]。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"前缀和的作用 前缀和一般用来在O(1)时间复杂度内求解区间和。比如求解原数组a[3]~a[10]的区间和，用前缀和求解为s[10]-s[2]。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:3","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 100010 var a[N]int var b[N]int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n, m int fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026a[i]) } for i := 1; i \u003c= n; i++ { b[i] = b[i - 1] + a[i] } for ; m \u003e 0; m-- { var l, r int fmt.Fscan(in, \u0026l, \u0026r) fmt.Fprintln(out, b[r] - b[l-1]) } } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:4","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 795. 前缀和 303. 区域和检索 - 数组不可变 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:5","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"二维前缀和 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:6:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() const N int = 1010 var a, s [N][N]int var n, m, q int fmt.Fscan(in, \u0026n, \u0026m, \u0026q) for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { fmt.Fscan(in, \u0026a[i][j]) } } for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { // 求前缀和 s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j] } } for ; q \u003e 0; q-- { var x1, y1, x2, y2 int fmt.Fscan(in, \u0026x1, \u0026y1, \u0026x2, \u0026y2) // 求子矩阵的和 fmt.Fprintln(out, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]) } } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:6:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 796. 子矩阵的和 304. 二维区域和检索 - 矩阵不可变 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:6:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"一维差分 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"什么是差分？ 差分是前缀和的逆运算，对一个差分数组求前缀和，得到原数组。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"如何求差分数组？ 构造这样一个数据，对于原数组a而言，差分数组b中每一个元素，都等于b[i] = a[i] - a[i-1]，其中b[1] = a[1]。 这样构造完之后，我们对其求前缀和可以发现，得到的答案就是原数组。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"差分的作用 差分数组用于解决区间加值的问题。比如给区间[l:r]中每一个数都加上C，利用差分数组可以在O(1)时间复杂度完成。 实现过程为，在差分数组b[l]处加上C，在b[r+1]处减去C，这样在还原为原数组时，区间[l:r]就施加上C的影响，在[r+1:n]减去C的影响。 公式为：b[l] += C; b[r+1] -= C。 图例——为[4:7]这个区间加上3。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:3","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N = 100010 var a [N]int var b [N]int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n, m int fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026a[i]) insert(i, i, a[i]) } for ; m \u003e 0; m-- { var l, r, c int fmt.Fscan(in, \u0026l, \u0026r, \u0026c) insert(l, r, c) } for i := 1; i \u003c= n; i++ { b[i] += b[i-1] fmt.Fprintf(out, \"%d \", b[i]) } } func insert(l, r, c int) { b[l] += c b[r+1] -= c } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:4","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 797. 差分 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:5","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"二维差分 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:8:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 1010 var a [N][N]int var b [N][N]int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n, m, q int fmt.Fscan(in, \u0026n, \u0026m, \u0026q) // 读取原数组数据，并构建差分数组 for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { fmt.Fscan(in, \u0026a[i][j]) insert(i, j, i, j, a[i][j]) } } // q次矩阵增加c值操作 for ; q \u003e 0; q-- { var x1, y1, x2, y2, c int fmt.Fscan(in, \u0026x1, \u0026y1, \u0026x2, \u0026y2, \u0026c) insert(x1, y1, x2, y2, c) } // 构建二维前缀和数组 for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1] } } // q次矩阵增加c之后的答案输出 for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { fmt.Fprintf(out, \"%d \", b[i][j]) } fmt.Fprintln(out) } } func insert(x1, y1, x2, y2, c int) { b[x1][y1] += c b[x2+1][y1] -= c b[x1][y2+1] -= c b[x2+1][y2+1] += c } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:8:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 798. 差分矩阵 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:8:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","排序","二分"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 1. 排序 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:0:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"1.1 快速排序 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:1:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"代码模板 func sortArray(nums []int) []int { qucikSort(nums, 0, len(nums) - 1) return nums } func qucikSort(nums []int, l, r int) { if l \u003e= r { return } pivot := nums[(l + r) / 2] i, j := l - 1, r + 1 for i \u003c j { for i++; nums[i] \u003c pivot; i++ {} for j--; nums[j] \u003e pivot; j-- {} if i \u003c j { nums[i], nums[j] = nums[j], nums[i] } } qucikSort(nums, l, j) qucikSort(nums, j + 1, r) } ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:1:1","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"经典模板题 912. 排序数组 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:1:2","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"1.2 归并排序 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:2:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"代码模板 递归版 func sortArray(nums []int) []int { mergeSort(nums, 0, len(nums) - 1) return nums } func mergeSort(nums []int, left, right int) { if left \u003e= right { return } mid := (left + right) \u003e\u003e 1 mergeSort(nums, left, mid) mergeSort(nums, mid + 1, right) temp := merge(nums[left:mid+1], nums[mid+1:right+1]) copy(nums[left:], temp) } func merge(left, right []int) []int { temp := make([]int, len(left) + len(right)) i, j, k := 0, 0, 0 for i \u003c len(left) || j \u003c len(right) { if i \u003e= len(left) { copy(temp[k:], right[j:]) return temp } if j \u003e= len(right) { copy(temp[k:], left[i:]) return temp } if left[i] \u003c= right[j] { temp[k] = left[i] k++; i++ } else { temp[k] = right[j] k++; j++ } } return temp } 迭代版 func sortArray(nums []int) []int { mergeSort(nums) return nums } func mergeSort(nums []int) { for step := 1; step \u003c len(nums); step += step { for i := 0; i + step \u003c len(nums); i += 2 * step { temp := merge(nums[i:i+step], nums[i+step:min(i+2*step, len(nums))]) copy(nums[i:], temp) } } } func merge(left, right []int) []int { temp := make([]int, len(left) + len(right)) i, j, k := 0, 0, 0 for i \u003c len(left) || j \u003c len(right) { if i \u003e= len(left) { copy(temp[k:], right[j:]) break } if j \u003e= len(right) { copy(temp[k:], left[i:]) break } if left[i] \u003c= right[j] { temp[k] = left[i] k++; i++ } else { temp[k] = right[j] k++; j++ } } return temp } func min(a, b int) int { if a \u003c b { return a } return b } ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:2:1","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"经典模板题 912. 排序数组 剑指 Offer 51. 数组中的逆序对 2. 二分 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:2:2","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"2.1 整数二分 二分的本质是将一个区间分为两块，一块满足要求，另一块不满足要求，然后就可以寻找这两块区间的边界。 每次缩小的时候，都要确保剩余区间内有答案。 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:3:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"代码模板 寻找左边界 func bsearch(nums []int, target int) int { if len(nums) == 0 { return -1 } l, r := 0, len(nums) - 1 for l \u003c r { mid := (l + r) \u003e\u003e 1 if nums[mid] \u003e= target { r = mid } else { l = mid + 1 } } if nums[l] != target { return -1 } return l } 寻找右边界 func bsearch(nums []int, target int) int { if len(nums) == 0 { return -1 } l, r := 0, len(nums) - 1 for l \u003c r { mid := (l + r + 1) \u003e\u003e 1 if nums[mid] \u003c= target { l = mid } else { r = mid - 1 } } if nums[r] != target { return -1 } return r } ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:3:1","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"经典模板题 704. 二分查找 34. 在排序数组中查找元素的第一个和最后一个位置 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:3:2","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"2.2 浮点数二分 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:4:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"代码模板 func mySqrt() { var x float64 fmt.Scanf(\"%f\", \u0026x) var l, r float64 = 0, x for r - l \u003e 1e-8 { mid := (l + r) / 2 if mid * mid \u003e= x { r = mid } else { l = mid } } fmt.Printf(\"%f\", l) } ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:4:1","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"经典模板题 69. x 的平方根 790. 数的三次方根 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:4:2","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","树状数组"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 参考 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:0:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"树状数组是什么？ 树状数组，或称Binary Indexed Tree, Fenwick Tree，是一种用于高效处理对一个存储数字的列表进行更新及求前缀和的数据结构。 树状数组所能解决的典型问题就是存在一个长度为n的数组，我们如何高效进行如下操作： update(idx, delta)：将num加到位置idx的数字上。 prefixSum(idx)：求从数组第一个位置到第idx（含idx）个位置所有数字的和。 rangeSum(from_idx, to_idx)：求从数组第from_idx个位置到第to_idx个位置的所有数字的和 如果用暴力求解数组区间和，时间复杂度为O(n)，更新数组值为O(1)。 // [left,right] func rangeSum(left, right int) int { // 时间复杂度O(n)，与for left\u003c= right 没有数量级上的差距 return sum(right) - sum(left - 1) } // [0,index] func sum(index int) int { if index \u003c 0 || index \u003e= len(nums) { return 0 } sum := 0 for i := index; i \u003e= 0; i-- { sum += nums[i] } return sum } // O(1) func update(index, delta int) { nums[index] += delta } 用前缀和求解区间和的时间复杂度为O(1)，更新数组值为O(n) type Presum struct { nums []int } func NewPreSum(nums []int) Presum { pre := make([]int, len(nums)) pre[0] = nums[0] for i := 1; i \u003c len(nums); i++ { pre[i] = pre[i-1] + nums[i] } return Presum{ nums: pre, } } func (p *Presum) Update(index, val int) { // O(n) for i := index; i \u003c len(p.nums); i++ { p.nums[i] += val } } func (p *Presum) SumRange(left, right int) int { // O(1) return p.nums[right] - p.nums[left-1] } 树状数组求解区间和的时间复杂度为O(logn)，更新数组值为O(logn)。因为修改值之后需要重新维护树状数组。 type BinaryIndTree struct { Nums []int Tree []int } func NewBinaryIndTree(nums []int) BinaryIndTree { // 用前缀和快速构造树状数组 length := len(nums) tree := make([]int, length+1) preSum := make([]int, length+1) for i := 1; i \u003c= length; i++ { preSum[i] = preSum[i-1] + nums[i-1] tree[i] = preSum[i] - preSum[i-lowbit(i)] } return BinaryIndTree{ Nums: nums, Tree: tree, } } func lowbit(i int) int { return i \u0026 (-i) } func (b *BinaryIndTree) Add(index, delta int) { // O(logn) for i := index; i \u003c len(b.Tree); i += lowbit(i) { b.Tree[i] += delta } } func (b *BinaryIndTree) Update(index, val int) { b.Add(index+1, val-b.Nums[index]) b.Nums[index] = val } func (b *BinaryIndTree) Sum(index int) int { sum := 0 // O(logn) for i := index; i \u003e 0; i -= lowbit(i) { sum += b.Tree[i] } return sum } func (b *BinaryIndTree) SumRange(left, right int) int { return b.Sum(right+1) - b.Sum(left) } 树状数组适用于对数组查询和修改都有性能要求的场景。 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:1:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"树状数组如何高效？ 看上面这张图，可以把树状数组想象成一棵树。所有奇数下标的都是独立子节点。子节点通过i+lowbit(i)来找到其父节点，父节点存储的就是它和它所有子节点的和。通过这样一棵树，我们可以用O(logn)的时间复杂度来获得一个区间的和。 为了方便表示，tree被画成了不连续的样子，实际上tree在内存中仍是连续的数组。 下面这样图可以比较容易理解树状数组在更新节点值时，如何知道那些节点值是应该更新的。 比如我们要对下标i的值进行更新，除了对i本身，还有其上面覆盖了i(或者说管辖i)的所有节点进行更新。比如i=1，则需要更新的节点为1、2、4、8 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:2:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"lowbit原理 lowbit(i)用一句话来解释就是——截断i在二进制表示中最低位1前面的数。 比如：i=6=b(110)，截断最低位1前面的数得到b(10)=2 lowbit实现很简单 func lowbit(i int) int { // return i \u0026 ((~i)+1) 两者等价 return i \u0026 (-i) } 为什么\u0026上自己的负数可以截断最低位1前面的数呢？因为负数在计算机中是用补码来表示的，所以我们需要对补码、原码有一些了解。 原码：用最高位表示符号位，如int8(-8) = 原(10001000) 补码：对原码除符号位之外的所有位取反并加1，如int8(-8) = 补(11111000) 反码：对原码除符号位之外的所有位取反，如int8(-8) = 反(11110111) 这里我们以6和-6为例，假设他们都是有符号的8位数。 可以发现一个数的正数与负数，它们除了最低位的1及后面的数之外，每一位的数都不相同，因此它们相\u0026可以得到我们想要的结果——截断i在二进制表示中最低位1前面的数。 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:2:1","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"树状数组功能一览 根据节点维护的数据含义不同，树状数组可以提供不同的功能来满足各种区间场景。 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"1. 单点增减+区间求和 LeetCode-307. 区域和检索 - 数组可修改 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:1","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"2. 区间增减+单点查询 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:2","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"3. 区间增减+区间求和 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:3","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"4. 单点增减+区间最值 HDU-1754 I Hate It ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:4","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"5. 区间叠加+单点最值 LeetCode-218. 天际线问题 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:5","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"树状数组常见应用 求逆序对 求区间逆序对 求树上逆序对 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:4:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"二维树状数组 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:5:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"完整代码 type BinaryIndTree struct { Nums []int Tree []int } func NewBinaryIndTree(nums []int) BinaryIndTree { // 用前缀和快速构造树状数组 length := len(nums) tree := make([]int, length+1) preSum := make([]int, length+1) for i := 1; i \u003c= length; i++ { preSum[i] = preSum[i-1] + nums[i-1] tree[i] = preSum[i] - preSum[i-lowbit(i)] } return BinaryIndTree{ Nums: nums, Tree: tree, } } func (b *BinaryIndTree) update(index, delta int) { for i := index; i \u003c len(b.Tree); i += lowbit(i) { b.Tree[i] += delta } } func (b *BinaryIndTree) Update(index, val int) { b.update(index+1, val-b.Nums[index]) b.Nums[index] = val } func (b *BinaryIndTree) Sum(index int) int { sum := 0 for i := index; i \u003e 0; i -= lowbit(i) { sum += b.Tree[i] } return sum } func (b *BinaryIndTree) SumRange(left, right int) int { return b.Sum(right+1) - b.Sum(left) } func lowbit(i int) int { return i \u0026 (-i) } ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:6:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","查找算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:0","tags":["算法","查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法","查找算法"],"content":"二分查找 对于任何有序集合，我们可以使用二分查找的方式来快速定位到想要的元素。 二分查找的时间复杂度为O(logn) 二分查找的实现难点在于边界条件的判断，要注意集合的闭合区间。实现时闭合区间分为两种：[left,right]和[left,right)，两种不同的闭合区间的代码实现也不同。 ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:0","tags":["算法","查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法","查找算法"],"content":"二分查找的边界条件 [left,right] // BinarySearch 查找nums中是否存在target，并返回其下标，如果不存在返回-1 func BinarySearch(nums []int, target int) int { length := len(nums) left, right := 0, length - 1 for left \u003c= right { mid := left + (right - left) / 2 if nums[mid] \u003c target { left = mid + 1 } else if nums[mid] \u003e target { right = mid - 1 } else { return mid } } return -1 } [left,right) // BinarySearch 查找nums中是否存在target，并返回其下标，如果不存在返回-1 func BinarySearch(nums []int, target int) int { length := len(nums) left, right := 0, length for left \u003c right { mid := left + (right - left) / 2 if nums[mid] \u003c target { left = mid + 1 } else if nums[mid] \u003e target { right = mid } else { return mid } } return -1 } ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:1","tags":["算法","查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法","查找算法"],"content":"二分查找其他应用 二分查找不仅可以用于有序序列，还可以用于部分有序序列，比如leetcode 153.寻找旋转排序数组中的最小值也可以使用二分法。 由此我们可知，二分查找只是一种查找的思想。对于查找一个值，我们要首先想到如何能跳过一些无意义的比较，收缩左右边界，以达到加快搜索的过程。 ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:2","tags":["算法","查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法","回溯"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:0","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","回溯"],"content":"回溯 回溯就是暴力穷举，对于一些组合、切割、求子集、n皇后等问题，只能使用暴力穷举的方式遍历所有可能性求解。 回溯用于解决n层for循环的问题 对于一个长度为n的序列，要求出它所有的子集，需要写出n层for循环。因为序列长度n未知，所以连用for暴力穷举的代码都写不出来。 这是就要用到回溯，通过递归的方式，不断深入，开启n层for循环。 n层递归的循环，就像是一颗树，循环的次数是树的宽度，递归的次数是树的深度 ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:1","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","回溯"],"content":"回溯模板 func demo() { // 存放结果 res := make([]int, 0) // 存放临时结果 path := make([]int, 0) // 回溯函数的参数很难提前确定 // 一般在写具体实现是根据需要补上 var backTracking func(所需参数) backTracking = func(所需参数) { if 满足要求 { // 新申请内存空间，避免底层数组一致 res = append(res, append([]int{}, path...)...) return } for 遍历序列 { path = append(添加临时结果) backTracking(所需参数) path = path[:len(path)-1] } } } ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:2","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","回溯"],"content":"回溯的去重 去重首先需要序列有序，然后在for循环内部判断当前元素与前一元素是否相同，如果相同就continue ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:3","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","回溯"],"content":"标识当前元素已被使用 used := make([]bool, length) backTracking = func() { for i := 0; i \u003c len(nums); i++ { if used[i] { continue } used[i] = true ... backTracking() used[i] = false ... } } ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:4","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","树"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 树的遍历方式分为如下几种： 前序遍历 中序遍历 后序遍历 层序遍历 其中前序遍历可以求出树的深度，而后序遍历可以求出树的高度 树的遍历也可以借用辅助数据结构来完成： 栈 队列 栈适合模拟前中后序遍历，队列适合模拟层序遍历 ","date":"2022-02-21","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/:0:0","tags":["算法","树"],"title":"树的递归遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"categories":["算法","树"],"content":"前序遍历求深度 func maxDepth(root *TreeNode) int { if root == nil { return 0 } leftDepth := maxDepth(root.Left) rightDepth := maxDepth(root.Right) return max(leftDepth, rightDepth) + 1 } ","date":"2022-02-21","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/:0:1","tags":["算法","树"],"title":"树的递归遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"categories":["bit数组","bitmap"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 什么是bit数组？ bit数组通常为一个无符号数的数组，用每一个元素的每一个bit位来存储数据。 var bitSlice []uint64{0, 0, 0} bit数组 当我们存储数据，比如存储2时，对64取商和模为0和2，可知需要将2存储在bitSlice[0]的第2个bit位中，因此我们把bitSlice[0] \u0026 1\u003c\u003c2即可标识2被存储了 把2存储到bitSlice中 对于更大的数字，比如66，对64取商和模为1和2，可知需要将66存储在bitSlice[1]的第2个bit位中，因此我们把bitSlice[1] \u0026 1\u003c\u003c2即可标识66被存储了 把66存储到bitSlice中 bit数组有什么用？ bit数组可以使用很小的存储空间，存储更多的数据。对于uint64而言，如果直接存储，一个数要使用8byte空间，64个数则要64*8byte=512byte，而用bit来存，一个uint64的变量可以存储64个数，空间节省了64倍。 如果我们要对40亿条数据进行排序去重，但机器可用内存只有4G，要怎么做呢？ 我们先来计算一下，4,000,000,000对64取商和模为62,500,000和0，可知数组最大需要62,500,000个元素，而62,500,000 * 8byte = 500,000,000byte ≈ 480M 如果用[]uint32切片直接存储，则需要4,000,000,000 * 4byte = 16,000,000,000byte ≈ 15G 使用bit数组，存储时只会将数所在的bit位 置1，所以只要按顺序取出数据，就是排序去重后的数据。 bit数组应用 bit数组在很多地方都有应用，比如redis中的bitmap就是使用了bit数组的方式实现的。 bit数组实现 package bitmap import ( \"bytes\" \"fmt\" ) // 参考go语言圣经6.5章节 // UINTSIZE 判断当前机器是32位还是64位 // 64位机器^uint(0) = 64位全1，\u003e\u003e 63之后变成只有第一位为1，32 \u003c\u003c 1 = 64 // 32位机器\u003e\u003e 63之后全部位变为0，32 \u003c\u003c 0 = 32 const UINTSIZE = 32 \u003c\u003c (^uint(0) \u003e\u003e 63) // An IntSet is a set of small non-negative integers. // Its zero value represents the empty set. type IntSet struct { words []uint } // Has reports whether the set contains the non-negative value x. func (s *IntSet) Has(x int) bool { word, bit := x/UINTSIZE, uint(x%UINTSIZE) // words长度大于数据所在元素下标，且所在bit位不为0 return word \u003c len(s.words) \u0026\u0026 s.words[word]\u0026(1\u003c\u003cbit) != 0 } // Add adds the non-negative value x to the set. func (s *IntSet) Add(x int) { // 对要存储的数取商和模 word, bit := x/UINTSIZE, uint(x%UINTSIZE) // 如果words数组长度小于商，则扩容至能存下为止 for word \u003e= len(s.words) { s.words = append(s.words, 0) } // 将数存储到指定bit位 s.words[word] |= 1 \u003c\u003c bit } // UnionWith sets s to the union of s and t. // 设置s为s和t的并集 func (s *IntSet) UnionWith(t *IntSet) { for i, tword := range t.words { if i \u003c len(s.words) { // 取并集 // 101 | 010 = 111 s.words[i] |= tword } else { s.words = append(s.words, tword) } } } // IntersectWith sets s to the intersect of s and t // 设置s为s和t的交集 // 元素在s集合t集合均出现 func (s *IntSet) IntersectWith(t *IntSet) { // 如果s比t长，把s截取到t的长度 if len(s.words) \u003e len(t.words) { s.words = s.words[:len(t.words)] } // 如果t比s长，也只会比较s中有的部分 for i, tword := range t.words { if i \u003c len(s.words) { s.words[i] \u0026= tword } } } // DifferenceWith sets s to the difference of s and t // 设置s为s和t的差集 // 元素出现在s集合，未出现在t集合 func (s *IntSet) DifferenceWith(t *IntSet) { for i, tword := range t.words { if i \u003c len(s.words) { // ^: 异或运算，值不同则为1，相同为0 // B A // 100011010 ^ 110101001 = 010110011 // 010110011 \u0026 110101001 = 010100001 // 正好是A中有而B中没有的 s.words[i] \u0026= s.words[i] ^ tword } } } // SymmetricDifference sets s to the symmetric difference of s and t // 设置s为s和t的并查集 // 元素出现在s但没有出现在t，或者出现在t没有出现在s func (s *IntSet) SymmetricDifference(t *IntSet) { for i, tword := range t.words { if i \u003c len(s.words) { s.words[i] ^= tword } else { // 如果s元素个数小于t，则s要把t中多的部分补上 s.words = append(s.words, tword) } } } // String returns the set as a string of the form \"{1 2 3}\". // String方法，fmt.Printf()函数对实现了String方法的类型会直接调用其String()方法进行输出 func (s *IntSet) String() string { var buf bytes.Buffer buf.WriteByte('{') for i, word := range s.words { if word == 0 { continue } // 逐位遍历，如果为1，则将其写入缓冲区 for j := 0; j \u003c UINTSIZE; j++ { if word\u0026(1\u003c\u003cuint(j)) != 0 { if buf.Len() \u003e len(\"{\") { buf.WriteByte(' ') } // UINTSIZE*i+j还原数实际大小 // 比如2存储在[0]的第2个比特位 // UINTSIZE*0+2=2 fmt.Fprintf(\u0026buf, \"%d\", UINTSIZE*i+j) } } } buf.WriteByte('}') return buf.String() } // Len return the number of elements // 返回当前存储了多少个数 func (s *IntSet) Len() int { l := 0 for _, word := range s.words { if word == 0 { continue } for j := 0; j \u003c UINTSIZE; j++ { if word\u0026(1\u003c\u003cuint(j)) != 0 { l++ } } } return l } // Elems returns a slice containing the elements of the set func (s *IntSet) Elems() []int { res := make([]int, s.Len()) k := 0 for i, word := range s.words { if word == 0 { continue } for j := 0; j \u003c UINTSIZE; j++ { if word\u0026(1\u003c\u003cj) != 0 { res[k] = UINTSIZE*i + j k++ } } } return res } // Remove remove x from the set // 删除指定数 func (s *IntSet) Remove(x int","date":"2022-02-15","objectID":"/bit%E6%95%B0%E7%BB%84/:0:0","tags":["bit数组","bitmap"],"title":"Bit数组/bitmap","uri":"/bit%E6%95%B0%E7%BB%84/"},{"categories":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 什么是RK算法？ RK算法是一种字符串匹配算法。核心思想是将字符串映射为其字符集长度的数值(hash值)，将字符串比较变为数值比较，从而可以获得较好的性能。需要注意的是，当hash相同时，字符串任然有小概率不相同，hash不同则不可能相同。 对于文本串s和模式串p，我们计算p的hash值，然后再计算s中长度为len(p)的所有子串的hash值，对比他们是否相同，如果相同还需再比较一次字符串是否相同。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:0:0","tags":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"content":"什么是hash值？ 通过一个hash函数，将输入内容转化为数字，这个数字就是hash值。对于输入的内容相同，hash函数输出的值必须相同且应该尽量唯一。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:1:0","tags":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"content":"如何计算字符串的hash值？ 对于一串数字字符串\"1234\"，我们可以把它看做是10进制数，通过计算:'1'*10^(4-1) + '2'*10^(4-2) + '3'*10^(4-3)+'4'*10^(4-4)将它hash为1234(10^2表示10的2次方,4为字符串长度)。 对于小写字母字符串\"abcd\"，我们可以把它看做是26进制数，通过计算:'a'*26^(4-1) + 'b'*26^(4-2) + 'c'*26^(4-3) + 'd'*26^(4-4)将它hash为19010(‘a’=1,‘b’=2,‘c’=3,’d’=4)。 对于大小写字符混合字符串\"AbCd\"，我们可以把它看做是128进制(ASCII码128个字符)，通过计算:'A'*128^(4-1) + 'b'*128^(4-2) + 'C'*128^(4-3) + 'd'*128^(4-4)，将它们hash为137,929,188(‘A’=65,‘b’=98,‘C’=67,’d’=100)。 通过上述例子可以发现，我们可以把一串字符hash为它们字符集进制的数，那么我们是否可以用Unicode字符集作为进制数？不就可以表示所有字符了？答案是可以的。Unicode字符集所有字符个数为1114112个。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:2:0","tags":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"content":"如何使用hash进行字符串匹配？ 对于文本串s\"12345\"，我们希望知道模式串p\"45\"是否被s包含要如何做？ 以10进制为例。 首先对p进行hash，'4'*10+'5'=45，对s[0:2]进行hash，'1'*10+'2'=12，12不等于45，进行下一轮计算s[1:3]。下一轮计算难道又要'2'*10+'3'=23这样遍历s[1:3]的每一个字符吗？其实不用，我们可以把(12-10)*10+3，这意味着我们总共只需要遍历s串一次，而p串也是一次，这就是rk算法时间复杂度O(m+n)的原因。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:3:0","tags":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"content":"常用的字符串hash函数 BKDRHash ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:4:0","tags":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"content":"如何解决hash值相同但字符串不相同的情况 字符串hash难免出现hash值相同的情况，当相同时我们需要额外遍历一遍以确保相同。 Golang中的RK算法应用 // PrimeRK相当于我们上面提到的进制 const PrimeRK = 16777619 // HashStr returns the hash and the appropriate multiplicative // factor for use in Rabin-Karp algorithm. func HashStr(sep string) (uint32, uint32) { hash := uint32(0) for i := 0; i \u003c len(sep); i++ { // 将模式串hash为PrimeRK进制的数 hash = hash*PrimeRK + uint32(sep[i]) } // var pow, sq uint32 = 1, PrimeRK for i := len(sep); i \u003e 0; i \u003e\u003e= 1 { if i\u00261 != 0 { pow *= sq } sq *= sq } return hash, pow } // IndexRabinKarp uses the Rabin-Karp search algorithm to return the index of the // first occurrence of substr in s, or -1 if not present. func IndexRabinKarp(s, substr string) int { if len(s) \u003c len(substr) { return -1 } // Rabin-Karp search hashss, pow := HashStr(substr) n := len(substr) var h uint32 for i := 0; i \u003c n; i++ { h = h*PrimeRK + uint32(s[i]) } if h == hashss \u0026\u0026 s[:n] == substr { return 0 } for i := n; i \u003c len(s); { h *= PrimeRK h += uint32(s[i]) h -= pow * uint32(s[i-n]) i++ if h == hashss \u0026\u0026 s[i-n:i] == substr { return i - n } } return -1 } 参考：https://www.cnblogs.com/golove/p/3234673.html ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:5:0","tags":["算法","hash","字符串hash","RK算法","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 什么是KMP算法？ kmp算法是一种用于高效匹配字符串子串是否存在的算法，比如想知道文本串s中是否存在模式串p，就可以使用kmp算法。 如何实现KMP算法？ 实现kmp算法分两步 基于模式串初始化next数组 使用next数组加速字符串匹配 ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:0:0","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"什么是next数组？ next数组，又称为prefix数组、前缀表，其作用是记录给定字符串的所有子串中相等的前后缀长度。 ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:1:0","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"什么是前缀后缀？ 对于字符串cbccbcbccc，其前缀为包含首字符不包含尾字母的任意子串，其后缀为包含尾字符不包含首字符的任意子串。 前缀 c cb cbc cbcc ... cbccbcbcc 后缀 c cc ccc bccc ... bccbcbccc 对于字符串cbccbcbccc的每一个子串，我们求出它们的最长相等前后缀长度，其中子串c初始化为0。 最长相等前后缀 ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:1:1","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"next数组具体实现 求next数组的代码如下 func getNext(s string) []int { sLen := len(s) next := make([]int, sLen) next[0] = 0 j := 0 for i := 1; i \u003c sLen; i++ { // j要保证大于0，因为下面有取j-1作为数组下标的操作 for j \u003e 0 \u0026\u0026 s[i] != s[j] { // 回退前一位 j = next[j - 1] } if s[i] == s[j] { j++ } next[i] = j } return next } 求出next数组后，我们就可以利用它加速字符串的匹配。 当遇到不匹配时，就往前找一个最长相等前后缀，并移动模式串指针到他的后面，再尝试匹配 不匹配 匹配 当i==j==5时，文本串s[5] != 模式串p[5]，这时我们在next数组中往前找一位，next数组中记录了p[0:5]这个子串最长相等前后缀长度为2，意味着我们j指针只需要回退到下标为2的位置就可以继续匹配了，跳过了前面相同的部分 kmp具体实现 func kmp(s string, p string) int { m, n := len(s), len(p) next := make([]int, n) // 构建next数组 for i, j := 1, 0; i \u003c n; i++ { for j \u003e 0 \u0026\u0026 p[i] != p[j] { j = next[j-1] } if p[i] == p[j] { j++ } next[i] = j } // 根据next数组加速字符串匹配 for i, j := 0, 0; i \u003c m; i++ { for j \u003e 0 \u0026\u0026 s[i] != p[j] { j = next[j-1] } if s[i] == p[j] { j++ } if j == n { return i - n + 1 } } // 全部匹配失败，返回-1 return -1 } ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:2:0","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["分享"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 1 引言 本文用于记录日常使用hugo的优化建议，阅读时长10分钟。 适用于以下人员： 已经搭建好Hugo博客 希望使用图床功能 希望自己的博客能在百度和谷歌上搜索到 本文将从以下几点进行优化： 使用GitHub作为博文的图床 让百度和谷歌收录站点 2 使用GitHub作为图床储存图片 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:0:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"什么是图床 图床是一个专门存放图片的服务器，使用图床可以让我们的博客直接从网上获取图片，而无需管理本地图片路径，让我们获得更好的博文书写体验。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:1:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"优雅的使用图床 方案为：VsCode+PicGo插件+GitHub。 VsCode用于书写博客文章，PicGo插件用于快速生成网络图片链接，GitHub作为图片服务器存放图片。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"操作步骤如下： ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:1","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"1.安装VsCode 点击VsCode即可前往下载界面。安装十分简单，不再赘述。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:2","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"2.下载PicGo插件 打开VsCode，在左侧的扩展管理中输入PicGo下载插件。 下载PicGo插件 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:3","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"3.创建GitHub图床仓库 创建一个名字为\u003c你github账户名\u003e.github.io的仓库，我这里的是博客使用的仓库，并使用images目录作为图片存放的目录。 创建GitHub图床仓库 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:4","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"4.生成令牌(Token) 接下来需要生成令牌，让PicGo插件能通过令牌免密上传图片到图床目录。 生成令牌 生成令牌 生成令牌 生成令牌 Token生成之后要及时复制，之后就无法复制了。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:5","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"5.配置PicGo插件 打开VsCode上的PicGo插件，点击小齿轮进行配置。 在配置中找到GitHub的相关配置项，从上到下分别配置：图床目录(必须加上/)，github仓库，Token令牌。 配置PicGo插件 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:6","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"6.测试图床 VsCode上的PicGo插件配置好之后，使用Ctrl+Alt+u可以把剪切版中的图片上传到图床中，并且会在当前VsCode打开的文件中生产一个图片的网络链接。同时我们看GitHub上的images目录时，会发现图片被自动上传了。 测试图床 2 在百度和谷歌上添加网站 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:7","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"为什么要添加网站 在百度和谷歌添加博客的网站之后，就可以通过百度和谷歌的搜索引擎找到自己的博客。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:3:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"收录和站点管理 站点收录：让百度或谷歌知道有这个站点的存在，添加之后需要等1~7天（不同搜索引擎不一样）的时间后才能找到自己的博客。 站点管理：向百度或谷歌证明某个站点是属于你的，即你是网站的管理员。可以通过如下方式进行证明： 在网站首页中增加一个校验值标签 在网页目录中增加一个校验页面 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:4:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"添加收录 测试网址是否被收录：site:hts0000.github.io。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:5:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"百度 检查收录 添加之后百度大概需要一星期的时间进行收录。 检查收录 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:5:1","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"谷歌 检查收录 添加之后谷歌大概需要1~2天的时间来收录网站。 检查收录 收录成功后在谷歌中搜索：site:hts0000.github.io，就可以发现我们的网站可以通过浏览器搜索到了。 检查收录 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:5:2","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"站点管理 通过百度账号和谷歌账号，可以绑定网站，通过百度和谷歌的统计功能，可以看到网站的访问次数和访问情况。 让账号和网站绑定，需要向百度和谷歌证明你是网站的管理员，证明的方法有很多种，这次选择校验页面的方式进行验证。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:6:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"百度 首先在账号中添加网站 站点管理 站点管理 把下载好的校验页面放到网页目录下，向百度证明你是网站的管理员。 站点管理 校验成功后可以在站点管理中看到刚刚添加的站点。 站点管理 点击站点可以看到百度为我们统计的站点信息，如点击率搜索量等等。 站点管理 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:6:1","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"谷歌 谷歌的操作与百度类似，也是在网页的目录下添加校验页面，向谷歌证明你是网站的管理员。 站点管理 添加完成之后也可以通过谷歌统计的站点信息查看网站的点击量等等。 站点管理 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:6:2","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 1 引言 本文用于记录基于HUGO搭建个人博客的步骤和注意事项，阅读时长大概30分钟。 适用于以下人员： 想搭建博客 想了解hugo 闲着没事 2 准备阶段 在开始搭建博客前，希望你已经准备好以下工具，以便能快速的跟上本篇文章。 Git Bash Notepad++ VSCode 文章将会从如下三个大步骤进行展开。 基于HUGO的本地博客 定制本地博客 使用GitHub展示博客内容 3 基于HUGO的本地博客 想要在本地搭建一个基于HUGO的博客，大致有如下三步。 安装hugo 获取一个hugo主题 启动hugo 第一步，安装hugo。 前往hugo的github仓库获取对应操作系统的hugo执行程序。 完成之后打开cmd终端，输入hugo version，如能正确显示hugo的版本即为安装成功。 hugo安装成功 安装成功后在cmd终端执行如下命令，在D盘生成hugo博客站点MyBlog。 hugo new site D:\\MyBlog 第二步，获取HUGO主题。 hugo的主题是博客的门面，博客的风格和样式都基于主题。如果有前端编程的能力，也可以自行设计属于自己的主题，或者前往hugo主题商店下载现成的主题。这里以LoveIt 主题为例。 点击Download前往LoveIt的github仓库进行下载。 下载LoveIt主题 下载LoveIt主题 将下载好的压缩包解压到D:\\MyBlog\\themes目录下，并将目录重命名为LoveIt。 将D:\\MyBlog\\themes\\LoveIt\\exampleSite\\zh目录下的所有文件和D:\\MyBlog\\themes\\LoveIt\\exampleSite\\static目录复制到D:\\MyBlog\\目录下。 zh目录：LoveIt主题的中文配置及界面内容 zh\\config.toml：LoveIt主题的集中配置文件 zh\\content目录：LoveIt主题的默认页面内容 static目录：LoveIt主题的图包 使用Notepad++或其他文本编辑工具打开config.toml文件，将 staticDir = [\"../static\", “../../assets/others”] 改成staticDir = [\"/static\", “../assets/others”]。 第三步，启动本地博客。 在cmd终端执行如下命令，启动监听。 hugo server -D --config D:\\MyBlog\\config.toml 在浏览器访问URL:localhost:1313，可以查看本地博客。 下载LoveIt主题 4 定制本地博客 定制一个充满个人元素的博客大概分为如下三步。 个性化的博客标题和个人介绍 个性化的头像和图标 个性化的博客内容 第一步，定制个人的博客标题和介绍。 关于如何修改博客的标题等，D:\\MyBlog\\config.toml文件内作者有非常完善的注释，大家多修改多尝试（先备份），这里不细讲。 第二步，个性化头像和图标。 点击Favicon Generator，打开Select your Favicon image上传一张你喜欢的图片。 Favicon Generator生成图标 上传之后成功之后来到页面最下方点击Generate your Favicons and HTML code，Favicon Generator会自动分辨率生成符合一系列PC和移动终端的图标。 Favicon Generator生成图标 点击Favicon package下载生成好的图标包。 Favicon Generator下载图标 将下载好的图标包解压，把里面的文件全部复制到D:\\MyBlog\\static\\目录下。 如果想要替换主页的头像图标，需要替换D:\\MyBlog\\static\\images\\avatar.png，推荐分辨率为528*560。 最后整体效果如下图所示。 博客展示 第三步，个性化的博客内容。 博客的最终目的是展示内容，hugo能非常方便的根据文章的设定生成标签(tags)和分类(categories)。下面教大家如何设置文章的模板。 设置博客文章的模板 LoveIt主题中作者已经写好了一个文章模板，这里直接套用这个模板进行修改即可。 首先将D:\\MyBlog\\themes\\LoveIt\\archetypesdefault.md文件复制到D:\\MyBlog\\archetypes目录下，使用VsCode等markdown编辑工具打开。 模板文件 生成一篇博客文章 打开cmd终端，执行如下命令，根据文章模板生成第一篇文章。 # 进入D盘 D: # 进入MyBlog目录 cd MyBlog # 生成博客文章，文章会生成在content/posts目录下 hugo new posts/我的第一篇博客.md # 启动hugo，开启监听 hugo server -D --config D:\\MyBlog\\config.toml 再次访问URL:localhost:1313即可看到刚刚添加的文章。 5 用GitHub展示博客文章 让GitHub仓库展示博客页面，大致有如下四步。 创建一个GitHub账号 创建一个同名仓库 hugo build生成页面 推送到GitHub远程仓库 第一步，创建一个GitHub账号。 网上有很多教程，不再赘述。 第二步，创建一个同名仓库 网上也有很多教程，只强调一点，仓库名称为username.github.io。如：你的用户名叫zhangsan000，则你的仓库名必须为zhangsan000.github.io。 GitHub仓库 第三步，hugo生成静态页面。 打开cmd终端，执行如下命令，生成静态页面。 # 进入D盘 D: # 进入MyBlog目录 cd MyBlog # 生成静态页面 hugo hugo生成静态页面之后在MyBlog目录下会生成public目录存放静态页面。 将静态页面推送到GitHub 打开cmd终端，将GitHub仓库clone到本地。 # 查看git是否正常安装，能正常显示git版本即为安装正确 git version D: cd MyBlog/pubilc # 将你的仓库clone下来 git clone repoURL 然后将所有文件移动到clone下来的仓库目录下，再次打开cmd终端，输入如下命令，将静态页面推送到远程仓库。 D: # 进入git本地仓库 cd MyBlog\\public\\\u003c你的仓库目录\u003e # 将所有的文件添加到本地暂存区 git add . # 提交暂存区的内容 git commit -m 'init MyBlog' # 将本地提交推送到远程 git push 在GitHub上查看提交。 GitHub仓库 最后在浏览器上访问URL:\u003c仓库名称\u003e.github.io即可通过网络访问到静态页面。 GitHub仓库 ","date":"2020-02-15","objectID":"/%E5%9F%BA%E4%BA%8Ehugo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["hugo","分享"],"title":"基于Hugo快速搭建个人博客","uri":"/%E5%9F%BA%E4%BA%8Ehugo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"Hts0000的个人博客 主要分享如下内容 Linux运维 网络基础 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About LoveIt","uri":"/about/"}]