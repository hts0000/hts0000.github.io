[{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 双指针 双指针算法一般有两种场景： 两个指针分别指向两个不同的集合 两个指针指向同一个集合，本质是维护该集合上的一段区间 双指针一般用于将暴力穷举O(n^2)的算法，优化到O(n)。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:0:0","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 package main import ( \"fmt\" ) func main() { var n int fmt.Scan(\u0026n) nums := make([]int, n) for i := 0; i \u003c n; i++ { fmt.Scan(\u0026nums[i]) } m := make([]int, 1e5 + 10) ans := 0 for i, j := 0, 0; i \u003c n; i++ { m[nums[i]]++ for m[nums[i]] \u003e 1 { m[nums[j]]-- j++ } ans = max(ans, i - j + 1) } fmt.Print(ans) } func max(a, b int) int { if a \u003e b { return a } return b } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:0:1","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"经典模板题 799. 最长连续不重复子序列 800. 数组元素的目标和 3. 无重复字符的最长子串 2816. 判断子序列 位运算 常用的位运算操作： 取出n的二进制表示下第k位是多少——(n\u003e\u003ek)\u00261 返回n的二进制表示下最后一位1，也叫lowbit操作——n\u0026-n ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:0:2","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"取出第k位 用0表示第一位。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:1:0","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 package main import \"fmt\" func main() { n := 10 for k := 3; k \u003e= 0; k-- { fmt.Print(n\u003e\u003ek\u00261) } } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:1:1","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"lowbit 公式为：x \u0026 -x。 原理为： 负数在计算机中使用补码的方式表示，因此-x = ^x + 1，当x取反之后，x的最后的1会变成0，而最后的1后面的0会变成1，再加上1的话，会进位一直到最后的1处。因此-x的二进制表达形——最后一个1前与x全部取反，最后一个1及后面全部一致，然后x \u0026 -x就会得到最后一个1及后面的0组成的二进制数。 一般形式： x = 0b(10101010000) ^x = 0b(01010101111) ^x + 1 = 0b(01010110000) 计算过程： x \u0026 -x = 0b(10101010000) \u0026 \\ 0b(01010110000) = 0b(00000010000) lowbit的用处有很多，常见的有：快速计算一个数有多少个位为1。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:0","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 package main import \"fmt\" // 计算二进制表示中1的个数 func main() { var n int fmt.Scan(\u0026n) for i := 0; i \u003c n; i++ { var num, res int fmt.Scan(\u0026num) for num \u003e 0 { num -= lowbit(num) res++ } fmt.Printf(\"%d \", res) } } func lowbit(x int) int { return x \u0026 -x } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:1","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"经典模板题 801. 二进制中1的个数 191. 位1的个数 离散化 这里单独指整数离散化。离散化是指将一个稀疏的区间离散到一个紧凑的区间中。比如有一个区间范围为[-10^9 ~ 10^9]，但是里面只有的数只有10^5范围，那么显然这个区间是稀疏的，有很多重复或空的值。离散化就是把这个稀疏空间映射到紧凑空间上，降低操作的时空间复杂度。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:2","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 func main() { // 存储所有需要操作的下标 alls := make([]int, 0, N) // 对所有需要操作的下标排序去重 quickSort(\u0026alls, 0, len(alls) - 1) alls = unique(alls) // 二分求出离散化后的值 find(alls, x) } func unique(a []int) []int { j := 0 for i := 0; i \u003c len(a); i++ { if i == 0 || a[i] != a[i - 1] { a[j] = a[i] j++ } } // 不应该直接返回a的切片，这样会导致底层大数组的引用没有消失，gc就无法回收 // return a[:j] // 返回一个新开辟的切片，底层数组不同，gc可以将a回收掉 temp := make([]int, j) copy(temp, a[:j]) return temp } func find(a []int, x int) int { l, r := 0, len(a) - 1 for l \u003c r { mid := (l + r) \u003e\u003e 1 if a[mid] \u003e= x { r = mid } else { l = mid + 1 } } return r + 1 } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:3","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"经典模板题 802. 区间和 区间合并 合并满足某种条件的区间，本质是贪心算法。 经典例题是合并有交集的区间，排序后判断左右端点重合则重新维护最小和最大端点。 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:4","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"代码模板 func merge(segs []pair) []pair { // 首先从小到大排序区间 sort.Slice(segs, func(i, j int) bool { return segs[i].first \u003c segs[j].first }) temp := make([]pair, 0) // 赋予开始和结束端点最小值，避免重复 var st, ed int = math.MinInt64, math.MinInt64 // 遍历所有区间 for _, seg := range segs { // 当有区间与开始和结束端点重叠时，更新最大结束端点 if seg.first \u003c= ed { ed = max(ed, seg.second) // 如果没有重叠，说明是一个新区间，更新开始和结束端点 } else { // 避免重复 if st != math.MinInt64 { temp = append(temp, pair{st, ed}) } st = seg.first ed = seg.second } } // 避免重复，再加入最后一个区间 if st != math.MinInt64 { temp = append(temp, pair{st, ed}) } return temp } ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:5","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","双指针","位运算","离散化","区间合并"],"content":"经典模板题 803. 区间合并 56. 合并区间 ","date":"2022-09-19","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/:2:6","tags":["算法","算法整理","双指针","位运算","离散化","区间合并"],"title":"基础算法整理(三)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%89/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 高精度 高精度是指，不能直接用一个变量来存储的数据，这种数据有几千位甚至几万位。存储这种数据必须使用数组。高精度运算就是为这种数据做算术运算。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:0:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"1.1 大整数相加 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:1:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import \"fmt\" func main() { a, b := \"\", \"\" fmt.Scanf(\"%s\", \u0026a) fmt.Scanf(\"%s\", \u0026b) A := make([]int, 0, len(a)) B := make([]int, 0, len(b)) for i := len(a) - 1; i \u003e= 0; i-- { A = append(A, int(a[i] - '0')) } for i := len(b) - 1; i \u003e= 0; i-- { B = append(B, int(b[i] - '0')) } C := add(A, B) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } } // C = A + B func add(A, B []int) (C []int) { t := 0 for i := 0; i \u003c len(A) || i \u003c len(B); i++ { if i \u003c len(A) { t += A[i] } if i \u003c len(B) { t += B[i] } C = append(C, t % 10) t /= 10 } if t == 1 { C = append(C, 1) } return C } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:1:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 791. 高精度加法 剑指 Offer II 025. 链表中的两数相加 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:1:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"1.2 大整数相减 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:2:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import \"fmt\" func main() { var a, b string fmt.Scanf(\"%s\", \u0026a) fmt.Scanf(\"%s\", \u0026b) A := make([]int, 0, len(a)) B := make([]int, 0, len(b)) for i := len(a) - 1; i \u003e= 0; i-- { A = append(A, int(a[i] - '0')) } for i := len(b) - 1; i \u003e= 0; i-- { B = append(B, int(b[i] - '0')) } if cmp(A, B) { C := sub(A, B) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } } else { // A \u003c B 的情况，要加上负号 fmt.Print(\"-\") C := sub(B, A) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } } } // 判断是否有 A \u003e= B func cmp(A, B []int) bool { if len(A) != len(B) { return len(A) \u003e len(B) } for i := len(A) - 1; i \u003e= 0; i-- { if A[i] != B[i] { return A[i] \u003e B[i] } } return true } // C = A - B // 应该保证 A \u003e= B func sub(A, B []int) (C []int) { t := 0 for i := 0; i \u003c len(A); i++ { t = A[i] - t if i \u003c len(B) { t -= B[i] } // 考虑了需要进位和不需要进位的情况 C = append(C, (t + 10) % 10) if t \u003c 0 { t = 1 } else { t = 0 } } // 去除前导零 for len(C) \u003e 1 \u0026\u0026 C[len(C) - 1] == 0 { C = C[:len(C) - 1] } return C } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:2:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 792. 高精度减法 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:2:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"1.3 大整数乘法 一个高精度的正整数A，乘上一个低精度的正整数b。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:3:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import \"fmt\" func main() { var a string var b int fmt.Scanf(\"%s\", \u0026a) fmt.Scanf(\"%d\", \u0026b) if b == 0 { fmt.Print(0) } else { A := make([]int, 0, len(a)) for i := len(a) - 1; i \u003e= 0; i-- { A = append(A, int(a[i] - '0')) } C := mul(A, b) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } } } // C = A * b // 0 \u003c= b \u003c= 10000 func mul(A []int, b int) (C []int) { for i, t := 0, 0; i \u003c len(A) || t \u003e 0; i++ { if i \u003c len(A) { t += A[i] * b } C = append(C, t % 10) t /= 10 } return C } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:3:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 793. 高精度乘法 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:3:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"1.4 大整数除法 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:4:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import \"fmt\" func main() { var a string var b int fmt.Scanf(\"%s\", \u0026a) fmt.Scanf(\"%d\", \u0026b) A := make([]int, 0, len(a)) for i := len(a) - 1; i \u003e= 0; i-- { A = append(A, int(a[i] - '0')) } C, r := div(A, b) for i := len(C) - 1; i \u003e= 0; i-- { fmt.Print(C[i]) } fmt.Printf(\"\\n%d\", r) } // C = A / b, r = A % b // 1 \u003c= b \u003c= 10000 func div(A []int, b int) (C []int, r int) { // 高精度除法需要从最高位开始处理， // 与其他算术运算不同 for i := len(A) - 1; i \u003e= 0 ; i-- { r = r * 10 + A[i] C = append(C, r / b) r %= b } // 反转C，与其他算术运算输出逻辑保持一致 reverse(C, 0, len(C) - 1) // 去除前导零 for len(C) \u003e 1 \u0026\u0026 C[len(C) - 1] == 0 { C = C[:len(C) - 1] } return C, r } func reverse(a []int, l, r int) { for l \u003c r { a[l], a[r] = a[r], a[l] l++; r-- } } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:4:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 794. 高精度除法 前缀和与差分 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:4:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"一维前缀和 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"什么是前缀和？ 设有长度为n的原数组a，则其前缀和si为原数组前i项的和——si=a1+a2+...+ai，当i=0时，s0=0。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"如何求前缀和数组？ 从前往后遍历原数组，s[i]=s[i-1]+a[i]。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"前缀和的作用 前缀和一般用来在O(1)时间复杂度内求解区间和。比如求解原数组a[3]~a[10]的区间和，用前缀和求解为s[10]-s[2]。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:3","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 100010 var a[N]int var b[N]int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n, m int fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026a[i]) } for i := 1; i \u003c= n; i++ { b[i] = b[i - 1] + a[i] } for ; m \u003e 0; m-- { var l, r int fmt.Fscan(in, \u0026l, \u0026r) fmt.Fprintln(out, b[r] - b[l-1]) } } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:4","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 795. 前缀和 303. 区域和检索 - 数组不可变 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:5:5","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"二维前缀和 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:6:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() const N int = 1010 var a, s [N][N]int var n, m, q int fmt.Fscan(in, \u0026n, \u0026m, \u0026q) for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { fmt.Fscan(in, \u0026a[i][j]) } } for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { // 求前缀和 s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j] } } for ; q \u003e 0; q-- { var x1, y1, x2, y2 int fmt.Fscan(in, \u0026x1, \u0026y1, \u0026x2, \u0026y2) // 求子矩阵的和 fmt.Fprintln(out, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]) } } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:6:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 796. 子矩阵的和 304. 二维区域和检索 - 矩阵不可变 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:6:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"一维差分 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"什么是差分？ 差分是前缀和的逆运算，对一个差分数组求前缀和，得到原数组。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"如何求差分数组？ 构造这样一个数据，对于原数组a而言，差分数组b中每一个元素，都等于b[i] = a[i] - a[i-1]，其中b[1] = a[1]。 这样构造完之后，我们对其求前缀和可以发现，得到的答案就是原数组。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"差分的作用 差分数组用于解决区间加值的问题。比如给区间[l:r]中每一个数都加上C，利用差分数组可以在O(1)时间复杂度完成。 实现过程为，在差分数组b[l]处加上C，在b[r+1]处减去C，这样在还原为原数组时，区间[l:r]就施加上C的影响，在[r+1:n]减去C的影响。 公式为：b[l] += C; b[r+1] -= C。 图例——为[4:7]这个区间加上3。 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:3","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N = 100010 var a [N]int var b [N]int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n, m int fmt.Fscan(in, \u0026n, \u0026m) for i := 1; i \u003c= n; i++ { fmt.Fscan(in, \u0026a[i]) insert(i, i, a[i]) } for ; m \u003e 0; m-- { var l, r, c int fmt.Fscan(in, \u0026l, \u0026r, \u0026c) insert(l, r, c) } for i := 1; i \u003c= n; i++ { b[i] += b[i-1] fmt.Fprintf(out, \"%d \", b[i]) } } func insert(l, r, c int) { b[l] += c b[r+1] -= c } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:4","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 797. 差分 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:7:5","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"二维差分 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:8:0","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"代码模板 package main import ( \"fmt\" \"bufio\" \"os\" ) const N int = 1010 var a [N][N]int var b [N][N]int func main() { in := bufio.NewReader(os.Stdin) out := bufio.NewWriter(os.Stdout) defer out.Flush() var n, m, q int fmt.Fscan(in, \u0026n, \u0026m, \u0026q) // 读取原数组数据，并构建差分数组 for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { fmt.Fscan(in, \u0026a[i][j]) insert(i, j, i, j, a[i][j]) } } // q次矩阵增加c值操作 for ; q \u003e 0; q-- { var x1, y1, x2, y2, c int fmt.Fscan(in, \u0026x1, \u0026y1, \u0026x2, \u0026y2, \u0026c) insert(x1, y1, x2, y2, c) } // 构建二维前缀和数组 for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1] } } // q次矩阵增加c之后的答案输出 for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { fmt.Fprintf(out, \"%d \", b[i][j]) } fmt.Fprintln(out) } } func insert(x1, y1, x2, y2, c int) { b[x1][y1] += c b[x2+1][y1] -= c b[x1][y2+1] -= c b[x2+1][y2+1] += c } ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:8:1","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","高精度","二分","前缀和","差分"],"content":"经典模板题 798. 差分矩阵 ","date":"2022-09-15","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/:8:2","tags":["算法","算法整理","高精度","二分","前缀和","差分"],"title":"基础算法整理(二)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%BA%8C/"},{"categories":["算法","算法整理","排序","二分"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 1. 排序 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:0:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"1.1 快速排序 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:1:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"代码模板 func sortArray(nums []int) []int { qucikSort(nums, 0, len(nums) - 1) return nums } func qucikSort(nums []int, l, r int) { if l \u003e= r { return } pivot := nums[(l + r) / 2] i, j := l - 1, r + 1 for i \u003c j { for i++; nums[i] \u003c pivot; i++ {} for j--; nums[j] \u003e pivot; j-- {} if i \u003c j { nums[i], nums[j] = nums[j], nums[i] } } qucikSort(nums, l, j) qucikSort(nums, j + 1, r) } ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:1:1","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"经典模板题 912. 排序数组 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:1:2","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"1.2 归并排序 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:2:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"代码模板 递归版 func sortArray(nums []int) []int { mergeSort(nums, 0, len(nums) - 1) return nums } func mergeSort(nums []int, left, right int) { if left \u003e= right { return } mid := (left + right) \u003e\u003e 1 mergeSort(nums, left, mid) mergeSort(nums, mid + 1, right) temp := merge(nums[left:mid+1], nums[mid+1:right+1]) copy(nums[left:], temp) } func merge(left, right []int) []int { temp := make([]int, len(left) + len(right)) i, j, k := 0, 0, 0 for i \u003c len(left) || j \u003c len(right) { if i \u003e= len(left) { copy(temp[k:], right[j:]) return temp } if j \u003e= len(right) { copy(temp[k:], left[i:]) return temp } if left[i] \u003c= right[j] { temp[k] = left[i] k++; i++ } else { temp[k] = right[j] k++; j++ } } return temp } 迭代版 func sortArray(nums []int) []int { mergeSort(nums) return nums } func mergeSort(nums []int) { for step := 1; step \u003c len(nums); step += step { for i := 0; i + step \u003c len(nums); i += 2 * step { temp := merge(nums[i:i+step], nums[i+step:min(i+2*step, len(nums))]) copy(nums[i:], temp) } } } func merge(left, right []int) []int { temp := make([]int, len(left) + len(right)) i, j, k := 0, 0, 0 for i \u003c len(left) || j \u003c len(right) { if i \u003e= len(left) { copy(temp[k:], right[j:]) break } if j \u003e= len(right) { copy(temp[k:], left[i:]) break } if left[i] \u003c= right[j] { temp[k] = left[i] k++; i++ } else { temp[k] = right[j] k++; j++ } } return temp } func min(a, b int) int { if a \u003c b { return a } return b } ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:2:1","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"经典模板题 912. 排序数组 剑指 Offer 51. 数组中的逆序对 2. 二分 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:2:2","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"2.1 整数二分 二分的本质是将一个区间分为两块，一块满足要求，另一块不满足要求，然后就可以寻找这两块区间的边界。 每次缩小的时候，都要确保剩余区间内有答案。 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:3:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"代码模板 寻找左边界 func bsearch(nums []int, target int) int { if len(nums) == 0 { return -1 } l, r := 0, len(nums) - 1 for l \u003c r { mid := (l + r) \u003e\u003e 1 if nums[mid] \u003e= target { r = mid } else { l = mid + 1 } } if nums[l] != target { return -1 } return l } 寻找右边界 func bsearch(nums []int, target int) int { if len(nums) == 0 { return -1 } l, r := 0, len(nums) - 1 for l \u003c r { mid := (l + r + 1) \u003e\u003e 1 if nums[mid] \u003c= target { l = mid } else { r = mid - 1 } } if nums[r] != target { return -1 } return r } ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:3:1","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"经典模板题 704. 二分查找 34. 在排序数组中查找元素的第一个和最后一个位置 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:3:2","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"2.2 浮点数二分 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:4:0","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"代码模板 func mySqrt() { var x float64 fmt.Scanf(\"%f\", \u0026x) var l, r float64 = 0, x for r - l \u003e 1e-8 { mid := (l + r) / 2 if mid * mid \u003e= x { r = mid } else { l = mid } } fmt.Printf(\"%f\", l) } ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:4:1","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","算法整理","排序","二分"],"content":"经典模板题 69. x 的平方根 790. 数的三次方根 ","date":"2022-09-12","objectID":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/:4:2","tags":["算法","算法整理","排序","二分"],"title":"基础算法整理(一)","uri":"/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%80/"},{"categories":["算法","树状数组"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 参考 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:0:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"树状数组是什么？ 树状数组，或称Binary Indexed Tree, Fenwick Tree，是一种用于高效处理对一个存储数字的列表进行更新及求前缀和的数据结构。 树状数组所能解决的典型问题就是存在一个长度为n的数组，我们如何高效进行如下操作： update(idx, delta)：将num加到位置idx的数字上。 prefixSum(idx)：求从数组第一个位置到第idx（含idx）个位置所有数字的和。 rangeSum(from_idx, to_idx)：求从数组第from_idx个位置到第to_idx个位置的所有数字的和 如果用暴力求解数组区间和，时间复杂度为O(n)，更新数组值为O(1)。 // [left,right] func rangeSum(left, right int) int { // 时间复杂度O(n)，与for left\u003c= right 没有数量级上的差距 return sum(right) - sum(left - 1) } // [0,index] func sum(index int) int { if index \u003c 0 || index \u003e= len(nums) { return 0 } sum := 0 for i := index; i \u003e= 0; i-- { sum += nums[i] } return sum } // O(1) func update(index, delta int) { nums[index] += delta } 用前缀和求解区间和的时间复杂度为O(1)，更新数组值为O(n) type Presum struct { nums []int } func NewPreSum(nums []int) Presum { pre := make([]int, len(nums)) pre[0] = nums[0] for i := 1; i \u003c len(nums); i++ { pre[i] = pre[i-1] + nums[i] } return Presum{ nums: pre, } } func (p *Presum) Update(index, val int) { // O(n) for i := index; i \u003c len(p.nums); i++ { p.nums[i] += val } } func (p *Presum) SumRange(left, right int) int { // O(1) return p.nums[right] - p.nums[left-1] } 树状数组求解区间和的时间复杂度为O(logn)，更新数组值为O(logn)。因为修改值之后需要重新维护树状数组。 type BinaryIndTree struct { Nums []int Tree []int } func NewBinaryIndTree(nums []int) BinaryIndTree { // 用前缀和快速构造树状数组 length := len(nums) tree := make([]int, length+1) preSum := make([]int, length+1) for i := 1; i \u003c= length; i++ { preSum[i] = preSum[i-1] + nums[i-1] tree[i] = preSum[i] - preSum[i-lowbit(i)] } return BinaryIndTree{ Nums: nums, Tree: tree, } } func lowbit(i int) int { return i \u0026 (-i) } func (b *BinaryIndTree) Add(index, delta int) { // O(logn) for i := index; i \u003c len(b.Tree); i += lowbit(i) { b.Tree[i] += delta } } func (b *BinaryIndTree) Update(index, val int) { b.Add(index+1, val-b.Nums[index]) b.Nums[index] = val } func (b *BinaryIndTree) Sum(index int) int { sum := 0 // O(logn) for i := index; i \u003e 0; i -= lowbit(i) { sum += b.Tree[i] } return sum } func (b *BinaryIndTree) SumRange(left, right int) int { return b.Sum(right+1) - b.Sum(left) } 树状数组适用于对数组查询和修改都有性能要求的场景。 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:1:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"树状数组如何高效？ 看上面这张图，可以把树状数组想象成一棵树。所有奇数下标的都是独立子节点。子节点通过i+lowbit(i)来找到其父节点，父节点存储的就是它和它所有子节点的和。通过这样一棵树，我们可以用O(logn)的时间复杂度来获得一个区间的和。 为了方便表示，tree被画成了不连续的样子，实际上tree在内存中仍是连续的数组。 下面这样图可以比较容易理解树状数组在更新节点值时，如何知道那些节点值是应该更新的。 比如我们要对下标i的值进行更新，除了对i本身，还有其上面覆盖了i(或者说管辖i)的所有节点进行更新。比如i=1，则需要更新的节点为1、2、4、8 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:2:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"lowbit原理 lowbit(i)用一句话来解释就是——截断i在二进制表示中最低位1前面的数。 比如：i=6=b(110)，截断最低位1前面的数得到b(10)=2 lowbit实现很简单 func lowbit(i int) int { // return i \u0026 ((~i)+1) 两者等价 return i \u0026 (-i) } 为什么\u0026上自己的负数可以截断最低位1前面的数呢？因为负数在计算机中是用补码来表示的，所以我们需要对补码、原码有一些了解。 原码：用最高位表示符号位，如int8(-8) = 原(10001000) 补码：对原码除符号位之外的所有位取反并加1，如int8(-8) = 补(11111000) 反码：对原码除符号位之外的所有位取反，如int8(-8) = 反(11110111) 这里我们以6和-6为例，假设他们都是有符号的8位数。 可以发现一个数的正数与负数，它们除了最低位的1及后面的数之外，每一位的数都不相同，因此它们相\u0026可以得到我们想要的结果——截断i在二进制表示中最低位1前面的数。 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:2:1","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"树状数组功能一览 根据节点维护的数据含义不同，树状数组可以提供不同的功能来满足各种区间场景。 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"1. 单点增减+区间求和 LeetCode-307. 区域和检索 - 数组可修改 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:1","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"2. 区间增减+单点查询 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:2","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"3. 区间增减+区间求和 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:3","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"4. 单点增减+区间最值 HDU-1754 I Hate It ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:4","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"5. 区间叠加+单点最值 LeetCode-218. 天际线问题 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:3:5","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"树状数组常见应用 求逆序对 求区间逆序对 求树上逆序对 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:4:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"二维树状数组 ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:5:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","树状数组"],"content":"完整代码 type BinaryIndTree struct { Nums []int Tree []int } func NewBinaryIndTree(nums []int) BinaryIndTree { // 用前缀和快速构造树状数组 length := len(nums) tree := make([]int, length+1) preSum := make([]int, length+1) for i := 1; i \u003c= length; i++ { preSum[i] = preSum[i-1] + nums[i-1] tree[i] = preSum[i] - preSum[i-lowbit(i)] } return BinaryIndTree{ Nums: nums, Tree: tree, } } func (b *BinaryIndTree) update(index, delta int) { for i := index; i \u003c len(b.Tree); i += lowbit(i) { b.Tree[i] += delta } } func (b *BinaryIndTree) Update(index, val int) { b.update(index+1, val-b.Nums[index]) b.Nums[index] = val } func (b *BinaryIndTree) Sum(index int) int { sum := 0 for i := index; i \u003e 0; i -= lowbit(i) { sum += b.Tree[i] } return sum } func (b *BinaryIndTree) SumRange(left, right int) int { return b.Sum(right+1) - b.Sum(left) } func lowbit(i int) int { return i \u0026 (-i) } ","date":"2022-04-04","objectID":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/:6:0","tags":["算法","树状数组"],"title":"树状数组","uri":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"categories":["算法","查找算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:0","tags":["算法","查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法","查找算法"],"content":"二分查找 对于任何有序集合，我们可以使用二分查找的方式来快速定位到想要的元素。 二分查找的时间复杂度为O(logn) 二分查找的实现难点在于边界条件的判断，要注意集合的闭合区间。实现时闭合区间分为两种：[left,right]和[left,right)，两种不同的闭合区间的代码实现也不同。 ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:0","tags":["算法","查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法","查找算法"],"content":"二分查找的边界条件 [left,right] // BinarySearch 查找nums中是否存在target，并返回其下标，如果不存在返回-1 func BinarySearch(nums []int, target int) int { length := len(nums) left, right := 0, length - 1 for left \u003c= right { mid := left + (right - left) / 2 if nums[mid] \u003c target { left = mid + 1 } else if nums[mid] \u003e target { right = mid - 1 } else { return mid } } return -1 } [left,right) // BinarySearch 查找nums中是否存在target，并返回其下标，如果不存在返回-1 func BinarySearch(nums []int, target int) int { length := len(nums) left, right := 0, length for left \u003c right { mid := left + (right - left) / 2 if nums[mid] \u003c target { left = mid + 1 } else if nums[mid] \u003e target { right = mid } else { return mid } } return -1 } ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:1","tags":["算法","查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法","查找算法"],"content":"二分查找其他应用 二分查找不仅可以用于有序序列，还可以用于部分有序序列，比如leetcode 153.寻找旋转排序数组中的最小值也可以使用二分法。 由此我们可知，二分查找只是一种查找的思想。对于查找一个值，我们要首先想到如何能跳过一些无意义的比较，收缩左右边界，以达到加快搜索的过程。 ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:2","tags":["算法","查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法","回溯"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:0","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","回溯"],"content":"回溯 回溯就是暴力穷举，对于一些组合、切割、求子集、n皇后等问题，只能使用暴力穷举的方式遍历所有可能性求解。 回溯用于解决n层for循环的问题 对于一个长度为n的序列，要求出它所有的子集，需要写出n层for循环。因为序列长度n未知，所以连用for暴力穷举的代码都写不出来。 这是就要用到回溯，通过递归的方式，不断深入，开启n层for循环。 n层递归的循环，就像是一颗树，循环的次数是树的宽度，递归的次数是树的深度 ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:1","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","回溯"],"content":"回溯模板 func demo() { // 存放结果 res := make([]int, 0) // 存放临时结果 path := make([]int, 0) // 回溯函数的参数很难提前确定 // 一般在写具体实现是根据需要补上 var backTracking func(所需参数) backTracking = func(所需参数) { if 满足要求 { // 新申请内存空间，避免底层数组一致 res = append(res, append([]int{}, path...)...) return } for 遍历序列 { path = append(添加临时结果) backTracking(所需参数) path = path[:len(path)-1] } } } ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:2","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","回溯"],"content":"回溯的去重 去重首先需要序列有序，然后在for循环内部判断当前元素与前一元素是否相同，如果相同就continue ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:3","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","回溯"],"content":"标识当前元素已被使用 used := make([]bool, length) backTracking = func() { for i := 0; i \u003c len(nums); i++ { if used[i] { continue } used[i] = true ... backTracking() used[i] = false ... } } ","date":"2022-03-02","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:4","tags":["算法","回溯"],"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法","树"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 树的遍历方式分为如下几种： 前序遍历 中序遍历 后序遍历 层序遍历 其中前序遍历可以求出树的深度，而后序遍历可以求出树的高度 树的遍历也可以借用辅助数据结构来完成： 栈 队列 栈适合模拟前中后序遍历，队列适合模拟层序遍历 ","date":"2022-02-21","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/:0:0","tags":["算法","树"],"title":"树的递归遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"categories":["算法","树"],"content":"前序遍历求深度 func maxDepth(root *TreeNode) int { if root == nil { return 0 } leftDepth := maxDepth(root.Left) rightDepth := maxDepth(root.Right) return max(leftDepth, rightDepth) + 1 } ","date":"2022-02-21","objectID":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/:0:1","tags":["算法","树"],"title":"树的递归遍历","uri":"/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"categories":["bit数组","bitmap"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 什么是bit数组？ bit数组通常为一个无符号数的数组，用每一个元素的每一个bit位来存储数据。 var bitSlice []uint64{0, 0, 0} bit数组 当我们存储数据，比如存储2时，对64取商和模为0和2，可知需要将2存储在bitSlice[0]的第2个bit位中，因此我们把bitSlice[0] \u0026 1\u003c\u003c2即可标识2被存储了 把2存储到bitSlice中 对于更大的数字，比如66，对64取商和模为1和2，可知需要将66存储在bitSlice[1]的第2个bit位中，因此我们把bitSlice[1] \u0026 1\u003c\u003c2即可标识66被存储了 把66存储到bitSlice中 bit数组有什么用？ bit数组可以使用很小的存储空间，存储更多的数据。对于uint64而言，如果直接存储，一个数要使用8byte空间，64个数则要64*8byte=512byte，而用bit来存，一个uint64的变量可以存储64个数，空间节省了64倍。 如果我们要对40亿条数据进行排序去重，但机器可用内存只有4G，要怎么做呢？ 我们先来计算一下，4,000,000,000对64取商和模为62,500,000和0，可知数组最大需要62,500,000个元素，而62,500,000 * 8byte = 500,000,000byte ≈ 480M 如果用[]uint32切片直接存储，则需要4,000,000,000 * 4byte = 16,000,000,000byte ≈ 15G 使用bit数组，存储时只会将数所在的bit位 置1，所以只要按顺序取出数据，就是排序去重后的数据。 bit数组应用 bit数组在很多地方都有应用，比如redis中的bitmap就是使用了bit数组的方式实现的。 bit数组实现 package bitmap import ( \"bytes\" \"fmt\" ) // 参考go语言圣经6.5章节 // UINTSIZE 判断当前机器是32位还是64位 // 64位机器^uint(0) = 64位全1，\u003e\u003e 63之后变成只有第一位为1，32 \u003c\u003c 1 = 64 // 32位机器\u003e\u003e 63之后全部位变为0，32 \u003c\u003c 0 = 32 const UINTSIZE = 32 \u003c\u003c (^uint(0) \u003e\u003e 63) // An IntSet is a set of small non-negative integers. // Its zero value represents the empty set. type IntSet struct { words []uint } // Has reports whether the set contains the non-negative value x. func (s *IntSet) Has(x int) bool { word, bit := x/UINTSIZE, uint(x%UINTSIZE) // words长度大于数据所在元素下标，且所在bit位不为0 return word \u003c len(s.words) \u0026\u0026 s.words[word]\u0026(1\u003c\u003cbit) != 0 } // Add adds the non-negative value x to the set. func (s *IntSet) Add(x int) { // 对要存储的数取商和模 word, bit := x/UINTSIZE, uint(x%UINTSIZE) // 如果words数组长度小于商，则扩容至能存下为止 for word \u003e= len(s.words) { s.words = append(s.words, 0) } // 将数存储到指定bit位 s.words[word] |= 1 \u003c\u003c bit } // UnionWith sets s to the union of s and t. // 设置s为s和t的并集 func (s *IntSet) UnionWith(t *IntSet) { for i, tword := range t.words { if i \u003c len(s.words) { // 取并集 // 101 | 010 = 111 s.words[i] |= tword } else { s.words = append(s.words, tword) } } } // IntersectWith sets s to the intersect of s and t // 设置s为s和t的交集 // 元素在s集合t集合均出现 func (s *IntSet) IntersectWith(t *IntSet) { // 如果s比t长，把s截取到t的长度 if len(s.words) \u003e len(t.words) { s.words = s.words[:len(t.words)] } // 如果t比s长，也只会比较s中有的部分 for i, tword := range t.words { if i \u003c len(s.words) { s.words[i] \u0026= tword } } } // DifferenceWith sets s to the difference of s and t // 设置s为s和t的差集 // 元素出现在s集合，未出现在t集合 func (s *IntSet) DifferenceWith(t *IntSet) { for i, tword := range t.words { if i \u003c len(s.words) { // ^: 异或运算，值不同则为1，相同为0 // B A // 100011010 ^ 110101001 = 010110011 // 010110011 \u0026 110101001 = 010100001 // 正好是A中有而B中没有的 s.words[i] \u0026= s.words[i] ^ tword } } } // SymmetricDifference sets s to the symmetric difference of s and t // 设置s为s和t的并查集 // 元素出现在s但没有出现在t，或者出现在t没有出现在s func (s *IntSet) SymmetricDifference(t *IntSet) { for i, tword := range t.words { if i \u003c len(s.words) { s.words[i] ^= tword } else { // 如果s元素个数小于t，则s要把t中多的部分补上 s.words = append(s.words, tword) } } } // String returns the set as a string of the form \"{1 2 3}\". // String方法，fmt.Printf()函数对实现了String方法的类型会直接调用其String()方法进行输出 func (s *IntSet) String() string { var buf bytes.Buffer buf.WriteByte('{') for i, word := range s.words { if word == 0 { continue } // 逐位遍历，如果为1，则将其写入缓冲区 for j := 0; j \u003c UINTSIZE; j++ { if word\u0026(1\u003c\u003cuint(j)) != 0 { if buf.Len() \u003e len(\"{\") { buf.WriteByte(' ') } // UINTSIZE*i+j还原数实际大小 // 比如2存储在[0]的第2个比特位 // UINTSIZE*0+2=2 fmt.Fprintf(\u0026buf, \"%d\", UINTSIZE*i+j) } } } buf.WriteByte('}') return buf.String() } // Len return the number of elements // 返回当前存储了多少个数 func (s *IntSet) Len() int { l := 0 for _, word := range s.words { if word == 0 { continue } for j := 0; j \u003c UINTSIZE; j++ { if word\u0026(1\u003c\u003cuint(j)) != 0 { l++ } } } return l } // Elems returns a slice containing the elements of the set func (s *IntSet) Elems() []int { res := make([]int, s.Len()) k := 0 for i, word := range s.words { if word == 0 { continue } for j := 0; j \u003c UINTSIZE; j++ { if word\u0026(1\u003c\u003cj) != 0 { res[k] = UINTSIZE*i + j k++ } } } return res } // Remove remove x from the set // 删除指定数 func (s *IntSet) Remove(x int","date":"2022-02-15","objectID":"/bit%E6%95%B0%E7%BB%84/:0:0","tags":["bit数组","bitmap"],"title":"Bit数组/bitmap","uri":"/bit%E6%95%B0%E7%BB%84/"},{"categories":["算法","RK","字符串匹配算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 什么是RK算法？ RK算法是一种字符串匹配算法。核心思想是将字符串映射为其字符集长度的数值(hash值)，将字符串比较变为数值比较，从而可以获得较好的性能。需要注意的是，当hash相同时，字符串任然有小概率不相同，hash不同则不可能相同。 对于文本串s和模式串p，我们计算p的hash值，然后再计算s中长度为len(p)的所有子串的hash值，对比他们是否相同，如果相同还需再比较一次字符串是否相同。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:0:0","tags":["算法","RK","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","RK","字符串匹配算法"],"content":"什么是hash值？ 通过一个hash函数，将输入内容转化为数字，这个数字就是hash值。对于输入的内容相同，hash函数输出的值必须相同且应该尽量唯一。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:1:0","tags":["算法","RK","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","RK","字符串匹配算法"],"content":"如何计算字符串的hash值？ 对于一串数字字符串\"1234\"，我们可以把它看做是10进制数，通过计算:'1'*10^(4-1) + '2'*10^(4-2) + '3'*10^(4-3)+'4'*10^(4-4)将它hash为1234(10^2表示10的2次方,4为字符串长度)。 对于小写字母字符串\"abcd\"，我们可以把它看做是26进制数，通过计算:'a'*26^(4-1) + 'b'*26^(4-2) + 'c'*26^(4-3) + 'd'*26^(4-4)将它hash为19010(‘a’=1,‘b’=2,‘c’=3,’d’=4)。 对于大小写字符混合字符串\"AbCd\"，我们可以把它看做是128进制(ASCII码128个字符)，通过计算:'A'*128^(4-1) + 'b'*128^(4-2) + 'C'*128^(4-3) + 'd'*128^(4-4)，将它们hash为137,929,188(‘A’=65,‘b’=98,‘C’=67,’d’=100)。 通过上述例子可以发现，我们可以把一串字符hash为它们字符集进制的数，那么我们是否可以用Unicode字符集作为进制数？不就可以表示所有字符了？答案是可以的。Unicode字符集所有字符个数为1114112个。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:2:0","tags":["算法","RK","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","RK","字符串匹配算法"],"content":"如何使用hash进行字符串匹配？ 对于文本串s\"12345\"，我们希望知道模式串p\"45\"是否被s包含要如何做？ 以10进制为例。 首先对p进行hash，'4'*10+'5'=45，对s[0:2]进行hash，'1'*10+'2'=12，12不等于45，进行下一轮计算s[1:3]。下一轮计算难道又要'2'*10+'3'=23这样遍历s[1:3]的每一个字符吗？其实不用，我们可以把(12-10)*10+3，这意味着我们总共只需要遍历s串一次，而p串也是一次，这就是rk算法时间复杂度O(m+n)的原因。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:3:0","tags":["算法","RK","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","RK","字符串匹配算法"],"content":"常用的字符串hash函数 BKDRHash ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:4:0","tags":["算法","RK","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","RK","字符串匹配算法"],"content":"如何解决hash值相同但字符串不相同的情况 字符串hash难免出现hash值相同的情况，当相同时我们需要额外遍历一遍以确保相同。 Golang中的RK算法应用 // PrimeRK相当于我们上面提到的进制 const PrimeRK = 16777619 // HashStr returns the hash and the appropriate multiplicative // factor for use in Rabin-Karp algorithm. func HashStr(sep string) (uint32, uint32) { hash := uint32(0) for i := 0; i \u003c len(sep); i++ { // 将模式串hash为PrimeRK进制的数 hash = hash*PrimeRK + uint32(sep[i]) } // var pow, sq uint32 = 1, PrimeRK for i := len(sep); i \u003e 0; i \u003e\u003e= 1 { if i\u00261 != 0 { pow *= sq } sq *= sq } return hash, pow } // IndexRabinKarp uses the Rabin-Karp search algorithm to return the index of the // first occurrence of substr in s, or -1 if not present. func IndexRabinKarp(s, substr string) int { if len(s) \u003c len(substr) { return -1 } // Rabin-Karp search hashss, pow := HashStr(substr) n := len(substr) var h uint32 for i := 0; i \u003c n; i++ { h = h*PrimeRK + uint32(s[i]) } if h == hashss \u0026\u0026 s[:n] == substr { return 0 } for i := n; i \u003c len(s); { h *= PrimeRK h += uint32(s[i]) h -= pow * uint32(s[i-n]) i++ if h == hashss \u0026\u0026 s[i-n:i] == substr { return i - n } } return -1 } 参考：https://www.cnblogs.com/golove/p/3234673.html ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:5:0","tags":["算法","RK","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 什么是KMP算法？ kmp算法是一种用于高效匹配字符串子串是否存在的算法，比如想知道文本串s中是否存在模式串p，就可以使用kmp算法。 如何实现KMP算法？ 实现kmp算法分两步 基于模式串初始化next数组 使用next数组加速字符串匹配 ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:0:0","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"什么是next数组？ next数组，又称为prefix数组、前缀表，其作用是记录给定字符串的所有子串中相等的前后缀长度。 ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:1:0","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"什么是前缀后缀？ 对于字符串cbccbcbccc，其前缀为包含首字符不包含尾字母的任意子串，其后缀为包含尾字符不包含首字符的任意子串。 前缀 c cb cbc cbcc ... cbccbcbcc 后缀 c cc ccc bccc ... bccbcbccc 对于字符串cbccbcbccc的每一个子串，我们求出它们的最长相等前后缀长度，其中子串c初始化为0。 最长相等前后缀 ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:1:1","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"next数组具体实现 求next数组的代码如下 func getNext(s string) []int { sLen := len(s) next := make([]int, sLen) next[0] = 0 j := 0 for i := 1; i \u003c sLen; i++ { // j要保证大于0，因为下面有取j-1作为数组下标的操作 for j \u003e 0 \u0026\u0026 s[i] != s[j] { // 回退前一位 j = next[j - 1] } if s[i] == s[j] { j++ } next[i] = j } return next } 求出next数组后，我们就可以利用它加速字符串的匹配。 当遇到不匹配时，就往前找一个最长相等前后缀，并移动模式串指针到他的后面，再尝试匹配 不匹配 匹配 当i==j==5时，文本串s[5] != 模式串p[5]，这时我们在next数组中往前找一位，next数组中记录了p[0:5]这个子串最长相等前后缀长度为2，意味着我们j指针只需要回退到下标为2的位置就可以继续匹配了，跳过了前面相同的部分 kmp具体实现 func kmp(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := getNext(needle) // 模式串的起始位置 next为0 因此也为0 j := 0 for i := 0; i \u003c len(haystack); i++ { for j \u003e 0 \u0026\u0026 haystack[i] != needle[j] { // 寻找下一个匹配点 j = next[j-1] } if haystack[i] == needle[j] { j++ } // j指向了模式串的末尾 if j == len(needle) { return i - len(needle) + 1 } } return -1 } func getNext(s string) []int { sLen := len(s) next := make([]int, sLen) next[0] = 0 j := 0 for i := 1; i \u003c sLen; i++ { // j要保证大于0，因为下面有取j-1作为数组下标的操作 for j \u003e 0 \u0026\u0026 s[i] != s[j] { // 回退前一位 j = next[j - 1] } if s[i] == s[j] { j++ } next[i] = j } return next } ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:2:0","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["分享"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 1 引言 本文用于记录日常使用hugo的优化建议，阅读时长10分钟。 适用于以下人员： 已经搭建好Hugo博客 希望使用图床功能 希望自己的博客能在百度和谷歌上搜索到 本文将从以下几点进行优化： 使用GitHub作为博文的图床 让百度和谷歌收录站点 2 使用GitHub作为图床储存图片 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:0:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"什么是图床 图床是一个专门存放图片的服务器，使用图床可以让我们的博客直接从网上获取图片，而无需管理本地图片路径，让我们获得更好的博文书写体验。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:1:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"优雅的使用图床 方案为：VsCode+PicGo插件+GitHub。 VsCode用于书写博客文章，PicGo插件用于快速生成网络图片链接，GitHub作为图片服务器存放图片。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"操作步骤如下： ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:1","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"1.安装VsCode 点击VsCode即可前往下载界面。安装十分简单，不再赘述。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:2","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"2.下载PicGo插件 打开VsCode，在左侧的扩展管理中输入PicGo下载插件。 下载PicGo插件 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:3","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"3.创建GitHub图床仓库 创建一个名字为\u003c你github账户名\u003e.github.io的仓库，我这里的是博客使用的仓库，并使用images目录作为图片存放的目录。 创建GitHub图床仓库 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:4","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"4.生成令牌(Token) 接下来需要生成令牌，让PicGo插件能通过令牌免密上传图片到图床目录。 生成令牌 生成令牌 生成令牌 生成令牌 Token生成之后要及时复制，之后就无法复制了。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:5","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"5.配置PicGo插件 打开VsCode上的PicGo插件，点击小齿轮进行配置。 在配置中找到GitHub的相关配置项，从上到下分别配置：图床目录(必须加上/)，github仓库，Token令牌。 配置PicGo插件 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:6","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"6.测试图床 VsCode上的PicGo插件配置好之后，使用Ctrl+Alt+u可以把剪切版中的图片上传到图床中，并且会在当前VsCode打开的文件中生产一个图片的网络链接。同时我们看GitHub上的images目录时，会发现图片被自动上传了。 测试图床 2 在百度和谷歌上添加网站 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:7","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"为什么要添加网站 在百度和谷歌添加博客的网站之后，就可以通过百度和谷歌的搜索引擎找到自己的博客。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:3:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"收录和站点管理 站点收录：让百度或谷歌知道有这个站点的存在，添加之后需要等1~7天（不同搜索引擎不一样）的时间后才能找到自己的博客。 站点管理：向百度或谷歌证明某个站点是属于你的，即你是网站的管理员。可以通过如下方式进行证明： 在网站首页中增加一个校验值标签 在网页目录中增加一个校验页面 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:4:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"添加收录 测试网址是否被收录：site:hts0000.github.io。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:5:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"百度 检查收录 添加之后百度大概需要一星期的时间进行收录。 检查收录 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:5:1","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"谷歌 检查收录 添加之后谷歌大概需要1~2天的时间来收录网站。 检查收录 收录成功后在谷歌中搜索：site:hts0000.github.io，就可以发现我们的网站可以通过浏览器搜索到了。 检查收录 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:5:2","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"站点管理 通过百度账号和谷歌账号，可以绑定网站，通过百度和谷歌的统计功能，可以看到网站的访问次数和访问情况。 让账号和网站绑定，需要向百度和谷歌证明你是网站的管理员，证明的方法有很多种，这次选择校验页面的方式进行验证。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:6:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"百度 首先在账号中添加网站 站点管理 站点管理 把下载好的校验页面放到网页目录下，向百度证明你是网站的管理员。 站点管理 校验成功后可以在站点管理中看到刚刚添加的站点。 站点管理 点击站点可以看到百度为我们统计的站点信息，如点击率搜索量等等。 站点管理 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:6:1","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"谷歌 谷歌的操作与百度类似，也是在网页的目录下添加校验页面，向谷歌证明你是网站的管理员。 站点管理 添加完成之后也可以通过谷歌统计的站点信息查看网站的点击量等等。 站点管理 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:6:2","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 1 引言 本文用于记录基于HUGO搭建个人博客的步骤和注意事项，阅读时长大概30分钟。 适用于以下人员： 想搭建博客 想了解hugo 闲着没事 2 准备阶段 在开始搭建博客前，希望你已经准备好以下工具，以便能快速的跟上本篇文章。 Git Bash Notepad++ VSCode 文章将会从如下三个大步骤进行展开。 基于HUGO的本地博客 定制本地博客 使用GitHub展示博客内容 3 基于HUGO的本地博客 想要在本地搭建一个基于HUGO的博客，大致有如下三步。 安装hugo 获取一个hugo主题 启动hugo 第一步，安装hugo。 前往hugo的github仓库获取对应操作系统的hugo执行程序。 完成之后打开cmd终端，输入hugo version，如能正确显示hugo的版本即为安装成功。 hugo安装成功 安装成功后在cmd终端执行如下命令，在D盘生成hugo博客站点MyBlog。 hugo new site D:\\MyBlog 第二步，获取HUGO主题。 hugo的主题是博客的门面，博客的风格和样式都基于主题。如果有前端编程的能力，也可以自行设计属于自己的主题，或者前往hugo主题商店下载现成的主题。这里以LoveIt 主题为例。 点击Download前往LoveIt的github仓库进行下载。 下载LoveIt主题 下载LoveIt主题 将下载好的压缩包解压到D:\\MyBlog\\themes目录下，并将目录重命名为LoveIt。 将D:\\MyBlog\\themes\\LoveIt\\exampleSite\\zh目录下的所有文件和D:\\MyBlog\\themes\\LoveIt\\exampleSite\\static目录复制到D:\\MyBlog\\目录下。 zh目录：LoveIt主题的中文配置及界面内容 zh\\config.toml：LoveIt主题的集中配置文件 zh\\content目录：LoveIt主题的默认页面内容 static目录：LoveIt主题的图包 使用Notepad++或其他文本编辑工具打开config.toml文件，将 staticDir = [\"../static\", “../../assets/others”] 改成staticDir = [\"/static\", “../assets/others”]。 第三步，启动本地博客。 在cmd终端执行如下命令，启动监听。 hugo server -D --config D:\\MyBlog\\config.toml 在浏览器访问URL:localhost:1313，可以查看本地博客。 下载LoveIt主题 4 定制本地博客 定制一个充满个人元素的博客大概分为如下三步。 个性化的博客标题和个人介绍 个性化的头像和图标 个性化的博客内容 第一步，定制个人的博客标题和介绍。 关于如何修改博客的标题等，D:\\MyBlog\\config.toml文件内作者有非常完善的注释，大家多修改多尝试（先备份），这里不细讲。 第二步，个性化头像和图标。 点击Favicon Generator，打开Select your Favicon image上传一张你喜欢的图片。 Favicon Generator生成图标 上传之后成功之后来到页面最下方点击Generate your Favicons and HTML code，Favicon Generator会自动分辨率生成符合一系列PC和移动终端的图标。 Favicon Generator生成图标 点击Favicon package下载生成好的图标包。 Favicon Generator下载图标 将下载好的图标包解压，把里面的文件全部复制到D:\\MyBlog\\static\\目录下。 如果想要替换主页的头像图标，需要替换D:\\MyBlog\\static\\images\\avatar.png，推荐分辨率为528*560。 最后整体效果如下图所示。 博客展示 第三步，个性化的博客内容。 博客的最终目的是展示内容，hugo能非常方便的根据文章的设定生成标签(tags)和分类(categories)。下面教大家如何设置文章的模板。 设置博客文章的模板 LoveIt主题中作者已经写好了一个文章模板，这里直接套用这个模板进行修改即可。 首先将D:\\MyBlog\\themes\\LoveIt\\archetypesdefault.md文件复制到D:\\MyBlog\\archetypes目录下，使用VsCode等markdown编辑工具打开。 模板文件 生成一篇博客文章 打开cmd终端，执行如下命令，根据文章模板生成第一篇文章。 # 进入D盘 D: # 进入MyBlog目录 cd MyBlog # 生成博客文章，文章会生成在content/posts目录下 hugo new posts/我的第一篇博客.md # 启动hugo，开启监听 hugo server -D --config D:\\MyBlog\\config.toml 再次访问URL:localhost:1313即可看到刚刚添加的文章。 5 用GitHub展示博客文章 让GitHub仓库展示博客页面，大致有如下四步。 创建一个GitHub账号 创建一个同名仓库 hugo build生成页面 推送到GitHub远程仓库 第一步，创建一个GitHub账号。 网上有很多教程，不再赘述。 第二步，创建一个同名仓库 网上也有很多教程，只强调一点，仓库名称为username.github.io。如：你的用户名叫zhangsan000，则你的仓库名必须为zhangsan000.github.io。 GitHub仓库 第三步，hugo生成静态页面。 打开cmd终端，执行如下命令，生成静态页面。 # 进入D盘 D: # 进入MyBlog目录 cd MyBlog # 生成静态页面 hugo hugo生成静态页面之后在MyBlog目录下会生成public目录存放静态页面。 将静态页面推送到GitHub 打开cmd终端，将GitHub仓库clone到本地。 # 查看git是否正常安装，能正常显示git版本即为安装正确 git version D: cd MyBlog/pubilc # 将你的仓库clone下来 git clone repoURL 然后将所有文件移动到clone下来的仓库目录下，再次打开cmd终端，输入如下命令，将静态页面推送到远程仓库。 D: # 进入git本地仓库 cd MyBlog\\public\\\u003c你的仓库目录\u003e # 将所有的文件添加到本地暂存区 git add . # 提交暂存区的内容 git commit -m 'init MyBlog' # 将本地提交推送到远程 git push 在GitHub上查看提交。 GitHub仓库 最后在浏览器上访问URL:\u003c仓库名称\u003e.github.io即可通过网络访问到静态页面。 GitHub仓库 ","date":"2020-02-15","objectID":"/%E5%9F%BA%E4%BA%8Ehugo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["hugo","分享"],"title":"基于Hugo快速搭建个人博客","uri":"/%E5%9F%BA%E4%BA%8Ehugo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"Hts0000的个人博客 主要分享如下内容 Linux运维 网络基础 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About LoveIt","uri":"/about/"}]