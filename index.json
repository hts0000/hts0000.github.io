[{"categories":["算法 查找算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:0","tags":["算法 查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 查找算法"],"content":"二分查找 对于任何有序集合，我们可以使用二分查找的方式来快速定位到想要的元素。 二分查找的时间复杂度为O(logn) 二分查找的实现难点在于边界条件的判断，要注意集合的闭合区间。实现时闭合区间分为两种：[left,right]和[left,right)，两种不同的闭合区间的代码实现也不同。 ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:0","tags":["算法 查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 查找算法"],"content":"二分查找的边界条件 [left,right] // BinarySearch 查找nums中是否存在target，并返回其下标，如果不存在返回-1 func BinarySearch(nums []int, target int) int { length := len(nums) left, right := 0, length - 1 for left \u003c= right { mid := left + (right - left) / 2 if nums[mid] \u003c target { left = mid + 1 } else if nums[mid] \u003e target { right = mid - 1 } else { return mid } } return -1 } [left,right) // BinarySearch 查找nums中是否存在target，并返回其下标，如果不存在返回-1 func BinarySearch(nums []int, target int) int { length := len(nums) left, right := 0, length for left \u003c right { mid := left + (right - left) / 2 if nums[mid] \u003c target { left = mid + 1 } else if nums[mid] \u003e target { right = mid } else { return mid } } return -1 } ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:1","tags":["算法 查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 查找算法"],"content":"二分查找其他应用 二分查找不仅可以用于有序序列，还可以用于部分有序序列，比如leetcode 153.寻找旋转排序数组中的最小值也可以使用二分法。 由此我们可知，二分查找只是一种查找的思想。对于查找一个值，我们要首先想到如何能跳过一些无意义的比较，收缩左右边界，以达到加快搜索的过程。 ","date":"2022-04-03","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:2","tags":["算法 查找算法"],"title":"二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["bit数组","bitmap"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 什么是bit数组？ bit数组通常为一个无符号数的数组，用每一个元素的每一个bit位来存储数据。 var bitSlice []uint64{0, 0, 0} bit数组bit数组 \" bit数组 当我们存储数据，比如存储2时，对64取商和模为0和2，可知需要将2存储在bitSlice[0]的第2个bit位中，因此我们把bitSlice[0] \u0026 1\u003c\u003c2即可标识2被存储了 把2存储到bitSlice中bit数组 \" 把2存储到bitSlice中 对于更大的数字，比如66，对64取商和模为1和2，可知需要将66存储在bitSlice[1]的第2个bit位中，因此我们把bitSlice[1] \u0026 1\u003c\u003c2即可标识66被存储了 把66存储到bitSlice中\" 把66存储到bitSlice中 bit数组有什么用？ bit数组可以使用很小的存储空间，存储更多的数据。对于uint64而言，如果直接存储，一个数要使用8byte空间，64个数则要64*8byte=512byte，而用bit来存，一个uint64的变量可以存储64个数，空间节省了64倍。 如果我们要对40亿条数据进行排序去重，但机器可用内存只有4G，要怎么做呢？ 我们先来计算一下，4,000,000,000对64取商和模为62,500,000和0，可知数组最大需要62,500,000个元素，而62,500,000 * 8byte = 500,000,000byte ≈ 480M 如果用[]uint32切片直接存储，则需要4,000,000,000 * 4byte = 16,000,000,000byte ≈ 15G 使用bit数组，存储时只会将数所在的bit位 置1，所以只要按顺序取出数据，就是排序去重后的数据。 bit数组应用 bit数组在很多地方都有应用，比如redis中的bitmap就是使用了bit数组的方式实现的。 bit数组实现 package bitmap import ( \"bytes\" \"fmt\" ) // 参考go语言圣经6.5章节 // UINTSIZE 判断当前机器是32位还是64位 // 64位机器^uint(0) = 64位全1，\u003e\u003e 63之后变成只有第一位为1，32 \u003c\u003c 1 = 64 // 32位机器\u003e\u003e 63之后全部位变为0，32 \u003c\u003c 0 = 32 const UINTSIZE = 32 \u003c\u003c (^uint(0) \u003e\u003e 63) // An IntSet is a set of small non-negative integers. // Its zero value represents the empty set. type IntSet struct { words []uint } // Has reports whether the set contains the non-negative value x. func (s *IntSet) Has(x int) bool { word, bit := x/UINTSIZE, uint(x%UINTSIZE) // words长度大于数据所在元素下标，且所在bit位不为0 return word \u003c len(s.words) \u0026\u0026 s.words[word]\u0026(1\u003c\u003cbit) != 0 } // Add adds the non-negative value x to the set. func (s *IntSet) Add(x int) { // 对要存储的数取商和模 word, bit := x/UINTSIZE, uint(x%UINTSIZE) // 如果words数组长度小于商，则扩容至能存下为止 for word \u003e= len(s.words) { s.words = append(s.words, 0) } // 将数存储到指定bit位 s.words[word] |= 1 \u003c\u003c bit } // UnionWith sets s to the union of s and t. // 设置s为s和t的并集 func (s *IntSet) UnionWith(t *IntSet) { for i, tword := range t.words { if i \u003c len(s.words) { // 取并集 // 101 | 010 = 111 s.words[i] |= tword } else { s.words = append(s.words, tword) } } } // IntersectWith sets s to the intersect of s and t // 设置s为s和t的交集 // 元素在s集合t集合均出现 func (s *IntSet) IntersectWith(t *IntSet) { // 如果s比t长，把s截取到t的长度 if len(s.words) \u003e len(t.words) { s.words = s.words[:len(t.words)] } // 如果t比s长，也只会比较s中有的部分 for i, tword := range t.words { if i \u003c len(s.words) { s.words[i] \u0026= tword } } } // DifferenceWith sets s to the difference of s and t // 设置s为s和t的差集 // 元素出现在s集合，未出现在t集合 func (s *IntSet) DifferenceWith(t *IntSet) { for i, tword := range t.words { if i \u003c len(s.words) { // ^: 异或运算，值不同则为1，相同为0 // B A // 100011010 ^ 110101001 = 010110011 // 010110011 \u0026 110101001 = 010100001 // 正好是A中有而B中没有的 s.words[i] \u0026= s.words[i] ^ tword } } } // SymmetricDifference sets s to the symmetric difference of s and t // 设置s为s和t的并查集 // 元素出现在s但没有出现在t，或者出现在t没有出现在s func (s *IntSet) SymmetricDifference(t *IntSet) { for i, tword := range t.words { if i \u003c len(s.words) { s.words[i] ^= tword } else { // 如果s元素个数小于t，则s要把t中多的部分补上 s.words = append(s.words, tword) } } } // String returns the set as a string of the form \"{1 2 3}\". // String方法，fmt.Printf()函数对实现了String方法的类型会直接调用其String()方法进行输出 func (s *IntSet) String() string { var buf bytes.Buffer buf.WriteByte('{') for i, word := range s.words { if word == 0 { continue } // 逐位遍历，如果为1，则将其写入缓冲区 for j := 0; j \u003c UINTSIZE; j++ { if word\u0026(1\u003c\u003cuint(j)) != 0 { if buf.Len() \u003e len(\"{\") { buf.WriteByte(' ') } // UINTSIZE*i+j还原数实际大小 // 比如2存储在[0]的第2个比特位 // UINTSIZE*0+2=2 fmt.Fprintf(\u0026buf, \"%d\", UINTSIZE*i+j) } } } buf.WriteByte('}') return buf.String() } // Len return the number of elements // 返回当前存储了多少个数 func (s *IntSet) Len() int { l := 0 for _, word := range s.words { if word == 0 { continue } for j := 0; j \u003c UINTSIZE; j++ { if word\u0026(1\u003c\u003cuint(j)) != 0 { l++ } } } return l } // Elems returns a slice containing the elements of the set func (s *IntSet) Elems() []int { res := make([]int, s.Len()) k := 0 for i, word := range s.words { if word == 0 { continue } for j := 0; j \u003c UINTSIZE; j++ { if word\u0026(1\u003c\u003cj) != 0 { res[k] = UINTSIZE*i + j k++ } } } return res } // Remove remove x","date":"2022-02-15","objectID":"/bit%E6%95%B0%E7%BB%84/:0:0","tags":["bit数组","bitmap"],"title":"Bit数组/bitmap","uri":"/bit%E6%95%B0%E7%BB%84/"},{"categories":["算法","RK","字符串匹配算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 什么是RK算法？ RK算法是一种字符串匹配算法。核心思想是将字符串映射为其字符集长度的数值(hash值)，将字符串比较变为数值比较，从而可以获得较好的性能。需要注意的是，当hash相同时，字符串任然有小概率不相同，hash不同则不可能相同。 对于文本串s和模式串p，我们计算p的hash值，然后再计算s中长度为len(p)的所有子串的hash值，对比他们是否相同，如果相同还需再比较一次字符串是否相同。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:0:0","tags":["算法","RK","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","RK","字符串匹配算法"],"content":"什么是hash值？ 通过一个hash函数，将输入内容转化为数字，这个数字就是hash值。对于输入的内容相同，hash函数输出的值必须相同且应该尽量唯一。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:1:0","tags":["算法","RK","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","RK","字符串匹配算法"],"content":"如何计算字符串的hash值？ 对于一串数字字符串\"1234\"，我们可以把它看做是10进制数，通过计算:'1'*10^(4-1) + '2'*10^(4-2) + '3'*10^(4-3)+'4'*10^(4-4)将它hash为1234(10^2表示10的2次方,4为字符串长度)。 对于小写字母字符串\"abcd\"，我们可以把它看做是26进制数，通过计算:'a'*26^(4-1) + 'b'*26^(4-2) + 'c'*26^(4-3) + 'd'*26^(4-4)将它hash为19010(‘a’=1,‘b’=2,‘c’=3,’d'=4)。 对于大小写字符混合字符串\"AbCd\"，我们可以把它看做是128进制(ASCII码128个字符)，通过计算:'A'*128^(4-1) + 'b'*128^(4-2) + 'C'*128^(4-3) + 'd'*128^(4-4)，将它们hash为137,929,188(‘A’=65,‘b’=98,‘C’=67,’d'=100)。 通过上述例子可以发现，我们可以把一串字符hash为它们字符集进制的数，那么我们是否可以用Unicode字符集作为进制数？不就可以表示所有字符了？答案是可以的。Unicode字符集所有字符个数为1114112个。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:2:0","tags":["算法","RK","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","RK","字符串匹配算法"],"content":"如何使用hash进行字符串匹配？ 对于文本串s\"12345\"，我们希望知道模式串p\"45\"是否被s包含要如何做？ 以10进制为例。 首先对p进行hash，'4'*10+'5'=45，对s[0:2]进行hash，'1'*10+'2'=12，12不等于45，进行下一轮计算s[1:3]。下一轮计算难道又要'2'*10+'3'=23这样遍历s[1:3]的每一个字符吗？其实不用，我们可以把(12-10)*10+3，这意味着我们总共只需要遍历s串一次，而p串也是一次，这就是rk算法时间复杂度O(m+n)的原因。 ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:3:0","tags":["算法","RK","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","RK","字符串匹配算法"],"content":"常用的字符串hash函数 BKDRHash ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:4:0","tags":["算法","RK","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","RK","字符串匹配算法"],"content":"如何解决hash值相同但字符串不相同的情况 字符串hash难免出现hash值相同的情况，当相同时我们需要额外遍历一遍以确保相同。 Golang中的RK算法应用 // PrimeRK相当于我们上面提到的进制 const PrimeRK = 16777619 // HashStr returns the hash and the appropriate multiplicative // factor for use in Rabin-Karp algorithm. func HashStr(sep string) (uint32, uint32) { hash := uint32(0) for i := 0; i \u003c len(sep); i++ { // 将模式串hash为PrimeRK进制的数 hash = hash*PrimeRK + uint32(sep[i]) } // var pow, sq uint32 = 1, PrimeRK for i := len(sep); i \u003e 0; i \u003e\u003e= 1 { if i\u00261 != 0 { pow *= sq } sq *= sq } return hash, pow } // IndexRabinKarp uses the Rabin-Karp search algorithm to return the index of the // first occurrence of substr in s, or -1 if not present. func IndexRabinKarp(s, substr string) int { if len(s) \u003c len(substr) { return -1 } // Rabin-Karp search hashss, pow := HashStr(substr) n := len(substr) var h uint32 for i := 0; i \u003c n; i++ { h = h*PrimeRK + uint32(s[i]) } if h == hashss \u0026\u0026 s[:n] == substr { return 0 } for i := n; i \u003c len(s); { h *= PrimeRK h += uint32(s[i]) h -= pow * uint32(s[i-n]) i++ if h == hashss \u0026\u0026 s[i-n:i] == substr { return i - n } } return -1 } 参考：https://www.cnblogs.com/golove/p/3234673.html ","date":"2022-02-11","objectID":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/:5:0","tags":["算法","RK","字符串匹配算法"],"title":"Golang中的字符串匹配——RK算法","uri":"/golang%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Drk%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 什么是KMP算法？ kmp算法是一种用于高效匹配字符串子串是否存在的算法，比如想知道文本串s中是否存在模式串p，就可以使用kmp算法。 如何实现KMP算法？ 实现kmp算法分两步 基于模式串初始化next数组 使用next数组加速字符串匹配 ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:0:0","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"什么是next数组？ next数组，又称为prefix数组、前缀表，其作用是记录给定字符串的所有子串中相等的前后缀长度。 ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:1:0","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"什么是前缀后缀？ 对于字符串cbccbcbccc，其前缀为包含首字符不包含尾字母的任意子串，其后缀为包含尾字符不包含首字符的任意子串。 前缀 c cb cbc cbcc ... cbccbcbcc 后缀 c cc ccc bccc ... bccbcbccc 对于字符串cbccbcbccc的每一个子串，我们求出它们的最长相等前后缀长度，其中子串c初始化为0。 最长相等前后缀最长相等前后缀 \" 最长相等前后缀 ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:1:1","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["算法","kmp","字符串匹配算法"],"content":"next数组具体实现 求next数组的代码如下 func getNext(s string) []int { sLen := len(s) next := make([]int, sLen) next[0] = 0 j := 0 for i := 1; i \u003c sLen; i++ { // j要保证大于0，因为下面有取j-1作为数组下标的操作 for j \u003e 0 \u0026\u0026 s[i] != s[j] { // 回退前一位 j = next[j - 1] } if s[i] == s[j] { j++ } next[i] = j } return next } 求出next数组后，我们就可以利用它加速字符串的匹配。 当遇到不匹配时，就往前找一个最长相等前后缀，并移动模式串指针到他的后面，再尝试匹配 不匹配不匹配 \" 不匹配 匹配匹配 \" 匹配 当i==j==5时，文本串s[5] != 模式串p[5]，这时我们在next数组中往前找一位，next数组中记录了p[0:5]这个子串最长相等前后缀长度为2，意味着我们j指针只需要回退到下标为2的位置就可以继续匹配了，跳过了前面相同的部分 kmp具体实现 func kmp(haystack string, needle string) int { if len(needle) == 0 { return 0 } next := getNext(needle) // 模式串的起始位置 next为0 因此也为0 j := 0 for i := 0; i \u003c len(haystack); i++ { for j \u003e 0 \u0026\u0026 haystack[i] != needle[j] { // 寻找下一个匹配点 j = next[j-1] } if haystack[i] == needle[j] { j++ } // j指向了模式串的末尾 if j == len(needle) { return i - len(needle) + 1 } } return -1 } func getNext(s string) []int { sLen := len(s) next := make([]int, sLen) next[0] = 0 j := 0 for i := 1; i \u003c sLen; i++ { // j要保证大于0，因为下面有取j-1作为数组下标的操作 for j \u003e 0 \u0026\u0026 s[i] != s[j] { // 回退前一位 j = next[j - 1] } if s[i] == s[j] { j++ } next[i] = j } return next } ","date":"2022-02-11","objectID":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/:2:0","tags":["算法","kmp","字符串匹配算法"],"title":"如何实现kmp算法","uri":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0kmp%E7%AE%97%E6%B3%95/"},{"categories":["分享"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 1 引言 本文用于记录日常使用hugo的优化建议，阅读时长10分钟。 适用于以下人员： 已经搭建好Hugo博客 希望使用图床功能 希望自己的博客能在百度和谷歌上搜索到 本文将从以下几点进行优化： 使用GitHub作为博文的图床 让百度和谷歌收录站点 2 使用GitHub作为图床储存图片 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:0:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"什么是图床 图床是一个专门存放图片的服务器，使用图床可以让我们的博客直接从网上获取图片，而无需管理本地图片路径，让我们获得更好的博文书写体验。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:1:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"优雅的使用图床 方案为：VsCode+PicGo插件+GitHub。 VsCode用于书写博客文章，PicGo插件用于快速生成网络图片链接，GitHub作为图片服务器存放图片。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"操作步骤如下： ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:1","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"1.安装VsCode 点击VsCode即可前往下载界面。安装十分简单，不再赘述。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:2","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"2.下载PicGo插件 打开VsCode，在左侧的扩展管理中输入PicGo下载插件。 下载PicGo插件下载PicGo插件 \" 下载PicGo插件 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:3","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"3.创建GitHub图床仓库 创建一个名字为\u003c你github账户名\u003e.github.io的仓库，我这里的是博客使用的仓库，并使用images目录作为图片存放的目录。 创建GitHub图床仓库创建GitHub图床仓库 \" 创建GitHub图床仓库 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:4","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"4.生成令牌(Token) 接下来需要生成令牌，让PicGo插件能通过令牌免密上传图片到图床目录。 生成令牌生成令牌 \" 生成令牌 生成令牌生成令牌 \" 生成令牌 生成令牌生成令牌 \" 生成令牌 生成令牌生成令牌 \" 生成令牌 Token生成之后要及时复制，之后就无法复制了。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:5","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"5.配置PicGo插件 打开VsCode上的PicGo插件，点击小齿轮进行配置。 在配置中找到GitHub的相关配置项，从上到下分别配置：图床目录(必须加上/)，github仓库，Token令牌。 配置PicGo插件配置PicGo插件 \" 配置PicGo插件 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:6","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"6.测试图床 VsCode上的PicGo插件配置好之后，使用Ctrl+Alt+u可以把剪切版中的图片上传到图床中，并且会在当前VsCode打开的文件中生产一个图片的网络链接。同时我们看GitHub上的images目录时，会发现图片被自动上传了。 测试图床测试图床 \" 测试图床 2 在百度和谷歌上添加网站 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:2:7","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"为什么要添加网站 在百度和谷歌添加博客的网站之后，就可以通过百度和谷歌的搜索引擎找到自己的博客。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:3:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"收录和站点管理 站点收录：让百度或谷歌知道有这个站点的存在，添加之后需要等1~7天（不同搜索引擎不一样）的时间后才能找到自己的博客。 站点管理：向百度或谷歌证明某个站点是属于你的，即你是网站的管理员。可以通过如下方式进行证明： 在网站首页中增加一个校验值标签 在网页目录中增加一个校验页面 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:4:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"添加收录 测试网址是否被收录：site:hts0000.github.io。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:5:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"百度 检查收录检查收录 \" 检查收录 添加之后百度大概需要一星期的时间进行收录。 检查收录检查收录 \" 检查收录 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:5:1","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"谷歌 检查收录检查收录 \" 检查收录 添加之后谷歌大概需要1~2天的时间来收录网站。 检查收录检查收录 \" 检查收录 收录成功后在谷歌中搜索：site:hts0000.github.io，就可以发现我们的网站可以通过浏览器搜索到了。 检查收录检查收录 \" 检查收录 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:5:2","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"站点管理 通过百度账号和谷歌账号，可以绑定网站，通过百度和谷歌的统计功能，可以看到网站的访问次数和访问情况。 让账号和网站绑定，需要向百度和谷歌证明你是网站的管理员，证明的方法有很多种，这次选择校验页面的方式进行验证。 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:6:0","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"百度 首先在账号中添加网站 站点管理站点管理 \" 站点管理 站点管理站点管理 \" 站点管理 把下载好的校验页面放到网页目录下，向百度证明你是网站的管理员。 站点管理站点管理 \" 站点管理 校验成功后可以在站点管理中看到刚刚添加的站点。 站点管理站点管理 \" 站点管理 点击站点可以看到百度为我们统计的站点信息，如点击率搜索量等等。 站点管理站点管理 \" 站点管理 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:6:1","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"谷歌 谷歌的操作与百度类似，也是在网页的目录下添加校验页面，向谷歌证明你是网站的管理员。 站点管理站点管理 \" 站点管理 添加完成之后也可以通过谷歌统计的站点信息查看网站的点击量等等。 站点管理站点管理 \" 站点管理 ","date":"2020-02-16","objectID":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/:6:2","tags":["hugo","分享"],"title":"Hugo日常使用优化","uri":"/hugo%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"categories":["分享"],"content":"转载请注明出处：https://hts0000.github.io/ 欢迎与我联系：hts_0000@sina.com 1 引言 本文用于记录基于HUGO搭建个人博客的步骤和注意事项，阅读时长大概30分钟。 适用于以下人员： 想搭建博客 想了解hugo 闲着没事 2 准备阶段 在开始搭建博客前，希望你已经准备好以下工具，以便能快速的跟上本篇文章。 Git Bash Notepad++ VSCode 文章将会从如下三个大步骤进行展开。 基于HUGO的本地博客 定制本地博客 使用GitHub展示博客内容 3 基于HUGO的本地博客 想要在本地搭建一个基于HUGO的博客，大致有如下三步。 安装hugo 获取一个hugo主题 启动hugo 第一步，安装hugo。 前往hugo的github仓库获取对应操作系统的hugo执行程序。 完成之后打开cmd终端，输入hugo version，如能正确显示hugo的版本即为安装成功。 hugo安装成功hugo安装成功 \" hugo安装成功 安装成功后在cmd终端执行如下命令，在D盘生成hugo博客站点MyBlog。 hugo new site D:\\MyBlog 第二步，获取HUGO主题。 hugo的主题是博客的门面，博客的风格和样式都基于主题。如果有前端编程的能力，也可以自行设计属于自己的主题，或者前往hugo主题商店下载现成的主题。这里以LoveIt 主题为例。 点击Download前往LoveIt的github仓库进行下载。 下载LoveIt主题下载LoveIt主题 \" 下载LoveIt主题 下载LoveIt主题下载LoveIt主题 \" 下载LoveIt主题 将下载好的压缩包解压到D:\\MyBlog\\themes目录下，并将目录重命名为LoveIt。 将D:\\MyBlog\\themes\\LoveIt\\exampleSite\\zh目录下的所有文件和D:\\MyBlog\\themes\\LoveIt\\exampleSite\\static目录复制到D:\\MyBlog\\目录下。 zh目录：LoveIt主题的中文配置及界面内容 zh\\config.toml：LoveIt主题的集中配置文件 zh\\content目录：LoveIt主题的默认页面内容 static目录：LoveIt主题的图包 使用Notepad++或其他文本编辑工具打开config.toml文件，将 staticDir = [\"../static\", “../../assets/others”] 改成staticDir = [\"/static\", “../assets/others”]。 第三步，启动本地博客。 在cmd终端执行如下命令，启动监听。 hugo server -D --config D:\\MyBlog\\config.toml 在浏览器访问URL:localhost:1313，可以查看本地博客。 下载LoveIt主题下载LoveIt主题 \" 下载LoveIt主题 4 定制本地博客 定制一个充满个人元素的博客大概分为如下三步。 个性化的博客标题和个人介绍 个性化的头像和图标 个性化的博客内容 第一步，定制个人的博客标题和介绍。 关于如何修改博客的标题等，D:\\MyBlog\\config.toml文件内作者有非常完善的注释，大家多修改多尝试（先备份），这里不细讲。 第二步，个性化头像和图标。 点击Favicon Generator，打开Select your Favicon image上传一张你喜欢的图片。 Favicon Generator生成图标Favicon Generator生成图标 \" Favicon Generator生成图标 上传之后成功之后来到页面最下方点击Generate your Favicons and HTML code，Favicon Generator会自动分辨率生成符合一系列PC和移动终端的图标。 Favicon Generator生成图标Favicon Generator生成图标 \" Favicon Generator生成图标 点击Favicon package下载生成好的图标包。 Favicon Generator下载图标Favicon Generator下载图标 \" Favicon Generator下载图标 将下载好的图标包解压，把里面的文件全部复制到D:\\MyBlog\\static\\目录下。 如果想要替换主页的头像图标，需要替换D:\\MyBlog\\static\\images\\avatar.png，推荐分辨率为528*560。 最后整体效果如下图所示。 博客展示博客展示 \" 博客展示 第三步，个性化的博客内容。 博客的最终目的是展示内容，hugo能非常方便的根据文章的设定生成标签(tags)和分类(categories)。下面教大家如何设置文章的模板。 设置博客文章的模板 LoveIt主题中作者已经写好了一个文章模板，这里直接套用这个模板进行修改即可。 首先将D:\\MyBlog\\themes\\LoveIt\\archetypesdefault.md文件复制到D:\\MyBlog\\archetypes目录下，使用VsCode等markdown编辑工具打开。 模板文件模板文件 \" 模板文件 生成一篇博客文章 打开cmd终端，执行如下命令，根据文章模板生成第一篇文章。 # 进入D盘 D: # 进入MyBlog目录 cd MyBlog # 生成博客文章，文章会生成在content/posts目录下 hugo new posts/我的第一篇博客.md # 启动hugo，开启监听 hugo server -D --config D:\\MyBlog\\config.toml 再次访问URL:localhost:1313即可看到刚刚添加的文章。 5 用GitHub展示博客文章 让GitHub仓库展示博客页面，大致有如下四步。 创建一个GitHub账号 创建一个同名仓库 hugo build生成页面 推送到GitHub远程仓库 第一步，创建一个GitHub账号。 网上有很多教程，不再赘述。 第二步，创建一个同名仓库 网上也有很多教程，只强调一点，仓库名称为username.github.io。如：你的用户名叫zhangsan000，则你的仓库名必须为zhangsan000.github.io。 GitHub仓库GitHub仓库 \" GitHub仓库 第三步，hugo生成静态页面。 打开cmd终端，执行如下命令，生成静态页面。 # 进入D盘 D: # 进入MyBlog目录 cd MyBlog # 生成静态页面 hugo hugo生成静态页面之后在MyBlog目录下会生成public目录存放静态页面。 将静态页面推送到GitHub 打开cmd终端，将GitHub仓库clone到本地。 # 查看git是否正常安装，能正常显示git版本即为安装正确 git version D: cd MyBlog/pubilc # 将你的仓库clone下来 git clone repoURL 然后将所有文件移动到clone下来的仓库目录下，再次打开cmd终端，输入如下命令，将静态页面推送到远程仓库。 D: # 进入git本地仓库 cd MyBlog\\public\\\u003c你的仓库目录\u003e # 将所有的文件添加到本地暂存区 git add . # 提交暂存区的内容 git commit -m 'init MyBlog' # 将本地提交推送到远程 git push 在GitHub上查看提交。 GitHub仓库GitHub仓库 \" GitHub仓库 最后在浏览器上访问URL:\u003c仓库名称\u003e.github.io即可通过网络访问到静态页面。 GitHub仓库GitHub仓库 \" GitHub仓库 ","date":"2020-02-15","objectID":"/%E5%9F%BA%E4%BA%8Ehugo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["hugo","分享"],"title":"基于Hugo快速搭建个人博客","uri":"/%E5%9F%BA%E4%BA%8Ehugo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"Hts0000的个人博客 主要分享如下内容 Linux运维 网络基础 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About LoveIt","uri":"/about/"}]